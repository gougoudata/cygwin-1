#!/usr/bin/perl -w
# -*- cperl -*-
#
# gtk-doc - GTK DocBook documentation generator.
# Copyright (C) 1998  Damon Chaplin
#               2007,2008,2009  Stefan Kost
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#

#############################################################################
# Script      : gtkdoc-mkdb
# Description : This creates the DocBook files from the edited templates.
#############################################################################

use strict;
use Getopt::Long;

push @INC, '/usr/share/gtk-doc/data';
require "gtkdoc-common.pl";

# Options

# name of documentation module
my $MODULE;
my $TMPL_DIR;
my $SGML_OUTPUT_DIR;
my @SOURCE_DIRS;
my $SOURCE_SUFFIXES = "";
my $IGNORE_FILES = "";
my $PRINT_VERSION;
my $PRINT_HELP;
my $MAIN_SGML_FILE;
my $EXPAND_CONTENT_FILES = "";
my $INLINE_MARKUP_MODE;
my $DEFAULT_STABILITY;
my $DEFAULT_INCLUDES;
my $OUTPUT_FORMAT;
my $NAME_SPACE = "";
my $OUTPUT_ALL_SYMBOLS;
my $OUTPUT_SYMBOLS_WITHOUT_SINCE;

my %optctl = ('module' => \$MODULE,
              'source-dir' => \@SOURCE_DIRS,
              'source-suffixes' => \$SOURCE_SUFFIXES,
              'ignore-files' => \$IGNORE_FILES,
              'output-dir' => \$SGML_OUTPUT_DIR,
              'tmpl-dir' => \$TMPL_DIR,
              'version' => \$PRINT_VERSION,
              'help' => \$PRINT_HELP,
              'main-sgml-file' => \$MAIN_SGML_FILE,
              'expand-content-files' => \$EXPAND_CONTENT_FILES,
              'sgml-mode' => \$INLINE_MARKUP_MODE,
              'xml-mode' => \$INLINE_MARKUP_MODE,
              'default-stability' => \$DEFAULT_STABILITY,
              'default-includes' => \$DEFAULT_INCLUDES,
              'output-format' => \$OUTPUT_FORMAT,
              'name-space' => \$NAME_SPACE,
              'outputallsymbols' => \$OUTPUT_ALL_SYMBOLS,
              'outputsymbolswithoutsince' => \$OUTPUT_SYMBOLS_WITHOUT_SINCE
              );
GetOptions(\%optctl, "module=s", "source-dir:s", "source-suffixes:s",
    "ignore-files:s", "output-dir:s", "tmpl-dir:s", "version", "outputallsymbols",
    "outputsymbolswithoutsince",
    "expand-content-files:s", "main-sgml-file:s", "extra-db-files:s", "help",
    "sgml-mode", "xml-mode", "default-stability:s", "default-includes:s",
    "output-format:s", "name-space:s");

if ($PRINT_VERSION) {
    print "1.18\n";
    exit 0;
}

if (!$MODULE) {
    $PRINT_HELP = 1;
}

if ($DEFAULT_STABILITY && $DEFAULT_STABILITY ne "Stable"
    && $DEFAULT_STABILITY ne "Private" && $DEFAULT_STABILITY ne "Unstable") {
    $PRINT_HELP = 1;
}

if ($PRINT_HELP) {
    print <<EOF;
gtkdoc-mkdb version 1.18 - generate docbook files

--module=MODULE_NAME       Name of the doc module being parsed
--source-dir=DIRNAME       Directories which contain inline reference material
--source-suffixes=SUFFIXES Suffixes of source files to scan, comma-separated
--ignore-files=FILES       Files or directories which should not be scanned
                           May be used more than once for multiple directories
--output-dir=DIRNAME       Directory to put the generated DocBook files in
--tmpl-dir=DIRNAME         Directory in which template files may be found
--main-sgml-file=FILE      File containing the toplevel DocBook file.
--expand-content-files=FILES Extra DocBook files to expand abbreviations in.
--output-format=FORMAT     Format to use for the generated docbook, XML or SGML.
--{xml,sgml}-mode          Allow DocBook markup in inline documentation.
--default-stability=LEVEL  Specify default stability Level. Valid values are
                           Stable, Unstable, or Private.
--default-includes=FILENAMES Specify default includes for section Synopsis
--name-space=NS            Omit namespace in index.
--version                  Print the version of this program
--help                     Print this help
EOF
    exit 0;
}

my ($empty_element_end, $doctype_header);

# autodetect output format
if (! defined($OUTPUT_FORMAT) || ($OUTPUT_FORMAT eq "")) {
    if (!$MAIN_SGML_FILE) {
        if (-e "${MODULE}-docs.xml") {
            $OUTPUT_FORMAT = "xml";
        } else {
            $OUTPUT_FORMAT = "sgml";
        }
    } else {
        if ($MAIN_SGML_FILE =~ m/.*\.(.*ml)$/i) {
            $OUTPUT_FORMAT = lc($1);
        }
    }

} else {
    $OUTPUT_FORMAT = lc($OUTPUT_FORMAT);
}

#print "DEBUG: output-format: [$OUTPUT_FORMAT]\n";

if ($OUTPUT_FORMAT eq "xml") {
    if (!$MAIN_SGML_FILE) {
        # backwards compatibility
        if (-e "${MODULE}-docs.sgml") {
            $MAIN_SGML_FILE = "${MODULE}-docs.sgml";
        } else {
            $MAIN_SGML_FILE = "${MODULE}-docs.xml";
        }
    }
    $empty_element_end = "/>";

    if (-e $MAIN_SGML_FILE) {
        open(INPUT, "<$MAIN_SGML_FILE") || die "Can't open $MAIN_SGML_FILE";
        $doctype_header = "";
        while (<INPUT>) {
            if (/^\s*<(book|chapter|article)/) {
                # check that the top-level tag or the doctype decl contain the xinclude namespace decl
                if (($_ !~ m/http:\/\/www.w3.org\/200[13]\/XInclude/) && ($doctype_header !~ m/http:\/\/www.w3.org\/200[13]\/XInclude/m)) {
                    $doctype_header = "";
                }
                last;
            }
            $doctype_header .= $_;
        }
        close(INPUT);
        $doctype_header =~ s/<!DOCTYPE \w+/<!DOCTYPE refentry/;
        # if there are SYSTEM ENTITIES here, we should prepend "../" to the path
        # FIXME: not sure if we can do this now, as people already work-around the problem
        # $doctype_header =~ s#<!ENTITY % ([a-zA-Z-]+) SYSTEM \"([^/][a-zA-Z./]+)\">#<!ENTITY % $1 SYSTEM \"../$2\">#g;
    } else {
        $doctype_header =
"<?xml version=\"1.0\"?>\n" .
"<!DOCTYPE refentry PUBLIC \"-//OASIS//DTD DocBook XML V4.3//EN\"\n" .
"               \"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd\"\n" .
"[\n" .
"  <!ENTITY % local.common.attrib \"xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'\">\n" .
"]>\n";
    }
} else {
    if (!$MAIN_SGML_FILE) {
        $MAIN_SGML_FILE = "${MODULE}-docs.sgml";
    }
    $empty_element_end = ">";
    $doctype_header = "";
}

my $ROOT_DIR = ".";

# All the files are written in subdirectories beneath here.
$TMPL_DIR = $TMPL_DIR ? $TMPL_DIR : "$ROOT_DIR/tmpl";

# This is where we put all the DocBook output.
$SGML_OUTPUT_DIR = $SGML_OUTPUT_DIR ? $SGML_OUTPUT_DIR : "$ROOT_DIR/$OUTPUT_FORMAT";

# This file contains the object hierarchy.
my $OBJECT_TREE_FILE = "$ROOT_DIR/$MODULE.hierarchy";

# This file contains the interfaces.
my $INTERFACES_FILE = "$ROOT_DIR/$MODULE.interfaces";

# This file contains the prerequisites.
my $PREREQUISITES_FILE = "$ROOT_DIR/$MODULE.prerequisites";

# This file contains signal arguments and names.
my $SIGNALS_FILE = "$ROOT_DIR/$MODULE.signals";

# The file containing Arg information.
my $ARGS_FILE = "$ROOT_DIR/$MODULE.args";

# These global arrays store information on signals. Each signal has an entry
# in each of these arrays at the same index, like a multi-dimensional array.
my @SignalObjects;        # The GtkObject which emits the signal.
my @SignalNames;        # The signal name.
my @SignalReturns;        # The return type.
my @SignalFlags;        # Flags for the signal
my @SignalPrototypes;        # The rest of the prototype of the signal handler.

# These global arrays store information on Args. Each Arg has an entry
# in each of these arrays at the same index, like a multi-dimensional array.
my @ArgObjects;                # The GtkObject which has the Arg.
my @ArgNames;                # The Arg name.
my @ArgTypes;                # The Arg type - gint, GtkArrowType etc.
my @ArgFlags;                # How the Arg can be used - readable/writable etc.
my @ArgNicks;                # The nickname of the Arg.
my @ArgBlurbs;          # Docstring of the Arg.
my @ArgDefaults;        # Default value of the Arg.
my @ArgRanges;                # The range of the Arg type
# These global hashes store declaration info keyed on a symbol name.
my %Declarations;
my %DeclarationTypes;
my %DeclarationConditional;
my %DeclarationOutput;
my %Deprecated;
my %Since;
my %StabilityLevel;
my %StructHasTypedef;

# These global hashes store the existing documentation.
my %SymbolDocs;
my %SymbolTypes;
my %SymbolParams;
my %SymbolSourceFile;
my %SymbolSourceLine;

# These global hashes store documentation scanned from the source files.
my %SourceSymbolDocs;
my %SourceSymbolParams;
my %SourceSymbolSourceFile;
my %SourceSymbolSourceLine;

# all documentation goes in here, so we can do coverage analysis
my %AllSymbols;
my %AllIncompleteSymbols;
my %AllUnusedSymbols;
my %AllDocumentedSymbols;

# Undeclared yet documented symbols
my %UndeclaredSymbols;

# These global arrays store GObject, subclasses and the hierarchy (also of
# non-object derived types).
my @Objects;
my @ObjectLevels;
my %ObjectRoots;

my %Interfaces;
my %Prerequisites;

# holds the symbols which are mentioned in $MODULE-sections.txt and in which
# section they are defined
my %KnownSymbols;
my %SymbolSection;
my %SymbolSectionId;

# collects index entries
my %IndexEntriesFull;
my %IndexEntriesSince;
my %IndexEntriesDeprecated;

# Standard C preprocessor directives, which we ignore for '#' abbreviations.
my %PreProcessorDirectives;
$PreProcessorDirectives{"assert"} = 1;
$PreProcessorDirectives{"define"} = 1;
$PreProcessorDirectives{"elif"} = 1;
$PreProcessorDirectives{"else"} = 1;
$PreProcessorDirectives{"endif"} = 1;
$PreProcessorDirectives{"error"} = 1;
$PreProcessorDirectives{"if"} = 1;
$PreProcessorDirectives{"ifdef"} = 1;
$PreProcessorDirectives{"ifndef"} = 1;
$PreProcessorDirectives{"include"} = 1;
$PreProcessorDirectives{"line"} = 1;
$PreProcessorDirectives{"pragma"} = 1;
$PreProcessorDirectives{"unassert"} = 1;
$PreProcessorDirectives{"undef"} = 1;
$PreProcessorDirectives{"warning"} = 1;

# remember used annotation (to write minimal glossary)
my %AnnotationsUsed;

# the annotations are defined at:
# http://live.gnome.org/GObjectIntrospection/Annotations
my %AnnotationDefinition = (
    'allow-none' => "NULL is ok, both for passing and for returning.",
    'array' => "Parameter points to an array of items.",
    'closure' => "This parameter is a 'user_data', for callbacks; many bindings can pass NULL here.",
    'default' => "Default parameter value (for in case the <acronym>shadows</acronym>-to function has less parameters).",
    'element-type' => "Generics and defining elements of containers and arrays.",
    'error-domains' => "Typed errors. Similar to throws in Java.",
    'in' => "Parameter for input. Default is <acronym>transfer none</acronym>.",
    'inout' => "Parameter for input and for returning results. Default is <acronym>transfer full</acronym>.",
    'in-out' => "Parameter for input and for returning results. Default is <acronym>transfer full</acronym>.",
    'not-error' => "A GError parameter is not to be handled like a normal GError.",
    'out' => "Parameter for returning results. Default is <acronym>transfer full</acronym>.",
    'transfer container' => "Free data container after the code is done.",
    'transfer full' => "Free data after the code is done.",
    'transfer none' => "Don't free data after the code is done.",
    'scope call' => "The callback is valid only during the call to the method.",
    'scope async' => "The callback is valid until first called.",
    'scope notified' => "The callback is valid until the GDestroyNotify argument is called.",
    'type' => "Override the parsed C type with given type"
);

# Create the root DocBook output directory if it doens't exist.
if (! -e $SGML_OUTPUT_DIR) {
    mkdir ("$SGML_OUTPUT_DIR", 0777)
        || die "Can't create directory: $SGML_OUTPUT_DIR";
}

# Function and other declaration output settings.
my $RETURN_TYPE_FIELD_WIDTH = 20;
my $SYMBOL_FIELD_WIDTH = 36;
my $SIGNAL_FIELD_WIDTH = 16;
my $PARAM_FIELD_COUNT = 2;

&ReadKnownSymbols ("$ROOT_DIR/$MODULE-sections.txt");
&ReadSignalsFile ($SIGNALS_FILE);
&ReadArgsFile ($ARGS_FILE);
&ReadObjectHierarchy;
&ReadInterfaces;
&ReadPrerequisites;

&ReadDeclarationsFile ("$ROOT_DIR/$MODULE-decl.txt", 0);
if (-f "$ROOT_DIR/$MODULE-overrides.txt") {
    &ReadDeclarationsFile ("$ROOT_DIR/$MODULE-overrides.txt", 1);
}

for my $dir (@SOURCE_DIRS) {
    &ReadSourceDocumentation ($dir);
}

my $changed = &OutputSGML ("$ROOT_DIR/$MODULE-sections.txt");

# If any of the DocBook SGML files have changed, update the timestamp file (so
# it can be used for Makefile dependencies).
if ($changed || ! -e "$ROOT_DIR/sgml.stamp") {

    # try to detect the common prefix
    # GtkWidget, GTK_WIDGET, gtk_widget -> gtk
    if ($NAME_SPACE eq "") {
        $NAME_SPACE="";
        my $pos=0;
        my $ratio=0.0;
        do {
            my %prefix;
            my $letter="";
            foreach my $symbol (keys(%IndexEntriesFull)) {
                if(($NAME_SPACE eq "") || $symbol =~ /^$NAME_SPACE/i) {
                    if (length($symbol)>$pos) {
                        $letter=substr($symbol,$pos,1);
                        # stop prefix scanning
                        if ($letter eq "_") {
                            # stop on "_"
                            last;
                        }
                        # Should we also stop on a uppercase char, if last was lowercase
                        #   GtkWidget, if we have the 'W' and had the 't' before
                        # or should we count upper and lowercase, and stop one 2nd uppercase, if we already had a lowercase
                        #   GtkWidget, the 'W' would be the 2nd uppercase and with 't','k' we had lowercase chars before
                        # need to recound each time as this is per symbol
                        $prefix{uc($letter)}++;
                    }
                }
            }
            if ($letter ne "" && $letter ne "_") {
                my $maxletter="";
                my $maxsymbols=0;
                foreach $letter (keys(%prefix)) {
                    #print "$letter: $prefix{$letter}.\n";
                    if ($prefix{$letter}>$maxsymbols) {
                        $maxletter=$letter;
                        $maxsymbols=$prefix{$letter};
                    }
                }
                $ratio = scalar(keys(%IndexEntriesFull)) / $prefix{$maxletter};
                #print "most symbols start with $maxletter, that is ". (100 * $ratio) ." %\n";
                if ($ratio > 0.9) {
                    # do another round
                    $NAME_SPACE .= $maxletter;
                }
                $pos++;
            }
            else {
                $ratio=0.0;
            }
        } while ($ratio > 0.9);
        #print "most symbols start with $NAME_SPACE\n";
    }

    &OutputIndexFull;
    &OutputDeprecatedIndex;
    &OutputSinceIndexes;
    &OutputAnnotationGlossary;

    open (TIMESTAMP, ">$ROOT_DIR/sgml.stamp")
        || die "Can't create $ROOT_DIR/sgml.stamp: $!";
    print (TIMESTAMP "timestamp");
    close (TIMESTAMP);
}

#############################################################################
# Function    : OutputObjectList
# Description : This outputs the alphabetical list of objects, in a columned
#                table.
#               FIXME: Currently this also outputs ancestor objects
#                which may not actually be in this module.
# Arguments   : none
#############################################################################

sub OutputObjectList {
    my $cols = 3;

    # FIXME: use $OUTPUT_FORMAT
    # my $old_object_index = "$SGML_OUTPUT_DIR/object_index.$OUTPUT_FORMAT";
    my $old_object_index = "$SGML_OUTPUT_DIR/object_index.sgml";
    my $new_object_index = "$SGML_OUTPUT_DIR/object_index.new";

    open (OUTPUT, ">$new_object_index")
        || die "Can't create $new_object_index: $!";

    if ($OUTPUT_FORMAT eq "xml") {
        my $header = $doctype_header;

        $header =~ s/<!DOCTYPE \w+/<!DOCTYPE informaltable/;
        print (OUTPUT "$header");
    }

    print (OUTPUT <<EOF);
<informaltable pgwide="1" frame="none">
<tgroup cols="$cols">
<colspec colwidth="1*"${empty_element_end}
<colspec colwidth="1*"${empty_element_end}
<colspec colwidth="1*"${empty_element_end}
<tbody>
EOF

    my $count = 0;
    my $object;
    foreach $object (sort (@Objects)) {
        my $xref = &MakeXRef ($object);
        if ($count % $cols == 0) { print (OUTPUT "<row>\n"); }
        print (OUTPUT "<entry>$xref</entry>\n");
        if ($count % $cols == ($cols - 1)) { print (OUTPUT "</row>\n"); }
        $count++;
    }
    if ($count == 0) {
        # emit an empty row, since empty tables are invalid
        print (OUTPUT "<row><entry> </entry></row>\n");
    }
    else {
        if ($count % $cols > 0) {
            print (OUTPUT "</row>\n");
        }
    }

    print (OUTPUT <<EOF);
</tbody></tgroup></informaltable>
EOF
    close (OUTPUT);

    &UpdateFileIfChanged ($old_object_index, $new_object_index, 0);
}


#############################################################################
# Function    : OutputSGML
# Description : This collects the output for each section of the docs, and
#                outputs each file when the end of the section is found.
# Arguments   : $file - the $MODULE-sections.txt file which contains all of
#                the functions/macros/structs etc. being documented, organised
#                into sections and subsections.
#############################################################################

sub OutputSGML {
    my ($file) = @_;

    #print "Reading: $file\n";
    open (INPUT, $file)
        || die "Can't open $file: $!";
    my $filename = "";
    my $book_top = "";
    my $book_bottom = "";
    my $includes = (defined $DEFAULT_INCLUDES) ? $DEFAULT_INCLUDES : "";
    my $section_includes = "";
    my $in_section = 0;
    my $title = "";
    my $section_id = "";
    my $subsection = "";
    my $synopsis;
    my $details;
    my $num_symbols;
    my $changed = 0;
    my $signals_synop = "";
    my $signals_desc = "";
    my $args_synop = "";
    my $child_args_synop = "";
    my $style_args_synop = "";
    my $args_desc = "";
    my $child_args_desc = "";
    my $style_args_desc = "";
    my $hierarchy = "";
    my $interfaces = "";
    my $implementations = "";
    my $prerequisites = "";
    my $derived = "";
    my @file_objects = ();
    my %templates = ();
    my %symbol_def_line = ();

    # merge the source docs, in case there are no templates
    &MergeSourceDocumentation;

    while (<INPUT>) {
        if (m/^#/) {
            next;

        } elsif (m/^<SECTION>/) {
            $synopsis = "";
            $details = "";
            $num_symbols = 0;
            $in_section = 1;
            @file_objects = ();
            %symbol_def_line = ();

        } elsif (m/^<SUBSECTION\s*(.*)>/i) {
            $synopsis .= "\n";
            $subsection = $1;

        } elsif (m/^<SUBSECTION>/) {

        } elsif (m/^<TITLE>(.*)<\/TITLE>/) {
            $title = $1;
            #print "Section: $title\n";

            # We don't want warnings if object & class structs aren't used.
            $DeclarationOutput{$title} = 1;
            $DeclarationOutput{"${title}Class"} = 1;
            $DeclarationOutput{"${title}Iface"} = 1;
            $DeclarationOutput{"${title}Interface"} = 1;

        } elsif (m/^<FILE>(.*)<\/FILE>/) {
            $filename = $1;
            if (! defined $templates{$filename}) {
               if (&ReadTemplateFile ("$TMPL_DIR/$filename", 1)) {
                   &MergeSourceDocumentation;
                   $templates{$filename}=$.;
               }
            } else {
                &LogWarning ($file, $., "Double <FILE>$filename</FILE> entry. ".
                    "Previous occurrence on line ".$templates{$filename}.".");
            }
            if (($title eq "") and (defined $SourceSymbolDocs{"$TMPL_DIR/$filename:Title"})) {
                $title = $SourceSymbolDocs{"$TMPL_DIR/$filename:Title"};
                 # Remove trailing blanks
                $title =~ s/\s+$//;
           }

        } elsif (m/^<INCLUDE>(.*)<\/INCLUDE>/) {
            if ($in_section) {
                $section_includes = $1;
            } else {
                if (defined $DEFAULT_INCLUDES) {
                    &LogWarning ($file, $., "Default <INCLUDE> being overridden by command line option.");
                }
                else {
                    $includes = $1;
                }
            }

        } elsif (m/^<\/SECTION>/) {
            #print "End of section: $title\n";
            if ($num_symbols > 0) {
                # collect documents
                if ($OUTPUT_FORMAT eq "xml") {
                    $book_bottom .= "    <xi:include href=\"xml/$filename.xml\"/>\n";
                } else {
                    $book_top.="<!ENTITY $section_id SYSTEM \"sgml/$filename.sgml\">\n";
                    $book_bottom .= "    &$section_id;\n";
                }

                if (defined ($SourceSymbolDocs{"$TMPL_DIR/$filename:Include"})) {
                    if ($section_includes) {
                        &LogWarning ($file, $., "Section <INCLUDE> being overridden by inline comments.");
                    }
                    $section_includes = $SourceSymbolDocs{"$TMPL_DIR/$filename:Include"};
                }
                if ($section_includes eq "") {
                    $section_includes = $includes;
                }

                 $signals_synop =~ s/^\n*//g;
                 $signals_synop =~ s/\n+$/\n/g;
                if ($signals_synop ne '') {
                    $signals_synop = <<EOF;
<refsect1 id="$section_id.signals" role="signal_proto">
<title role="signal_proto.title">Signals</title>
<synopsis>
${signals_synop}</synopsis>
</refsect1>
EOF
                     $signals_desc =~ s/^\n*//g;
                     $signals_desc =~ s/\n+$/\n/g;
                     $signals_desc =~ s/(\s|\n)+$//ms;
                    $signals_desc  = <<EOF;
<refsect1 id="$section_id.signal-details" role="signals">
<title role="signals.title">Signal Details</title>
$signals_desc
</refsect1>
EOF
                }

                 $args_synop =~ s/^\n*//g;
                 $args_synop =~ s/\n+$/\n/g;
                if ($args_synop ne '') {
                    $args_synop = <<EOF;
<refsect1 id="$section_id.properties" role="properties">
<title role="properties.title">Properties</title>
<synopsis>
${args_synop}</synopsis>
</refsect1>
EOF
                     $args_desc =~ s/^\n*//g;
                     $args_desc =~ s/\n+$/\n/g;
                     $args_desc =~ s/(\s|\n)+$//ms;
                    $args_desc  = <<EOF;
<refsect1 id="$section_id.property-details" role="property_details">
<title role="property_details.title">Property Details</title>
$args_desc
</refsect1>
EOF
                }

                 $child_args_synop =~ s/^\n*//g;
                 $child_args_synop =~ s/\n+$/\n/g;
                if ($child_args_synop ne '') {
                    $args_synop .= <<EOF;
<refsect1 id="$section_id.child-properties" role="child_properties">
<title role="child_properties.title">Child Properties</title>
<synopsis>
${child_args_synop}</synopsis>
</refsect1>
EOF
                     $child_args_desc =~ s/^\n*//g;
                     $child_args_desc =~ s/\n+$/\n/g;
                     $child_args_desc =~ s/(\s|\n)+$//ms;
                    $args_desc .= <<EOF;
<refsect1 id="$section_id.child-property-details" role="child_property_details">
<title role="child_property_details.title">Child Property Details</title>
$child_args_desc
</refsect1>
EOF
                }

                 $style_args_synop =~ s/^\n*//g;
                 $style_args_synop =~ s/\n+$/\n/g;
                if ($style_args_synop ne '') {
                    $args_synop .= <<EOF;
<refsect1 id="$section_id.style-properties" role="style_properties">
<title role="style_properties.title">Style Properties</title>
<synopsis>
${style_args_synop}</synopsis>
</refsect1>
EOF
                     $style_args_desc =~ s/^\n*//g;
                     $style_args_desc =~ s/\n+$/\n/g;
                     $style_args_desc =~ s/(\s|\n)+$//ms;
                    $args_desc .= <<EOF;
<refsect1 id="$section_id.style-property-details" role="style_properties_details">
<title role="style_properties_details.title">Style Property Details</title>
$style_args_desc
</refsect1>
EOF
                }

                 $hierarchy =~ s/^\n*//g;
                 $hierarchy =~ s/\n+$/\n/g;
                 $hierarchy =~ s/(\s|\n)+$//ms;
                if ($hierarchy ne "") {
                    $hierarchy = <<EOF;
<refsect1 id="$section_id.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
$hierarchy
</refsect1>
EOF
                }

                 $interfaces =~ s/^\n*//g;
                 $interfaces =~ s/\n+$/\n/g;
                 $interfaces =~ s/(\s|\n)+$//ms;
                if ($interfaces ne "") {
                    $interfaces = <<EOF;
<refsect1 id="$section_id.implemented-interfaces" role="impl_interfaces">
<title role="impl_interfaces.title">Implemented Interfaces</title>
$interfaces
</refsect1>
EOF
                }

                 $implementations =~ s/^\n*//g;
                 $implementations =~ s/\n+$/\n/g;
                 $implementations =~ s/(\s|\n)+$//ms;
                if ($implementations ne "") {
                    $implementations = <<EOF;
<refsect1 id="$section_id.implementations" role="implementations">
<title role="implementations.title">Known Implementations</title>
$implementations
</refsect1>
EOF
                }

                 $prerequisites =~ s/^\n*//g;
                 $prerequisites =~ s/\n+$/\n/g;
                 $prerequisites =~ s/(\s|\n)+$//ms;
                if ($prerequisites ne "") {
                    $prerequisites = <<EOF;
<refsect1 id="$section_id.prerequisites" role="prerequisites">
<title role="prerequisites.title">Prerequisites</title>
$prerequisites
</refsect1>
EOF
                }

                 $derived =~ s/^\n*//g;
                 $derived =~ s/\n+$/\n/g;
                 $derived =~ s/(\s|\n)+$//ms;
                if ($derived ne "") {
                    $derived = <<EOF;
<refsect1 id="$section_id.derived-interfaces" role="derived_interfaces">
<title role="derived_interfaces.title">Known Derived Interfaces</title>
$derived
</refsect1>
EOF
                }

                $synopsis =~ s/^\n*//g;
                $synopsis =~ s/\n+$/\n/g;
                my $file_changed = &OutputSGMLFile ($filename, $title, $section_id,
                                                    $section_includes,
                                                    \$synopsis, \$details,
                                                    \$signals_synop, \$signals_desc,
                                                    \$args_synop, \$args_desc,
                                                    \$hierarchy, \$interfaces,
                                                    \$implementations,
                                                    \$prerequisites, \$derived,
                                                    \@file_objects);
                if ($file_changed) {
                    $changed = 1;
                }
            }
            $title = "";
            $section_id = "";
            $subsection = "";
            $in_section = 0;
            $section_includes = "";
            $signals_synop = "";
            $signals_desc = "";
            $args_synop = "";
            $child_args_synop = "";
            $style_args_synop = "";
            $args_desc = "";
            $child_args_desc = "";
            $style_args_desc = "";
            $hierarchy = "";
             $interfaces = "";
             $implementations = "";
            $prerequisites = "";
            $derived = "";

        } elsif (m/^(\S+)/) {
            my $symbol = $1;
            #print "  Symbol: $symbol\n";

            # check for duplicate entries
            if (! defined $symbol_def_line{$symbol}) {
                my $declaration = $Declarations{$symbol};
                if (defined ($declaration)) {
                    # We don't want standard macros/functions of GObjects,
                    # or private declarations.
                    if ($subsection ne "Standard" && $subsection ne "Private") {
                        if (&CheckIsObject ($symbol)) {
                            push @file_objects, $symbol;
                        }
                        my ($synop, $desc) = &OutputDeclaration ($symbol,
                                                                 $declaration);
                        my ($sig_synop, $sig_desc) = &GetSignals ($symbol);
                        my ($arg_synop, $child_arg_synop, $style_arg_synop,
                            $arg_desc, $child_arg_desc, $style_arg_desc) = &GetArgs ($symbol);
                        my $hier = &GetHierarchy ($symbol);
                        my $ifaces = &GetInterfaces ($symbol);
                        my $impls = &GetImplementations ($symbol);
                        my $prereqs = &GetPrerequisites ($symbol);
                        my $der = &GetDerived ($symbol);
                        $synopsis .= $synop;
                        $details .= $desc;
                        $signals_synop .= $sig_synop;
                        $signals_desc .= $sig_desc;
                        $args_synop .= $arg_synop;
                        $child_args_synop .= $child_arg_synop;
                        $style_args_synop .= $style_arg_synop;
                        $args_desc .= $arg_desc;
                        $child_args_desc .= $child_arg_desc;
                        $style_args_desc .= $style_arg_desc;
                        $hierarchy .= $hier;
                        $interfaces .= $ifaces;
                        $implementations .= $impls;
                        $prerequisites .= $prereqs;
                        $derived .= $der;
                    }

                    # Note that the declaration has been output.
                    $DeclarationOutput{$symbol} = 1;
                } elsif ($subsection ne "Standard" && $subsection ne "Private") {
                    $UndeclaredSymbols{$symbol} = 1;
                    &LogWarning ($file, $., "No declaration found for $symbol.");
                }
                $num_symbols++;
                $symbol_def_line{$symbol}=$.;

                if ($section_id eq "") {
                    if($title eq "" && $filename eq "") {
                        &LogWarning ($file, $., "Section has no title and no file.");
                    }
                    # FIXME: one of those would be enough
                    # filename should be an internal detail for gtk-doc
                    if ($title eq "") {
                        $title = $filename;
                    } elsif ($filename eq "") {
                        $filename = $title;
                    }
                    $filename =~ s/\s/_/g;

                    $section_id = $SourceSymbolDocs{"$TMPL_DIR/$filename:Section_Id"};
                    if (defined ($section_id) && $section_id !~ m/^\s*$/) {
                        # Remove trailing blanks and use as is
                        $section_id =~ s/\s+$//;
                    } elsif (&CheckIsObject ($title)) {
                        # GObjects use their class name as the ID.
                        $section_id = &CreateValidSGMLID ($title);
                    } else {
                        $section_id = &CreateValidSGMLID ("$MODULE-$title");
                    }
                }
                $SymbolSection{$symbol}=$title;
                $SymbolSectionId{$symbol}=$section_id;
            }
            else {
                &LogWarning ($file, $., "Double symbol entry for $symbol. ".
                    "Previous occurrence on line ".$symbol_def_line{$symbol}.".");
            }
        }
    }
    close (INPUT);

    &OutputMissingDocumentation;
    &OutputUndeclaredSymbols;
    &OutputUnusedSymbols;

    if ($OUTPUT_ALL_SYMBOLS) {
        &OutputAllSymbols;
    }
    if ($OUTPUT_SYMBOLS_WITHOUT_SINCE) {
        &OutputSymbolsWithoutSince;
    }

    for $filename (split (' ', $EXPAND_CONTENT_FILES)) {
        my $file_changed = &OutputExtraFile ($filename);
        if ($file_changed) {
            $changed = 1;
        }
    }

    &OutputBook ($book_top, $book_bottom);

    return $changed;
}

#############################################################################
# Function    : OutputIndex
# Description : This writes an indexlist that can be included into the main-
#               document into an <index> tag.
#############################################################################

sub OutputIndex {
    my ($basename, $apiindexref ) = @_;
    my %apiindex = %{$apiindexref};
    my $old_index = "$SGML_OUTPUT_DIR/$basename.xml";
    my $new_index = "$SGML_OUTPUT_DIR/$basename.new";
    my $lastletter = " ";
    my $divopen = 0;
    my $symbol;
    my $short_symbol;

    open (OUTPUT, ">$new_index")
        || die "Can't create $new_index";

    my $header = $doctype_header;
    $header =~ s/<!DOCTYPE \w+/<!DOCTYPE indexdiv/;

    print (OUTPUT "$header<indexdiv>\n");

    #print "generate $basename index (".%apiindex." entries)\n";

    # do a case insensitive sort while chopping off the prefix
    foreach my $hash (
        sort { $$a{criteria} cmp $$b{criteria} }
        map { my $x = uc($_); $x =~ s/^$NAME_SPACE\_?(.*)/$1/i; { criteria => $x, original => $_, short => $1 } }
        keys %apiindex) {

        $symbol = $$hash{original};
        if (defined($$hash{short})) {
            $short_symbol = $$hash{short};
        } else {
            $short_symbol = $symbol;
        }

        # generate a short symbol description
        my $symbol_desc = "";
        my $symbol_section = "";
        my $symbol_section_id = "";
        my $symbol_type = "";
        if (defined($DeclarationTypes{$symbol})) {
          $symbol_type = lc($DeclarationTypes{$symbol});
        }
        if ($symbol_type eq "") {
            #print "trying symbol $symbol\n";
            if ($symbol =~ m/(.*)::(.*)/) {
                my $oname = $1;
                my $osym = $2;
                my $i;
                #print "  trying object signal ${oname}:$osym in ".$#SignalNames." signals\n";
                for ($i = 0; $i <= $#SignalNames; $i++) {
                    if ($SignalNames[$i] eq $osym) {
                        $symbol_type = "object signal";
                        if (defined($SymbolSection{$oname})) {
                           $symbol_section = $SymbolSection{$oname};
                           $symbol_section_id = $SymbolSectionId{$oname};
                        }
                        last;
                    }
                }
            } elsif ($symbol =~ m/(.*):(.*)/) {
                my $oname = $1;
                my $osym = $2;
                my $i;
                #print "  trying object property ${oname}::$osym in ".$#ArgNames." properties\n";
                for ($i = 0; $i <= $#ArgNames; $i++) {
                    #print "    ".$ArgNames[$i]."\n";
                    if ($ArgNames[$i] eq $osym) {
                        $symbol_type = "object property";
                        if (defined($SymbolSection{$oname})) {
                           $symbol_section = $SymbolSection{$oname};
                           $symbol_section_id = $SymbolSectionId{$oname};
                        }
                        last;
                    }
                }
            }
        } else {
           if (defined($SymbolSection{$symbol})) {
               $symbol_section = $SymbolSection{$symbol};
               $symbol_section_id = $SymbolSectionId{$symbol};
           }
        }
        if ($symbol_type ne "") {
           $symbol_desc=", $symbol_type";
           if ($symbol_section ne "") {
               $symbol_desc.=" in <link linkend=\"$symbol_section_id\">$symbol_section</link>";
               #$symbol_desc.=" in ". &ExpandAbbreviations($symbol, "#$symbol_section");
           }
        }

        my $curletter = uc(substr($short_symbol,0,1));
        my $id = $apiindex{$symbol};

        #print "  add symbol $symbol with $id to index in section $curletter\n";

        if ($curletter ne $lastletter) {
            $lastletter = $curletter;

            if ($divopen == 1) {
                print (OUTPUT "</indexdiv>\n");
            }
            print (OUTPUT "<indexdiv><title>$curletter</title>\n");
            $divopen = 1;
        }

        print (OUTPUT <<EOF);
<indexentry><primaryie linkends="$id"><link linkend="$id">$symbol</link>$symbol_desc</primaryie></indexentry>
EOF
    }

    if ($divopen == 1) {
        print (OUTPUT "</indexdiv>\n");
    }
    print (OUTPUT "</indexdiv>\n");
    close (OUTPUT);

    &UpdateFileIfChanged ($old_index, $new_index, 0);
}


#############################################################################
# Function    : OutputIndexFull
# Description : This writes the full api indexlist that can be included into the
#               main document into an <index> tag.
#############################################################################

sub OutputIndexFull {
    &OutputIndex ("api-index-full", \%IndexEntriesFull);
}


#############################################################################
# Function    : OutputDeprecatedIndex
# Description : This writes the deprecated api indexlist that can be included
#               into the main document into an <index> tag.
#############################################################################

sub OutputDeprecatedIndex {
    &OutputIndex ("api-index-deprecated", \%IndexEntriesDeprecated);
}


#############################################################################
# Function    : OutputSinceIndexes
# Description : This writes the 'since' api indexlists that can be included into
#               the main document into an <index> tag.
#############################################################################

sub OutputSinceIndexes {
    my @sinces = keys %{{ map { $_ => 1 } values %Since }};

    foreach my $version (@sinces) {
        #print "Since : [$version]\n";
        # TODO make filtered hash
        #my %index = grep { $Since{$_} eq $version } %IndexEntriesSince;
        my %index = map { $_ => $IndexEntriesSince{$_} } grep { $Since{$_} eq $version } keys %IndexEntriesSince;

        &OutputIndex ("api-index-$version", \%index);
    }
}

#############################################################################
# Function    : OutputAnnotationGlossary
# Description : This writes a glossary of the used annotation terms into a
#               separate glossary file that can be included into the main
#               document.
#############################################################################

sub OutputAnnotationGlossary {
    my $old_glossary = "$SGML_OUTPUT_DIR/annotation-glossary.xml";
    my $new_glossary = "$SGML_OUTPUT_DIR/annotation-glossary.new";
    my $lastletter = " ";
    my $divopen = 0;

    # if there are no annotations used return
    return if (! keys(%AnnotationsUsed));

    # add acronyms that are referenced from acronym text
rerun:
    foreach my $annotation (keys(%AnnotationsUsed)) {
        if(defined($AnnotationDefinition{$annotation})) {
            if($AnnotationDefinition{$annotation} =~ m/<acronym>([\w ]+)<\/acronym>/) {
                if (!exists($AnnotationsUsed{$1})) {
                    $AnnotationsUsed{$1} = 1;
                    goto rerun;
                }
            }
        }
    }

    open (OUTPUT, ">$new_glossary")
        || die "Can't create $new_glossary";

    my $header = $doctype_header;
    $header =~ s/<!DOCTYPE \w+/<!DOCTYPE glossary/;

    print (OUTPUT  <<EOF);
$header
<glossary id="annotation-glossary">
  <title>Annotation Glossary</title>
EOF

    foreach my $annotation (keys(%AnnotationsUsed)) {
        if(defined($AnnotationDefinition{$annotation})) {
            my $def = $AnnotationDefinition{$annotation};
            my $curletter = uc(substr($annotation,0,1));

            if ($curletter ne $lastletter) {
                $lastletter = $curletter;

                if ($divopen == 1) {
                    print (OUTPUT "</glossdiv>\n");
                }
                print (OUTPUT "<glossdiv><title>$curletter</title>\n");
                $divopen = 1;
            }
            print (OUTPUT <<EOF);
    <glossentry>
      <glossterm><anchor id="annotation-glossterm-$annotation"/>$annotation</glossterm>
      <glossdef>
        <para>$def</para>
      </glossdef>
    </glossentry>
EOF
        }
    }

    if ($divopen == 1) {
        print (OUTPUT "</glossdiv>\n");
    }
    print (OUTPUT "</glossary>\n");
    close (OUTPUT);

    &UpdateFileIfChanged ($old_glossary, $new_glossary, 0);
}

#############################################################################
# Function    : ReadKnownSymbols
# Description : This collects the names of non-private symbols from the
#               $MODULE-sections.txt file.
# Arguments   : $file - the $MODULE-sections.txt file which contains all of
#                the functions/macros/structs etc. being documented, organised
#                into sections and subsections.
#############################################################################

sub ReadKnownSymbols {
    my ($file) = @_;

    my $subsection = "";

    #print "Reading: $file\n";
    open (INPUT, $file)
        || die "Can't open $file: $!";

    while (<INPUT>) {
        if (m/^#/) {
            next;

        } elsif (m/^<SECTION>/) {
            $subsection = "";

        } elsif (m/^<SUBSECTION\s*(.*)>/i) {
            $subsection = $1;

        } elsif (m/^<SUBSECTION>/) {
            next;

        } elsif (m/^<TITLE>(.*)<\/TITLE>/) {
            next;

        } elsif (m/^<FILE>(.*)<\/FILE>/) {
            $KnownSymbols{"$TMPL_DIR/$1:Long_Description"} = 1;
            $KnownSymbols{"$TMPL_DIR/$1:Short_Description"} = 1;
            next;

        } elsif (m/^<INCLUDE>(.*)<\/INCLUDE>/) {
            next;

        } elsif (m/^<\/SECTION>/) {
            next;

        } elsif (m/^(\S+)/) {
            my $symbol = $1;

            if ($subsection ne "Standard" && $subsection ne "Private") {
                $KnownSymbols{$symbol} = 1;
            }
            else {
                $KnownSymbols{$symbol} = 0;
            }
        }
    }
    close (INPUT);
}


#############################################################################
# Function    : OutputDeclaration
# Description : Returns the synopsis and detailed description DocBook
#                describing one function/macro etc.
# Arguments   : $symbol - the name of the function/macro begin described.
#                $declaration - the declaration of the function/macro.
#############################################################################

sub OutputDeclaration {
    my ($symbol, $declaration) = @_;

    my $type = $DeclarationTypes {$symbol};
    if ($type eq 'MACRO') {
        return &OutputMacro ($symbol, $declaration);
    } elsif ($type eq 'TYPEDEF') {
        return &OutputTypedef ($symbol, $declaration);
    } elsif ($type eq 'STRUCT') {
        return &OutputStruct ($symbol, $declaration);
    } elsif ($type eq 'ENUM') {
        return &OutputEnum ($symbol, $declaration);
    } elsif ($type eq 'UNION') {
        return &OutputUnion ($symbol, $declaration);
    } elsif ($type eq 'VARIABLE') {
        return &OutputVariable ($symbol, $declaration);
    } elsif ($type eq 'FUNCTION') {
        return &OutputFunction ($symbol, $declaration, $type);
    } elsif ($type eq 'USER_FUNCTION') {
        return &OutputFunction ($symbol, $declaration, $type);
    } else {
        die "Unknown symbol type";
    }
}


#############################################################################
# Function    : OutputSymbolTraits
# Description : Returns the Since and StabilityLevel paragraphs for a symbol.
# Arguments   : $symbol - the name of the function/macro begin described.
#############################################################################

sub OutputSymbolTraits {
    my ($symbol) = @_;
    my $desc = "";

    if (exists $Since{$symbol}) {
        $desc .= "<para role=\"since\">Since $Since{$symbol}</para>";
    }
    if (exists $StabilityLevel{$symbol}) {
        $desc .= "<para role=\"stability\">Stability Level: $StabilityLevel{$symbol}</para>";
    }
    return $desc;
}

#############################################################################
# Function    : Outpu{Symbol,Section}ExtraLinks
# Description : Returns extralinks for the symbol (if enabled).
# Arguments   : $symbol - the name of the function/macro begin described.
#############################################################################

sub uri_escape {
    my $text = $_[0];
    return undef unless defined $text;

    # Build a char to hex map
    my %escapes = ();
    for (0..255) {
            $escapes{chr($_)} = sprintf("%%%02X", $_);
    }

    # Default unsafe characters.  RFC 2732 ^(uric - reserved)
    $text =~ s/([^A-Za-z0-9\-_.!~*'()])/$escapes{$1}/g;

    return $text;
}

sub OutputSymbolExtraLinks {
    my ($symbol) = @_;
    my $desc = "";

    if (0) { # NEW FEATURE: needs configurability
    my $sstr = &uri_escape($symbol);
    my $mstr = &uri_escape($MODULE);
    $desc .= <<EOF;
<ulink role="extralinks" url="http://www.google.com/codesearch?q=$sstr">code search</ulink>
<ulink role="extralinks" url="http://library.gnome.org/edit?module=$mstr&amp;symbol=$sstr">edit documentation</ulink>
EOF
    }
    return $desc;
}

sub OutputSectionExtraLinks {
    my ($symbol,$docsymbol) = @_;
    my $desc = "";

    if (0) { # NEW FEATURE: needs configurability
    my $sstr = &uri_escape($symbol);
    my $mstr = &uri_escape($MODULE);
    my $dsstr = &uri_escape($docsymbol);
    $desc .= <<EOF;
<ulink role="extralinks" url="http://www.google.com/codesearch?q=$sstr">code search</ulink>
<ulink role="extralinks" url="http://library.gnome.org/edit?module=$mstr&amp;symbol=$dsstr">edit documentation</ulink>
EOF
    }
    return $desc;
}


#############################################################################
# Function    : OutputMacro
# Description : Returns the synopsis and detailed description of a macro.
# Arguments   : $symbol - the macro.
#                $declaration - the declaration of the macro.
#############################################################################

sub OutputMacro {
    my ($symbol, $declaration) = @_;
    my $id = &CreateValidSGMLID ($symbol);
    my $condition = &MakeConditionDescription ($symbol);
    my $synop = &MakeReturnField("#define") . "<link linkend=\"$id\">$symbol</link>";
    my $desc;

    my @fields = ParseMacroDeclaration($declaration, \&CreateValidSGML);
    my $title = $symbol . (@fields ? "()" : "");

    $desc = "<refsect2 id=\"$id\" role=\"macro\"$condition>\n<title>$title</title>\n";
    $desc .= MakeIndexterms($symbol, $id);
    $desc .= "\n";
    $desc .= OutputSymbolExtraLinks($symbol);

    if (@fields) {
        if (length ($symbol) < $SYMBOL_FIELD_WIDTH) {
            $synop .= (' ' x ($SYMBOL_FIELD_WIDTH - length ($symbol)));
        }

        $synop .= "(";
        for (my $i = 1; $i <= $#fields; $i += 2) {
            my $field_name = $fields[$i];

            if ($i == 1) {
                $synop .= "$field_name";
            } else {
                $synop .= ",\n"
                    . (' ' x ($SYMBOL_FIELD_WIDTH + $RETURN_TYPE_FIELD_WIDTH))
                    . " $field_name";
            }
        }
        $synop .= ")";
    }
    $synop .= "\n";

    # Don't output the macro definition if is is a conditional macro or it
    # looks like a function, i.e. starts with "g_" or "_?gnome_", or it is
    # longer than 2 lines, otherwise we get lots of complicated macros like
    # g_assert.
    if (!defined ($DeclarationConditional{$symbol}) && ($symbol !~ m/^g_/)
        && ($symbol !~ m/^_?gnome_/) && (($declaration =~ tr/\n//) < 2)) {
        my $decl_out = &CreateValidSGML ($declaration);
        $desc .= "<programlisting>$decl_out</programlisting>\n";
    } else {
        $desc .= "<programlisting>" . &MakeReturnField("#define") . "$symbol";
        if ($declaration =~ m/^\s*#\s*define\s+\w+(\([^\)]*\))/) {
            my $args = $1;
            my $pad = ' ' x ($RETURN_TYPE_FIELD_WIDTH - length ("#define "));
            # Align each line so that if should all line up OK.
            $args =~ s/\n/\n$pad/gm;
            $desc .= &CreateValidSGML ($args);
        }
        $desc .= "</programlisting>\n";
    }

    $desc .= &MakeDeprecationNote($symbol);

    my $parameters = &OutputParamDescriptions ("MACRO", $symbol, @fields);
    my $parameters_output = 0;

    if (defined ($SymbolDocs{$symbol})) {
        my $symbol_docs = &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});

        # Try to insert the parameter table at the author's desired position.
        # Otherwise we need to tag it onto the end.
        if ($symbol_docs =~ s/<!--PARAMETERS-->/$parameters/) {
          $parameters_output = 1;
        }
        $desc .= $symbol_docs;
    }

    if ($parameters_output == 0) {
        $desc .= $parameters;
    }

    $desc .= OutputSymbolTraits ($symbol);
    $desc .= "</refsect2>\n";
    return ($synop, $desc);
}


#############################################################################
# Function    : OutputTypedef
# Description : Returns the synopsis and detailed description of a typedef.
# Arguments   : $symbol - the typedef.
#                $declaration - the declaration of the typedef,
#                  e.g. 'typedef unsigned int guint;'
#############################################################################

sub OutputTypedef {
    my ($symbol, $declaration) = @_;
    my $id = &CreateValidSGMLID ($symbol);
    my $condition = &MakeConditionDescription ($symbol);
    my $synop = &MakeReturnField("typedef") . "<link linkend=\"$id\">$symbol</link>;\n";
    my $desc = "<refsect2 id=\"$id\" role=\"typedef\"$condition>\n<title>$symbol</title>\n";

    $desc .= MakeIndexterms($symbol, $id);
    $desc .= "\n";
    $desc .= OutputSymbolExtraLinks($symbol);

    if (!defined ($DeclarationConditional{$symbol})) {
        my $decl_out = &CreateValidSGML ($declaration);
        $desc .= "<programlisting>$decl_out</programlisting>\n";
    }

    $desc .= &MakeDeprecationNote($symbol);

    if (defined ($SymbolDocs{$symbol})) {
        $desc .= &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});
    }
    $desc .= OutputSymbolTraits ($symbol);
    $desc .= "</refsect2>\n";
    return ($synop, $desc);
}


#############################################################################
# Function    : OutputStruct
# Description : Returns the synopsis and detailed description of a struct.
#                We check if it is a object struct, and if so we only output
#                parts of it that are noted as public fields.
#                We also use a different SGML ID for object structs, since the
#                original ID is used for the entire RefEntry.
# Arguments   : $symbol - the struct.
#                $declaration - the declaration of the struct.
#############################################################################

sub OutputStruct {
    my ($symbol, $declaration) = @_;

    my $is_gtype = 0;
    my $default_to_public = 1;
    if (&CheckIsObject ($symbol)) {
        #print "Found struct gtype: $symbol\n";
        $is_gtype = 1;
        $default_to_public = $ObjectRoots{$symbol} eq 'GBoxed';
    }

    my $id;
    my $condition;
    if ($is_gtype) {
        $id = &CreateValidSGMLID ($symbol . "_struct");
        $condition = &MakeConditionDescription ($symbol . "_struct");
    } else {
        $id = &CreateValidSGMLID ($symbol);
        $condition = &MakeConditionDescription ($symbol);
    }

    # Determine if it is a simple struct or it also has a typedef.
    my $has_typedef = 0;
    if ($StructHasTypedef{$symbol} || $declaration =~ m/^\s*typedef\s+/) {
      $has_typedef = 1;
    }

    my $synop;
    my $desc;
    if ($has_typedef) {
        # For structs with typedefs we just output the struct name.
        $synop = &MakeReturnField("") . "<link linkend=\"$id\">$symbol</link>;\n";
        $desc = "<refsect2 id=\"$id\" role=\"struct\"$condition>\n<title>$symbol</title>\n";
    } else {
        $synop = &MakeReturnField("struct") . "<link linkend=\"$id\">$symbol</link>;\n";
        $desc = "<refsect2 id=\"$id\" role=\"struct\"$condition>\n<title>struct $symbol</title>\n";
    }

    $desc .= MakeIndexterms($symbol, $id);
    $desc .= "\n";
    $desc .= OutputSymbolExtraLinks($symbol);

    # Form a pretty-printed, private-data-removed form of the declaration

    my $decl_out = "";
    if ($declaration =~ m/^\s*$/) {
        #print "Found opaque struct: $symbol\n";
        $decl_out = "typedef struct _$symbol $symbol;";
    } elsif ($declaration =~ m/^\s*struct\s+\w+\s*;\s*$/) {
        #print "Found opaque struct: $symbol\n";
        $decl_out = "struct $symbol;";
    } else {
        my $public = $default_to_public;
        my $new_declaration = "";
        my $decl_line;
        my $decl = $declaration;

        if ($decl =~ m/^\s*(typedef\s+)?struct\s*\w*\s*(?:\/\*.*\*\/)?\s*{(.*)}\s*\w*\s*;\s*$/s) {
            my $struct_contents = $2;

            foreach $decl_line (split (/\n/, $struct_contents)) {
                #print "Struct line: $decl_line\n";
                if ($decl_line =~ m%/\*\s*<\s*public\s*>\s*\*/%) {
                    $public = 1;
                } elsif ($decl_line =~ m%/\*\s*<\s*(private|protected)\s*>\s*\*/%) {
                    $public = 0;
                } elsif ($public) {
                    $new_declaration .= $decl_line . "\n";
                }
            }

            if ($new_declaration) {
                # Strip any blank lines off the ends.
                $new_declaration =~ s/^\s*\n//;
                $new_declaration =~ s/\n\s*$/\n/;

                if ($has_typedef) {
                    $decl_out = "typedef struct {\n" . $new_declaration
                      . "} $symbol;\n";
                } else {
                    $decl_out = "struct $symbol {\n" . $new_declaration
                      . "};\n";
                }
            }
        } else {
            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                "Couldn't parse struct:\n$declaration");
        }

        # If we couldn't parse the struct or it was all private, output an
        # empty struct declaration.
        if ($decl_out eq "") {
            if ($has_typedef) {
                $decl_out = "typedef struct _$symbol $symbol;";
            } else {
                $decl_out = "struct $symbol;";
            }
        }
    }

    $decl_out = &CreateValidSGML ($decl_out);
    $desc .= "<programlisting>$decl_out</programlisting>\n";

    $desc .= &MakeDeprecationNote($symbol);

    if (defined ($SymbolDocs{$symbol})) {
        $desc .= &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});
    }

    # Create a table of fields and descriptions

    # FIXME: Inserting &#160's into the produced type declarations here would
    #        improve the output in most situations ... except for function
    #        members of structs!
    my @fields = ParseStructDeclaration($declaration, !$default_to_public,
                                        0, \&MakeXRef,
                                        sub {
                                            "<structfield id=\"".&CreateValidSGMLID("$id.$_[0]")."\">$_[0]</structfield>";
                                        });
    my $params = $SymbolParams{$symbol};

    # If no parameters are filled in, we don't generate the description
    # table, for backwards compatibility.

    my $found = 0;
    if (defined $params) {
        for (my $i = 1; $i <= $#$params; $i += $PARAM_FIELD_COUNT) {
            if ($params->[$i] =~ /\S/) {
                $found = 1;
                last;
            }
        }
    }

    if ($found) {
        my %field_descrs = @$params;
        my $missing_parameters = "";
        my $unused_parameters = "";

        $desc .= "<variablelist role=\"struct\">\n";
        while (@fields) {
            my $field_name = shift @fields;
            my $text = shift @fields;
            my $field_descr = $field_descrs{$field_name};
            my $param_annotations = "";

            $desc .= "<varlistentry><term>$text</term>\n";
            if (defined $field_descr) {
                ($field_descr,$param_annotations) = &ExpandAnnotation($symbol, $field_descr);
                $field_descr = &ExpandAbbreviations($symbol, $field_descr);
                $field_descr .= $param_annotations;
                # trim
                $field_descr =~ s/^(\s|\n)+//msg;
                $field_descr =~ s/(\s|\n)+$//msg;
                $desc .= "<listitem><simpara>$field_descr</simpara></listitem>\n";
                delete $field_descrs{$field_name};
            } else {
                &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                    "Field description for $symbol"."::"."$field_name is missing in source code comment block.");
                if ($missing_parameters ne "") {
                  $missing_parameters .= ", ".$field_name;
                } else {
                    $missing_parameters = $field_name;
                }
                $desc .= "<listitem />\n";
            }
            $desc .= "</varlistentry>\n";
        }
        $desc .= "</variablelist>";
        foreach my $field_name (keys %field_descrs) {
            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                "Field description for $symbol"."::"."$field_name is not used from source code comment block.");
            if ($unused_parameters ne "") {
              $unused_parameters .= ", ".$field_name;
            } else {
               $unused_parameters = $field_name;
            }
        }

        # remember missing/unused parameters (needed in tmpl-free build)
        if (($missing_parameters ne "") and (! exists ($AllIncompleteSymbols{$symbol}))) {
            $AllIncompleteSymbols{$symbol}=$missing_parameters;
        }
        if (($unused_parameters ne "") and (! exists ($AllUnusedSymbols{$symbol}))) {
            $AllUnusedSymbols{$symbol}=$unused_parameters;
        }
    }
    else {
        if (scalar(@fields) > 0) {
            if (! exists ($AllIncompleteSymbols{$symbol})) {
                $AllIncompleteSymbols{$symbol}="<items>";
                &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                    "Field descriptions for struct $symbol are missing in source code comment block.");
                #("Remaining structs fields: ".@fields.":".join(',',@fields)."\n");
            }
        }
    }

    $desc .= OutputSymbolTraits ($symbol);
    $desc .= "</refsect2>\n";
    return ($synop, $desc);
}


#############################################################################
# Function    : OutputUnion
# Description : Returns the synopsis and detailed description of a union.
# Arguments   : $symbol - the union.
#                $declaration - the declaration of the union.
#############################################################################

sub OutputUnion {
    my ($symbol, $declaration) = @_;
    my $id = &CreateValidSGMLID ($symbol);
    my $condition = &MakeConditionDescription ($symbol);

    # Determine if it is a simple struct or it also has a typedef.
    my $has_typedef = 0;
    if ($StructHasTypedef{$symbol} || $declaration =~ m/^\s*typedef\s+/) {
      $has_typedef = 1;
    }

    my $synop;
    my $desc;
    if ($has_typedef) {
        # For unions with typedefs we just output the union name.
        $synop = &MakeReturnField("") . "<link linkend=\"$id\">$symbol</link>;\n";
        $desc = "<refsect2 id=\"$id\" role=\"union\"$condition>\n<title>$symbol</title>\n";
    } else {
        $synop = &MakeReturnField("union") . "<link linkend=\"$id\">$symbol</link>;\n";
        $desc = "<refsect2 id=\"$id\" role=\"union\"$condition>\n<title>union $symbol</title>\n";
    }

    $desc .= MakeIndexterms($symbol, $id);
    $desc .= "\n";
    $desc .= OutputSymbolExtraLinks($symbol);

    # FIXME: we do more for structs
    my $decl_out = &CreateValidSGML ($declaration);
    $desc .= "<programlisting>$decl_out</programlisting>\n";

    $desc .= &MakeDeprecationNote($symbol);

    if (defined ($SymbolDocs{$symbol})) {
        $desc .= &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});
    }

    # Create a table of fields and descriptions

    # FIXME: Inserting &#160's into the produced type declarations here would
    #        improve the output in most situations ... except for function
    #        members of structs!
    my @fields = ParseStructDeclaration($declaration, 0,
                                        0, \&MakeXRef,
                                        sub {
                                            "<structfield id=\"".&CreateValidSGMLID("$id.$_[0]")."\">$_[0]</structfield>";
                                        });
    my $params = $SymbolParams{$symbol};

    # If no parameters are filled in, we don't generate the description
    # table, for backwards compatibility

    my $found = 0;
    if (defined $params) {
        for (my $i = 1; $i <= $#$params; $i += $PARAM_FIELD_COUNT) {
            if ($params->[$i] =~ /\S/) {
                $found = 1;
                last;
            }
        }
    }

    if ($found) {
        my %field_descrs = @$params;
        my $missing_parameters = "";
        my $unused_parameters = "";

        $desc .= "<variablelist role=\"union\">\n";
        while (@fields) {
            my $field_name = shift @fields;
            my $text = shift @fields;
            my $field_descr = $field_descrs{$field_name};
            my $param_annotations = "";

            $desc .= "<varlistentry><term>$text</term>\n";
            if (defined $field_descr) {
                ($field_descr,$param_annotations) = &ExpandAnnotation($symbol, $field_descr);
                $field_descr = &ExpandAbbreviations($symbol, $field_descr);
                $field_descr .= $param_annotations;
                # trim
                $field_descr =~ s/^(\s|\n)+//msg;
                $field_descr =~ s/(\s|\n)+$//msg;
                $desc .= "<listitem><simpara>$field_descr</simpara></listitem>\n";
                delete $field_descrs{$field_name};
            } else {
                &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                    "Field description for $symbol"."::"."$field_name is missing in source code comment block.");
                if ($missing_parameters ne "") {
                    $missing_parameters .= ", ".$field_name;
                } else {
                    $missing_parameters = $field_name;
                }
                $desc .= "<listitem />\n";
            }
            $desc .= "</varlistentry>\n";
        }
        $desc .= "</variablelist>";
        foreach my $field_name (keys %field_descrs) {
            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                "Field description for $symbol"."::"."$field_name is not used from source code comment block.");
            if ($unused_parameters ne "") {
              $unused_parameters .= ", ".$field_name;
            } else {
               $unused_parameters = $field_name;
            }
        }

        # remember missing/unused parameters (needed in tmpl-free build)
        if (($missing_parameters ne "") and (! exists ($AllIncompleteSymbols{$symbol}))) {
            $AllIncompleteSymbols{$symbol}=$missing_parameters;
        }
        if (($unused_parameters ne "") and (! exists ($AllUnusedSymbols{$symbol}))) {
            $AllUnusedSymbols{$symbol}=$unused_parameters;
        }
    }
    else {
        if (scalar(@fields) > 0) {
            if (! exists ($AllIncompleteSymbols{$symbol})) {
                $AllIncompleteSymbols{$symbol}="<items>";
                &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                    "Field descriptions for union $symbol are missing in source code comment block.");
                #("Remaining union fields: ".@fields.":".join(',',@fields)."\n");
            }
        }
    }

    $desc .= OutputSymbolTraits ($symbol);
    $desc .= "</refsect2>\n";
    return ($synop, $desc);
}


#############################################################################
# Function    : OutputEnum
# Description : Returns the synopsis and detailed description of a enum.
# Arguments   : $symbol - the enum.
#                $declaration - the declaration of the enum.
#############################################################################

sub OutputEnum {
    my ($symbol, $declaration) = @_;

    my $is_gtype = 0;
    if (&CheckIsObject ($symbol)) {
        #print "Found enum gtype: $symbol\n";
        $is_gtype = 1;
    }

    my $id;
    my $condition;
    if ($is_gtype) {
        $id = &CreateValidSGMLID ($symbol . "_enum");
        $condition = &MakeConditionDescription ($symbol . "_enum");
    } else {
        $id = &CreateValidSGMLID ($symbol);
        $condition = &MakeConditionDescription ($symbol);
    }

    my $synop = &MakeReturnField("enum") . "<link linkend=\"$id\">$symbol</link>;\n";
    my $desc = "<refsect2 id=\"$id\" role=\"enum\"$condition>\n<title>enum $symbol</title>\n";

    $desc .= MakeIndexterms($symbol, $id);
    $desc .= "\n";
    $desc .= OutputSymbolExtraLinks($symbol);

    my $decl_out = "";
    my $public = 1;
    my $new_declaration = "";
    my $decl_line;
    my $decl = $declaration;

    if ($decl =~ m/^\s*(typedef\s+)?enum\s*\w*\s*(?:\/\*.*\*\/)?\s*{(.*)}\s*\w*\s*;\s*$/s) {
        my $has_typedef = defined($1) ? 1 : 0;
        my $enum_contents = $2;

        foreach $decl_line (split (/\n/, $enum_contents)) {
            #print "Enum line: $decl_line\n";
            if ($decl_line =~ m%/\*\s*<\s*public\s*>\s*\*/%) {
                $public = 1;
            } elsif ($decl_line =~ m%/\*\s*<\s*(private|protected)\s*>\s*\*/%) {
                $public = 0;
            } elsif ($public) {
                $new_declaration .= $decl_line . "\n";
            }
        }

        if ($new_declaration) {
            # Strip any blank lines off the ends.
            $new_declaration =~ s/^\s*\n//;
            $new_declaration =~ s/\n\s*$/\n/;

            if ($has_typedef) {
                $decl_out = "typedef enum {\n" . $new_declaration
                  . "} $symbol;\n";
            } else {
                $decl_out = "enum $symbol {\n" . $new_declaration
                  . "};\n";
            }
        }
    }

    $decl_out = &CreateValidSGML ($decl_out);
    $desc .= "<programlisting>$decl_out</programlisting>\n";

    $desc .= &MakeDeprecationNote($symbol);

    if (defined ($SymbolDocs{$symbol})) {
        $desc .= &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});
    }

    # Create a table of fields and descriptions

    my @fields = ParseEnumDeclaration($declaration);
    my $params = $SymbolParams{$symbol};

    # If no parameters are filled in, we don't generate the description
    # table, for backwards compatibility

    my $found = 0;
    if (defined $params) {
        for (my $i = 1; $i <= $#$params; $i += $PARAM_FIELD_COUNT) {
            if ($params->[$i] =~ /\S/) {
                $found = 1;
                last;
            }
        }
    }

    if ($found) {
        my %field_descrs = @$params;
        my $missing_parameters = "";
        my $unused_parameters = "";

        $desc .= "<variablelist role=\"enum\">\n";
        for my $field_name (@fields) {
            my $field_descr = $field_descrs{$field_name};
            my $param_annotations = "";

            $id = &CreateValidSGMLID ($field_name);
            $condition = &MakeConditionDescription ($field_name);
            $desc .= "<varlistentry id=\"$id\" role=\"constant\"$condition>\n<term><literal>$field_name</literal></term>\n";
            if (defined $field_descr) {
                ($field_descr,$param_annotations) = &ExpandAnnotation($symbol, $field_descr);
                $field_descr = &ExpandAbbreviations($symbol, $field_descr);
                $desc .= "<listitem><simpara>$field_descr$param_annotations</simpara></listitem>\n";
                delete $field_descrs{$field_name};
            } else {
                &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                    "Value description for $symbol"."::"."$field_name is missing in source code comment block.");
                if ($missing_parameters ne "") {
                  $missing_parameters .= ", ".$field_name;
                } else {
                    $missing_parameters = $field_name;
                }
                $desc .= "<listitem />\n";
            }
            $desc .= "</varlistentry>\n";
        }
        $desc .= "</variablelist>";
        foreach my $field_name (keys %field_descrs) {
            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                "Value description for $symbol"."::"."$field_name is not used from source code comment block.");
            if ($unused_parameters ne "") {
              $unused_parameters .= ", ".$field_name;
            } else {
               $unused_parameters = $field_name;
            }
        }

        # remember missing/unused parameters (needed in tmpl-free build)
        if (($missing_parameters ne "") and (! exists ($AllIncompleteSymbols{$symbol}))) {
            $AllIncompleteSymbols{$symbol}=$missing_parameters;
        }
        if (($unused_parameters ne "") and (! exists ($AllUnusedSymbols{$symbol}))) {
            $AllUnusedSymbols{$symbol}=$unused_parameters;
        }
    }
    else {
        if (scalar(@fields) > 0) {
            if (! exists ($AllIncompleteSymbols{$symbol})) {
                $AllIncompleteSymbols{$symbol}="<items>";
                &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                    "Value descriptions for $symbol are missing in source code comment block.");
            }
        }
    }

    $desc .= OutputSymbolTraits ($symbol);
    $desc .= "</refsect2>\n";
    return ($synop, $desc);
}


#############################################################################
# Function    : OutputVariable
# Description : Returns the synopsis and detailed description of a variable.
# Arguments   : $symbol - the extern'ed variable.
#                $declaration - the declaration of the variable.
#############################################################################

sub OutputVariable {
    my ($symbol, $declaration) = @_;
    my $id = &CreateValidSGMLID ($symbol);
    my $condition = &MakeConditionDescription ($symbol);
    
    #("ouputing variable: '$symbol' '$declaration'");

    my $synop;
    if ($declaration =~ m/^\s*extern\s+((const\s+|signed\s+|unsigned\s+|long\s+|short\s+)*\w+)(\s+\*+|\*+|\s)(\s*)(const\s+)*([A-Za-z]\w*)\s*;/) {
        my $mod1 = defined ($1) ? $1 : "";
        my $ptr = defined ($3) ? $3 : "";
        my $space = defined ($4) ? $4 : "";
        my $mod2 = defined ($5) ? $5 : "";
        $synop = &MakeReturnField("extern $mod1$ptr$space$mod2") . "<link linkend=\"$id\">$symbol</link>;\n";
    } elsif ($declaration =~ m/^\s*((const\s+|signed\s+|unsigned\s+|long\s+|short\s+)*\w+)(\s+\*+|\*+|\s)(\s*)(const\s+)*([A-Za-z]\w*)\s*=/) {
        my $mod1 = defined ($1) ? $1 : "";
        my $ptr = defined ($3) ? $3 : "";
        my $space = defined ($4) ? $4 : "";
        my $mod2 = defined ($5) ? $5 : "";
        $synop = &MakeReturnField("$mod1$ptr$space$mod2") . "<link linkend=\"$id\">$symbol</link>;\n";

    } else {
        $synop = &MakeReturnField("extern") . "<link linkend=\"$id\">$symbol</link>;\n";
    }

    my $desc = "<refsect2 id=\"$id\" role=\"variable\"$condition>\n<title>$symbol</title>\n";

    $desc .= MakeIndexterms($symbol, $id);
    $desc .= "\n";
    $desc .= OutputSymbolExtraLinks($symbol);

    my $decl_out = &CreateValidSGML ($declaration);
    $desc .= "<programlisting>$decl_out</programlisting>\n";

    $desc .= &MakeDeprecationNote($symbol);

    if (defined ($SymbolDocs{$symbol})) {
        $desc .= &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});
    }
    $desc .= OutputSymbolTraits ($symbol);
    $desc .= "</refsect2>\n";
    return ($synop, $desc);
}


#############################################################################
# Function    : OutputFunction
# Description : Returns the synopsis and detailed description of a function.
# Arguments   : $symbol - the function.
#                $declaration - the declaration of the function.
#############################################################################

sub OutputFunction {
    my ($symbol, $declaration, $symbol_type) = @_;
    my $id = &CreateValidSGMLID ($symbol);
    my $condition = &MakeConditionDescription ($symbol);

    # Take out the return type     $1                                                                                       $2   $3
    $declaration =~ s/<RETURNS>\s*((?:const\s+|G_CONST_RETURN\s+|signed\s+|unsigned\s+|long\s+|short\s+|struct\s+|enum\s+)*)(\w+)(\s*\**\s*(?:const|G_CONST_RETURN)?\s*\**\s*(?:restrict)?\s*)<\/RETURNS>\n//;
    my $type_modifier = defined($1) ? $1 : "";
    my $type = $2;
    my $pointer = $3;
    # Trim trailing spaces as we are going to pad to $RETURN_TYPE_FIELD_WIDTH below anyway
    $pointer =~ s/\s+$//;
    my $xref = &MakeXRef ($type, &tagify($type, "returnvalue"));
    my $start = "";
    #if ($symbol_type eq 'USER_FUNCTION') {
    #    $start = "typedef ";
    #}

    # We output const rather than G_CONST_RETURN.
    $type_modifier =~ s/G_CONST_RETURN/const/g;
    $pointer =~ s/G_CONST_RETURN/const/g;
    $pointer =~ s/^\s+/ /g;

    my $ret_type_len = length ($start) + length ($type_modifier)+ length ($type)
        + length ($pointer);
    my $ret_type_output;
    my $symbol_len;
    if ($ret_type_len < $RETURN_TYPE_FIELD_WIDTH) {
        $ret_type_output = "$start$type_modifier$xref$pointer"
            . (' ' x ($RETURN_TYPE_FIELD_WIDTH - $ret_type_len));
        $symbol_len = 0;
    } else {
        #$ret_type_output = "$start$type_modifier$xref$pointer\n" . (' ' x $RETURN_TYPE_FIELD_WIDTH);

        $ret_type_output = "$start$type_modifier$xref$pointer ";
        $symbol_len = $ret_type_len + 1 - $RETURN_TYPE_FIELD_WIDTH;
    }
    ##("$symbol ret type output: [$ret_type_output], $ret_type_len");

    $symbol_len += length ($symbol);
    my $char1 = my $char2 = my $char3 = "";
    if ($symbol_type eq 'USER_FUNCTION') {
        $symbol_len += 3;
        $char1 = "(";
        $char2 = "*";
        $char3 = ")";
    }

    my ($symbol_output, $symbol_desc_output);
    if ($symbol_len < $SYMBOL_FIELD_WIDTH) {
        $symbol_output = "$char1<link linkend=\"$id\">$char2$symbol</link>$char3"
            . (' ' x ($SYMBOL_FIELD_WIDTH - $symbol_len));
        $symbol_desc_output = "$char1$char2$symbol$char3"
            . (' ' x ($SYMBOL_FIELD_WIDTH - $symbol_len));
    } else {
        $symbol_output = "$char1<link linkend=\"$id\">$char2$symbol</link>$char3\n"
            . (' ' x ($SYMBOL_FIELD_WIDTH + $RETURN_TYPE_FIELD_WIDTH));
        $symbol_desc_output = "$char1$char2$symbol$char3\n"
            . (' ' x ($SYMBOL_FIELD_WIDTH + $RETURN_TYPE_FIELD_WIDTH));
    }

    my $synop = $ret_type_output . $symbol_output . '(';
    my $desc = "<refsect2 id=\"$id\" role=\"function\"$condition>\n<title>${symbol} ()</title>\n";

    $desc .= MakeIndexterms($symbol, $id);
    $desc .= "\n";
    $desc .= OutputSymbolExtraLinks($symbol);

    $desc  .= "<programlisting>${ret_type_output}$symbol_desc_output(";

    my @fields = ParseFunctionDeclaration($declaration, \&MakeXRef,
                                        sub {
                                            &tagify($_[0],"parameter");
                                        });

    for (my $i = 1; $i <= $#fields; $i += 2) {
        my $field_name = $fields[$i];

        if ($i == 1) {
            $synop .= "$field_name";
            $desc  .= "$field_name";
        } else {
            $synop .= ",\n"
                . (' ' x ($SYMBOL_FIELD_WIDTH + $RETURN_TYPE_FIELD_WIDTH))
                . " $field_name";
            $desc  .= ",\n"
                . (' ' x ($SYMBOL_FIELD_WIDTH + $RETURN_TYPE_FIELD_WIDTH))
                . " $field_name";
        }

    }

    $synop .= ");\n";
    $desc  .= ");</programlisting>\n";

    $desc .= &MakeDeprecationNote($symbol);

    my $parameters = &OutputParamDescriptions ("FUNCTION", $symbol, @fields);
    my $parameters_output = 0;

    if (defined ($SymbolDocs{$symbol})) {
        my $symbol_docs = &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});

        # Try to insert the parameter table at the author's desired position.
        # Otherwise we need to tag it onto the end.
        # FIXME: document that in the user manual and make it useable for other
        # types too
        if ($symbol_docs =~ s/<!--PARAMETERS-->/$parameters/) {
          $parameters_output = 1;
        }
        $desc .= $symbol_docs;
    }

    if ($parameters_output == 0) {
        $desc .= $parameters;
    }

    $desc .= OutputSymbolTraits ($symbol);
    $desc .= "</refsect2>\n";
    return ($synop, $desc);
}


#############################################################################
# Function    : OutputParamDescriptions
# Description : Returns the DocBook output describing the parameters of a
#                function, macro or signal handler.
# Arguments   : $symbol_type - 'FUNCTION', 'MACRO' or 'SIGNAL'. Signal
#                  handlers have an implicit user_data parameter last.
#                $symbol - the name of the function/macro being described.
#               @fields - parsed fields from the declaration, used to determine
#                  undocumented/unused entries
#############################################################################

sub OutputParamDescriptions {
    my ($symbol_type, $symbol, @fields) = @_;
    my $output = "";
    my $params = $SymbolParams{$symbol};
    my $num_params = 0;
    my %field_descrs = ();

    if (@fields) {
        %field_descrs = @fields;
        delete $field_descrs{"void"};
        delete $field_descrs{"Returns"};
    }

    if (defined $params) {
        my $returns = "";
        my $params_desc = "";
        my $missing_parameters = "";
        my $unused_parameters = "";
        my $j;

        for ($j = 0; $j <= $#$params; $j += $PARAM_FIELD_COUNT) {
            my $param_name = $$params[$j];
            my $param_desc = $$params[$j + 1];
            my $param_annotations = "";

            ($param_desc,$param_annotations) = & ExpandAnnotation($symbol, $param_desc);
            $param_desc = &ExpandAbbreviations($symbol, $param_desc);
            $param_desc .= $param_annotations;
            # trim
            $param_desc =~ s/^(\s|\n)+//msg;
            $param_desc =~ s/(\s|\n)+$//msg;
            if ($param_name eq "Returns") {
                $returns = "$param_desc";
            } elsif ($param_name eq "void") {
                #print "!!!! void in params for $symbol?\n";
            } else {
                if (@fields) {
                    if (!defined $field_descrs{$param_name}) {
                        &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                            "Parameter description for $symbol"."::"."$param_name is not used from source code comment block.");
                        if ($unused_parameters ne "") {
                          $unused_parameters .= ", ".$param_name;
                        } else {
                           $unused_parameters = $param_name;
                        }
                    } else {
                        delete $field_descrs{$param_name};
                    }
                }
                if($param_desc ne "") {
                    $params_desc .= "<varlistentry><term><parameter>$param_name</parameter>&#160;:</term>\n<listitem><simpara>$param_desc</simpara></listitem></varlistentry>\n";
                    $num_params++;
                }
            }
        }
        foreach my $param_name (keys %field_descrs) {
            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                "Parameter description for $symbol"."::"."$param_name is missing in source code comment block.");
            if ($missing_parameters ne "") {
              $missing_parameters .= ", ".$param_name;
            } else {
               $missing_parameters = $param_name;
            }
        }

        # Signals have an implicit user_data parameter which we describe.
        if ($symbol_type eq "SIGNAL") {
            $params_desc .= "<varlistentry><term><parameter>user_data</parameter>&#160;:</term>\n<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>\n";
        }

        # Start a table if we need one.
        if ($params_desc || $returns) {
            $output .= "<variablelist role=\"params\">\n";
            if ($params_desc ne "") {
                #$output .= "<varlistentry><term>Parameters:</term><listitem></listitem></varlistentry>\n";
                $output .= $params_desc;
            }

            # Output the returns info last
            if ($returns) {
                $output .= "<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>$returns</simpara></listitem></varlistentry>\n";
            }

            # Finish the table.
            $output .= "</variablelist>";
        }

        # remember missing/unused parameters (needed in tmpl-free build)
        if (($missing_parameters ne "") and (! exists ($AllIncompleteSymbols{$symbol}))) {
            $AllIncompleteSymbols{$symbol}=$missing_parameters;
        }
        if (($unused_parameters ne "") and (! exists ($AllUnusedSymbols{$symbol}))) {
            $AllUnusedSymbols{$symbol}=$unused_parameters;
        }
    }
    if (($num_params == 0) && @fields && (scalar(keys(%field_descrs)) > 0)) {
        if (! exists ($AllIncompleteSymbols{$symbol})) {
            $AllIncompleteSymbols{$symbol}="<parameters>";
        }
    }

    return $output;
}


#############################################################################
# Function    : ParseStabilityLevel
# Description : Parses a stability level and outputs a warning if it isn't
#               valid.
# Arguments   : $stability - the stability text.
#                $file, $line - context for error message
#                $message - description of where the level is from, to use in
#               any error message.
# Returns     : The parsed stability level string.
#############################################################################

sub ParseStabilityLevel {
    my ($stability, $file, $line, $message) = @_;

    $stability =~ s/^\s*//;
    $stability =~ s/\s*$//;
    if ($stability =~ m/^stable$/i) {
        $stability = "Stable";
    } elsif ($stability =~ m/^unstable$/i) {
        $stability = "Unstable";
    } elsif ($stability =~ m/^private$/i) {
        $stability = "Private";
    } else {
        &LogWarning ($file, $line, "$message is $stability.".
            "It should be one of these: Stable, Unstable, or Private.");
    }
    return $stability;
}


#############################################################################
# Function    : OutputSGMLFile
# Description : Outputs the final DocBook file for one section.
# Arguments   : $file - the name of the file.
#               $title - the title from the $MODULE-sections.txt file, which
#                 will be overridden by the title in the template file.
#               $section_id - the SGML id to use for the toplevel tag.
#               $includes - comma-separates list of include files added at top of
#                 synopsis, with '<' '>' around them (if not already enclosed in "").
#               $synopsis - reference to the DocBook for the Synopsis part.
#               $details - reference to the DocBook for the Details part.
#               $signal_synop - reference to the DocBook for the Signal Synopsis part
#               $signal_desc - reference to the DocBook for the Signal Description part
#               $args_synop - reference to the DocBook for the Arg Synopsis part
#               $args_desc - reference to the DocBook for the Arg Description part
#               $hierarchy - reference to the DocBook for the Object Hierarchy part
#               $interfaces - reference to the DocBook for the Interfaces part
#               $implementations - reference to the DocBook for the Known Implementations part
#               $prerequisites - reference to the DocBook for the Prerequisites part
#               $derived - reference to the DocBook for the Derived Interfaces part
#               $file_objects - reference to an array of objects in this file
#############################################################################

sub OutputSGMLFile {
    my ($file, $title, $section_id, $includes, $synopsis, $details, $signals_synop, $signals_desc, $args_synop, $args_desc, $hierarchy, $interfaces, $implementations, $prerequisites, $derived, $file_objects) = @_;

    #print "Output sgml for file $file with title '$title'\n";

    # The edited title overrides the one from the sections file.
    my $new_title = $SymbolDocs{"$TMPL_DIR/$file:Title"};
    if (defined ($new_title) && $new_title !~ m/^\s*$/) {
        $title = $new_title;
        #print "Found title: $title\n";
    }
    my $short_desc = $SymbolDocs{"$TMPL_DIR/$file:Short_Description"};
    if (!defined ($short_desc) || $short_desc =~ m/^\s*$/) {
        $short_desc = "";
    } else {
        $short_desc = &ExpandAbbreviations("$title:Short_description",
                                           $short_desc);
        #print "Found short_desc: $short_desc";
    }
    my $long_desc = $SymbolDocs{"$TMPL_DIR/$file:Long_Description"};
    if (!defined ($long_desc) || $long_desc =~ m/^\s*$/) {
        $long_desc = "";
    } else {
        $long_desc = &ExpandAbbreviations("$title:Long_description",
                                          $long_desc);
        #print "Found long_desc: $long_desc";
    }
    my $see_also = $SymbolDocs{"$TMPL_DIR/$file:See_Also"};
    if (!defined ($see_also) || $see_also =~ m%^\s*(<para>)?\s*(</para>)?\s*$%) {
        $see_also = "";
    } else {
        $see_also = &ExpandAbbreviations("$title:See_Also", $see_also);
        #print "Found see_also: $see_also";
    }
    if ($see_also) {
        $see_also = "<refsect1 id=\"$section_id.see-also\">\n<title>See Also</title>\n$see_also\n</refsect1>\n";
    }
    my $stability = $SymbolDocs{"$TMPL_DIR/$file:Stability_Level"};
    if (!defined ($stability) || $stability =~ m/^\s*$/) {
        $stability = "";
    } else {
        $stability = &ParseStabilityLevel($stability, $file, $., "Section stability level");
        #print "Found stability: $stability";
    }
    if ($stability) {
        $stability = "<refsect1 id=\"$section_id.stability-level\">\n<title>Stability Level</title>\n$stability, unless otherwise indicated\n</refsect1>\n";
    } elsif ($DEFAULT_STABILITY) {
        $stability = "<refsect1 id=\"$section_id.stability-level\">\n<title>Stability Level</title>\n$DEFAULT_STABILITY, unless otherwise indicated\n</refsect1>\n";
    }

    my $image = $SymbolDocs{"$TMPL_DIR/$file:Image"};
    if (!defined ($image) || $image =~ m/^\s*$/) {
      $image = "";
    } else {
      $image =~ s/^\s*//;
      $image =~ s/\s*$//;

      my $format;

      if ($image =~ /jpe?g$/i) {
        $format = "format='JPEG'";
      } elsif ($image =~ /png$/i) {
        $format = "format='PNG'";
      } elsif ($image =~ /svg$/i) {
        $format = "format='SVG'";
      } else {
        $format = "";
      }

      $image = "  <inlinegraphic fileref='$image' $format/>\n"
    }

    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
        gmtime (time);
    my $month = (qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec))[$mon];
    $year += 1900;

    my $include_output = "";
    my $include;
    foreach $include (split (/,/, $includes)) {
        if ($include =~ m/^\".+\"$/) {
            $include_output .= "#include ${include}\n";
        }
        else {
            $include =~ s/^\s+|\s+$//gs;
            $include_output .= "#include &lt;${include}&gt;\n";
        }
    }
    if ($include_output ne '') {
        $include_output = "\n$include_output\n";
    }

    my $extralinks = OutputSectionExtraLinks($title,"Section:$file");

    my $old_sgml_file = "$SGML_OUTPUT_DIR/$file.$OUTPUT_FORMAT";
    my $new_sgml_file = "$SGML_OUTPUT_DIR/$file.$OUTPUT_FORMAT.new";

    open (OUTPUT, ">$new_sgml_file")
        || die "Can't create $new_sgml_file: $!";

    my $object_anchors = "";
    foreach my $object (@$file_objects) {
        next if ($object eq $section_id);
        my $id = CreateValidSGMLID($object);
        #print "Debug: Adding anchor for $object\n";
        $object_anchors .= "<anchor id=\"$id\"$empty_element_end";
    }

    # We used to output this, but is messes up our UpdateFileIfChanged code
    # since it changes every day (and it is only used in the man pages):
    # "<refentry id="$section_id" revision="$mday $month $year">"

    if ($OUTPUT_FORMAT eq "xml") {
        print OUTPUT $doctype_header;
    }

    print OUTPUT <<EOF;
<refentry id="$section_id">
<refmeta>
<refentrytitle role="top_of_page" id="$section_id.top_of_page">$title</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>
  \U$MODULE\E Library
$image</refmiscinfo>
</refmeta>
<refnamediv>
<refname>$title</refname>
<refpurpose>$short_desc</refpurpose>
</refnamediv>
$stability
<refsynopsisdiv id="$section_id.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>
$object_anchors
<synopsis>$include_output$${synopsis}</synopsis>
</refsynopsisdiv>
$$hierarchy$$prerequisites$$derived$$interfaces$$implementations$$args_synop$$signals_synop
<refsect1 id="$section_id.description" role="desc">
<title role="desc.title">Description</title>
$extralinks$long_desc
</refsect1>
<refsect1 id="$section_id.details" role="details">
<title role="details.title">Details</title>
$$details
</refsect1>
$$args_desc$$signals_desc$see_also
</refentry>
EOF
    close (OUTPUT);

    return &UpdateFileIfChanged ($old_sgml_file, $new_sgml_file, 0);
}


#############################################################################
# Function    : OutputExtraFile
# Description : Copies an "extra" DocBook file into the output directory,
#               expanding abbreviations
# Arguments   : $file - the source file.
#############################################################################
sub OutputExtraFile {
    my ($file) = @_;

    my $basename;

    ($basename = $file) =~ s!^.*/!!;

    my $old_sgml_file = "$SGML_OUTPUT_DIR/$basename";
    my $new_sgml_file = "$SGML_OUTPUT_DIR/$basename.new";

    my $contents;

    open(EXTRA_FILE, "<$file") || die "Can't open $file";

    {
        local $/;
        $contents = <EXTRA_FILE>;
    }

    open (OUTPUT, ">$new_sgml_file")
        || die "Can't create $new_sgml_file: $!";

    print OUTPUT &ExpandAbbreviations ("$basename file", $contents);
    close (OUTPUT);

    return &UpdateFileIfChanged ($old_sgml_file, $new_sgml_file, 0);
}
#############################################################################
# Function    : OutputBook
# Description : Outputs the SGML entities that need to be included into the
#                main SGML file for the module.
# Arguments   : $book_top - the declarations of the entities, which are added
#                  at the top of the main SGML file.
#                $book_bottom - the references to the entities, which are
#                  added in the main SGML file at the desired position.
#############################################################################

sub OutputBook {
    my ($book_top, $book_bottom) = @_;

    my $old_file = "$SGML_OUTPUT_DIR/$MODULE-doc.top";
    my $new_file = "$SGML_OUTPUT_DIR/$MODULE-doc.top.new";

    open (OUTPUT, ">$new_file")
        || die "Can't create $new_file: $!";
    print OUTPUT $book_top;
    close (OUTPUT);

    &UpdateFileIfChanged ($old_file, $new_file, 0);


    $old_file = "$SGML_OUTPUT_DIR/$MODULE-doc.bottom";
    $new_file = "$SGML_OUTPUT_DIR/$MODULE-doc.bottom.new";

    open (OUTPUT, ">$new_file")
        || die "Can't create $new_file: $!";
    print OUTPUT $book_bottom;
    close (OUTPUT);

    &UpdateFileIfChanged ($old_file, $new_file, 0);


    # If the main SGML/XML file hasn't been created yet, we create it here.
    # The user can tweak it later.
    if ($MAIN_SGML_FILE && ! -e $MAIN_SGML_FILE) {
      open (OUTPUT, ">$MAIN_SGML_FILE")
        || die "Can't create $MAIN_SGML_FILE: $!";

      if ($OUTPUT_FORMAT eq "xml") {
          print OUTPUT <<EOF;
<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
  <!ENTITY % local.common.attrib "xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'">
]>
<book id="index">
EOF
      } else {
        print OUTPUT <<EOF;
<!doctype book PUBLIC "-//Davenport//DTD DocBook V3.0//EN" [
$book_top
]>
<book id="index">
EOF
      }

print OUTPUT <<EOF;
  <bookinfo>
    <title>$MODULE Reference Manual</title>
    <releaseinfo>
      for $MODULE [VERSION].
      The latest version of this documentation can be found on-line at
      <ulink role="online-location" url="http://[SERVER]/$MODULE/index.html">http://[SERVER]/$MODULE/</ulink>.
    </releaseinfo>
  </bookinfo>

  <chapter>
    <title>[Insert title here]</title>
    $book_bottom
  </chapter>
EOF
  if (-e $OBJECT_TREE_FILE) {
    print OUTPUT <<EOF;
  <chapter id="object-tree">
    <title>Object Hierarchy</title>
     <xi:include href="xml/tree_index.sgml"/>
  </chapter>
EOF
  }

print OUTPUT <<EOF;
  <index id="api-index-full">
    <title>API Index</title>
    <xi:include href="xml/api-index-full.xml"><xi:fallback /></xi:include>
  </index>
  <index id="deprecated-api-index" role="deprecated">
    <title>Index of deprecated API</title>
    <xi:include href="xml/api-index-deprecated.xml"><xi:fallback /></xi:include>
  </index>

  <xi:include href="xml/annotation-glossary.xml"><xi:fallback /></xi:include>
</book>
EOF

      close (OUTPUT);
    }
}


#############################################################################
# Function    : CreateValidSGML
# Description : This turns any chars which are used in SGML into entities,
#                e.g. '<' into '&lt;'
# Arguments   : $text - the text to turn into proper SGML.
#############################################################################

sub CreateValidSGML {
    my ($text) = @_;
    $text =~ s/&/&amp;/g;        # Do this first, or the others get messed up.
    $text =~ s/</&lt;/g;
    $text =~ s/>/&gt;/g;
    # browers render single tabs inconsistently
    $text =~ s/([^\s])\t([^\s])/$1&#160;$2/g;
    return $text;
}

#############################################################################
# Function    : ConvertSGMLChars
# Description : This is used for text in source code comment blocks, to turn
#               chars which are used in SGML into entities, e.g. '<' into
#               '&lt;'. Depending on $INLINE_MARKUP_MODE, this is done
#               unconditionally or only if the character doesn't seem to be
#               part of an SGML construct (tag or entity reference).
# Arguments   : $text - the text to turn into proper SGML.
#############################################################################

sub ConvertSGMLChars {
    my ($symbol, $text) = @_;

    if ($INLINE_MARKUP_MODE) {
        # For the XML/SGML mode only convert to entities outside CDATA sections.
        return &ModifyXMLElements ($text, $symbol,
                                   "<!\\[CDATA\\[|<programlisting[^>]*>",
                                   \&ConvertSGMLCharsEndTag,
                                   \&ConvertSGMLCharsCallback);
    } else {
        # For the simple non-sgml mode, convert to entities everywhere.
        $text =~ s/&/&amp;/g;        # Do this first, or the others get messed up.
        $text =~ s/</&lt;/g;
        $text =~ s/>/&gt;/g;
        return $text;
    }
}


sub ConvertSGMLCharsEndTag {
  if ($_[0] eq "<!\[CDATA\[") {
    return "]]>";
  } else {
    return "</programlisting>";
  }
}

sub ConvertSGMLCharsCallback {
  my ($text, $symbol, $tag) = @_;

  if ($tag =~ m/^<programlisting/) {
    # We can handle <programlisting> specially here.
    return &ModifyXMLElements ($text, $symbol,
                               "<!\\[CDATA\\[",
                               \&ConvertSGMLCharsEndTag,
                               \&ConvertSGMLCharsCallback2);
  } elsif ($tag eq "") {
    # If we're not in CDATA convert to entities.
    $text =~ s/&(?![a-zA-Z#]+;)/&amp;/g;        # Do this first, or the others get messed up.
    $text =~ s/<(?![a-zA-Z\/!])/&lt;/g;
    $text =~ s/(?<![a-zA-Z0-9"'\/-])>/&gt;/g;

    # Handle "#include <xxxxx>"
    $text =~ s/#include(\s+)<([^>]+)>/#include$1&lt;$2&gt;/g;
  }

  return $text;
}

sub ConvertSGMLCharsCallback2 {
  my ($text, $symbol, $tag) = @_;

  # If we're not in CDATA convert to entities.
  # We could handle <programlisting> differently, though I'm not sure it helps.
  if ($tag eq "") {
    # replace only if its not a tag
    $text =~ s/&(?![a-zA-Z#]+;)/&amp;/g;        # Do this first, or the others get messed up.
    $text =~ s/<(?![a-zA-Z\/!])/&lt;/g;
    $text =~ s/(?<![a-zA-Z0-9"'\/-])>/&gt;/g;

    # Handle "#include <xxxxx>"
    $text =~ s/#include(\s+)<([^>]+)>/#include$1&lt;$2&gt;/g;
  }

  return $text;
}

#############################################################################
# Function    : ExpandAnnotation
# Description : This turns annotations into acronym tags.
# Arguments   : $symbol - the symbol being documented, for error messages.
#                $text - the text to expand.
#############################################################################
sub ExpandAnnotation {
    my ($symbol, $param_desc) = @_;
    my $param_annotations = "";

    # look for annotations at the start of the comment part
    if ($param_desc =~ m%^\s*\((.*?)\):%) {
        my @annotations;
        my $annotation;
        $param_desc = $';

        @annotations = split(/\)\s*\(/,$1);
        foreach $annotation (@annotations) {
            # need to search for the longest key-match in %AnnotationDefinition
            my $match_length=0;
            my $match_annotation="";
            my $annotationdef;
            foreach $annotationdef (keys %AnnotationDefinition) {
                if ($annotation =~ m/^$annotationdef/) {
                    if (length($annotationdef)>$match_length) {
                        $match_length=length($annotationdef);
                        $match_annotation=$annotationdef;
                    }
                }
            }
            my $annotation_extra = "";
            if ($match_annotation ne "") {
                if ($annotation =~ m%$match_annotation\s+(.*)%) {
                    $annotation_extra = " $1";
                }
                $AnnotationsUsed{$match_annotation} = 1;
                $param_annotations .= "[<acronym>$match_annotation</acronym>$annotation_extra]";
            }
            else {
                &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                    "unknown annotation \"$annotation\" in documentation for $symbol.");
                $param_annotations .= "[$annotation]";
            }
        }
        chomp($param_desc);
        $param_desc =~ m/^(.*?)\.*\s*$/s;
        $param_desc = "$1. ";
    }
    if ($param_annotations ne "") {
        $param_annotations = "<emphasis role=\"annotation\">$param_annotations</emphasis>";
    }
    return ($param_desc, $param_annotations);
}

#############################################################################
# Function    : ExpandAbbreviations
# Description : This turns the abbreviations function(), macro(), @param,
#                %constant, and #symbol into appropriate DocBook markup.
#               CDATA sections and <programlisting> parts are skipped.
# Arguments   : $symbol - the symbol being documented, for error messages.
#                $text - the text to expand.
#############################################################################

sub ExpandAbbreviations {
  my ($symbol, $text) = @_;

  # Convert "|[" and "]|" into the start and end of program listing examples.
  # FIXME: we like to have a way to specify parameters e.g. language="c"
  $text =~ s%\|\[%<informalexample><programlisting>%g;
  $text =~ s%\]\|%</programlisting></informalexample>%g;
  # TODO: check for a xml comment after |[ and pick the language attribute from
  # that

  # keep CDATA unmodified, preserve ulink tags (ideally we preseve all tags
  # as such)
  return &ModifyXMLElements ($text, $symbol,
                             "<!\\[CDATA\\[|<ulink[^>]*>|<programlisting[^>]*>|<!DOCTYPE",
                             \&ExpandAbbreviationsEndTag,
                             \&ExpandAbbreviationsCallback);
}


# Returns the end tag corresponding to the given start tag.
sub ExpandAbbreviationsEndTag {
  my ($start_tag) = @_;

  if ($start_tag eq "<!\[CDATA\[") {
    return "]]>";
  } elsif ($start_tag eq "<!DOCTYPE") {
    return "]>";
  } elsif ($start_tag =~ m/<(\w+)/) {
    return "</$1>";
  }
}

# Called inside or outside each CDATA or <programlisting> section.
sub ExpandAbbreviationsCallback {
  my ($text, $symbol, $tag) = @_;

  if ($tag =~ m/^<programlisting/) {
    # Handle any embedded CDATA sections.
    return &ModifyXMLElements ($text, $symbol,
                               "<!\\[CDATA\\[",
                               \&ExpandAbbreviationsEndTag,
                               \&ExpandAbbreviationsCallback2);
  } elsif ($tag eq "") {
    # We are outside any CDATA or <programlisting> sections, so we expand
    # any gtk-doc abbreviations.

    # Convert '@param()'
    # FIXME: we could make those also links ($symbol.$2), but that would be less
    # useful as the link target is a few lines up or down
    $text =~ s/(\A|[^\\])\@(\w+((\.|->)\w+)*)\s*\(\)/$1<parameter>$2()<\/parameter>/g;

    # Convert 'function()' or 'macro()'.
    # if there is abc_*_def() we don't want to make a link to _def()
    # FIXME: also handle abc(def(....)) : but that would need to be done recursively :/
    $text =~ s/([^\*.\w])(\w+)\s*\(\)/$1.&MakeXRef($2, &tagify($2 . "()", "function"));/eg;
    # handle #Object.func()
    $text =~ s/(\A|[^\\])#([\w\-:\.]+[\w]+)\s*\(\)/$1.&MakeXRef($2, &tagify($2 . "()", "function"));/eg;

    # Convert '@param', but not '\@param'.
    $text =~ s/(\A|[^\\])\@(\w+((\.|->)\w+)*)/$1<parameter>$2<\/parameter>/g;
    $text =~ s/\\\@/\@/g;

    # Convert '%constant', but not '\%constant'.
    # Also allow negative numbers, e.g. %-1.
    $text =~ s/(\A|[^\\])\%(-?\w+)/$1.&MakeXRef($2, &tagify($2, "literal"));/eg;
    $text =~ s/\\\%/\%/g;

    # Convert '#symbol', but not '\#symbol'.
    $text =~ s/(\A|[^\\])#([\w\-:\.]+[\w]+)/$1.&MakeHashXRef($2, "type");/eg;
    $text =~ s/\\#/#/g;

    # Expand urls
    # FIXME: should we skip urls that are already tagged? (e.g. <literal>http://...</literal>)
    # this is apparently also called for markup and not just for plain text
    # disable for now.
    #$text =~ s%(http|https|ftp)://(.*?)((?:\s|,|\)|\]|\<|\.\s))%<ulink url="$1://$2">$2</ulink>$3%g;

    # TODO: optionally check all words from $text against internal symbols and
    # warn if those could be xreffed, but miss a %,# or ()
  }

  return $text;
}

# This is called inside a <programlisting>
sub ExpandAbbreviationsCallback2 {
  my ($text, $symbol, $tag) = @_;

  if ($tag eq "") {
    # We are inside a <programlisting> but outside any CDATA sections,
    # so we expand any gtk-doc abbreviations.
    # FIXME: why is this different from &ExpandAbbreviationsCallback(),
    #        why not just call it
    $text =~ s/#(\w+)/&MakeHashXRef($1, "");/eg;
  }

  return $text;
}

sub MakeHashXRef {
    my ($symbol, $tag) = @_;;
    my $text = $symbol;

    # Check for things like '#include', '#define', and skip them.
    if ($PreProcessorDirectives{$symbol}) {
      return "#$symbol";
    }

    # Get rid of special suffixes ('-struct','-enum').
    $text =~ s/-struct$//;
    $text =~ s/-enum$//;

    # If the symbol is in the form "Object::signal", then change the symbol to
    # "Object-signal" and use "signal" as the text.
    if ($symbol =~ s/::/-/) {
      $text = "\"$'\"";
    }

    # If the symbol is in the form "Object:property", then change the symbol to
    # "Object--property" and use "property" as the text.
    if ($symbol =~ s/:/--/) {
      $text = "\"$'\"";
    }

    if ($tag ne "") {
      $text = tagify ($text, $tag);
    }

    return &MakeXRef($symbol, $text);
}


#############################################################################
# Function    : ModifyXMLElements
# Description : Looks for given XML element tags within the text, and calls
#               the callback on pieces of text inside & outside those elements.
#               Used for special handling of text inside things like CDATA
#               and <programlisting>.
# Arguments   : $text - the text.
#               $symbol - the symbol currently being documented (only used for
#                      error messages).
#               $start_tag_regexp - the regular expression to match start tags.
#                      e.g. "<!\\[CDATA\\[|<programlisting[^>]*>" to match
#                      CDATA sections or programlisting elements.
#               $end_tag_func - function which is passed the matched start tag
#                      and should return the appropriate end tag string.
#               $callback - callback called with each part of the text. It is
#                      called with a piece of text, the symbol being
#                      documented, and the matched start tag or "" if the text
#                      is outside the XML elements being matched.
#############################################################################
sub ModifyXMLElements {
    my ($text, $symbol, $start_tag_regexp, $end_tag_func, $callback) = @_;
    my ($before_tag, $start_tag, $end_tag_regexp, $end_tag);
    my $result = "";

    while ($text =~ m/$start_tag_regexp/s) {
      $before_tag = $`; # Prematch for last successful match string
      $start_tag = $&;  # Last successful match
      $text = $';       # Postmatch for last successful match string

      $result .= &$callback ($before_tag, $symbol, "");
      $result .= $start_tag;

      # get the mathing end-tag for current tag
      $end_tag_regexp = &$end_tag_func ($start_tag);

      if ($text =~ m/$end_tag_regexp/s) {
        $before_tag = $`;
        $end_tag = $&;
        $text = $';

        $result .= &$callback ($before_tag, $symbol, $start_tag);
        $result .= $end_tag;
      } else {
        &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
            "Can't find tag end: $end_tag_regexp in docs for: $symbol.");
        # Just assume it is all inside the tag.
        $result .= &$callback ($text, $symbol, $start_tag);
        $text = "";
      }
    }

    # Handle any remaining text outside the tags.
    $result .= &$callback ($text, $symbol, "");

    return $result;
}

sub noop {
  return $_[0];
}

# Adds a tag around some text.
# e.g tagify("Text", "literal") => "<literal>Text</literal>".
sub tagify {
   my ($text, $elem) = @_;
   return "<" . $elem . ">" . $text . "</" . $elem . ">";
}


#############################################################################
# Function    : MakeXRef
# Description : This returns a cross-reference link to the given symbol.
#                Though it doesn't try to do this for a few standard C types
#                that it        knows won't be in the documentation.
# Arguments   : $symbol - the symbol to try to create a XRef to.
#               $text - text text to put inside the XRef, defaults to $symbol
#############################################################################

sub MakeXRef {
    my ($symbol, $text) = ($_[0], $_[1]);

    $symbol =~ s/^\s+//;
    $symbol =~ s/\s+$//;

    if (!defined($text)) {
        $text = $symbol;

        # Get rid of special suffixes ('-struct','-enum').
        $text =~ s/-struct$//;
        $text =~ s/-enum$//;
    }

    if ($symbol =~ m/ /) {
        return "$text";
    }

    #print "Getting type link for $symbol -> $text\n";

    my $symbol_id = &CreateValidSGMLID ($symbol);
    return "<link linkend=\"$symbol_id\">$text</link>";
}


#############################################################################
# Function    : MakeIndexterms
# Description : This returns a indexterm elements for the given symbol
# Arguments   : $symbol - the symbol to create indexterms for
#############################################################################

sub MakeIndexterms {
  my ($symbol, $id) = @_;
  my $terms =  "";
  my $sortas = "";

  # make the index useful, by ommiting the namespace when sorting
  if ($NAME_SPACE ne "") {
    if ($symbol =~ m/^$NAME_SPACE\_?(.*)/i) {
       $sortas=" sortas=\"$1\"";
    }
  }

  if (exists $Deprecated{$symbol}) {
      $terms .= "<indexterm zone=\"$id\" role=\"deprecated\"><primary$sortas>$symbol</primary></indexterm>";
      $IndexEntriesDeprecated{$symbol}=$id;
      $IndexEntriesFull{$symbol}=$id;
  }
  if (exists $Since{$symbol}) {
     my $since = $Since{$symbol};
     $since =~ s/^\s+//;
     $since =~ s/\s+$//;
     if ($since ne "") {
         $terms .= "<indexterm zone=\"$id\" role=\"$since\"><primary$sortas>$symbol</primary></indexterm>";
     }
     $IndexEntriesSince{$symbol}=$id;
     $IndexEntriesFull{$symbol}=$id;
  }
  if ($terms eq "") {
     $terms .= "<indexterm zone=\"$id\"><primary$sortas>$symbol</primary></indexterm>";
     $IndexEntriesFull{$symbol}=$id;
  }

  return $terms;
 }

#############################################################################
# Function    : MakeDeprecationNote
# Description : This returns a deprecation warning for the given symbol.
# Arguments   : $symbol - the symbol to try to create a warning for.
#############################################################################

sub MakeDeprecationNote {
    my ($symbol) = $_[0];
    my $desc = "";
    my $note = "";
    if (exists $Deprecated{$symbol}) {
        $desc .= "<warning>";

        if ($Deprecated{$symbol} =~ /^\s*([0-9\.]+)\s*:/) {
                $desc .= "<para><literal>$symbol</literal> has been deprecated since version $1 and should not be used in newly-written code.";
        } else {
                $desc .= "<para><literal>$symbol</literal> is deprecated and should not be used in newly-written code.";
        }
        if ($Deprecated{$symbol} ne "") {
            $note = &ExpandAbbreviations($symbol, $Deprecated{$symbol});
            $note =~ s/^\s*([0-9\.]+)\s*:\s*//;
            $note =~ s/^\s+//;
            $note =~ s/\s+$//;
            $note =~ s%\n{2,}%\n</para>\n<para>\n%g;
            $desc .= " " . $note;
        }
        $desc .= "</para></warning>\n";
    }
    return $desc;
}

#############################################################################
# Function    : MakeConditionDescription
# Description : This returns a sumary of conditions for the given symbol.
# Arguments   : $symbol - the symbol to try to create the sumary.
#############################################################################

sub MakeConditionDescription {
    my ($symbol) = $_[0];
    my $desc = "";

    if (exists $Deprecated{$symbol}) {
        if ($desc ne "") {
            $desc .= "|";
        }

        if ($Deprecated{$symbol} =~ /^\s*(.*?)\s*$/) {
                $desc .= "deprecated:$1";
        } else {
                $desc .= "deprecated";
        }
    }

    if (exists $Since{$symbol}) {
        if ($desc ne "") {
            $desc .= "|";
        }

        if ($Since{$symbol} =~ /^\s*(.*?)\s*$/) {
                $desc .= "since:$1";
        } else {
                $desc .= "since";
        }
    }

    if (exists $StabilityLevel{$symbol}) {
        if ($desc ne "") {
            $desc .= "|";
        }
        $desc .= "stability:".$StabilityLevel{$symbol};
    }

    if ($desc ne "") {
        $desc=" condition=\"".$desc."\"";
        #print "condition for '$symbol' = '$desc'\n";
    }
    return $desc;
}

#############################################################################
# Function    : GetHierarchy
# Description : Returns the DocBook output describing the ancestors and
#               immediate children of a GObject subclass. It uses the
#               global @Objects and @ObjectLevels arrays to walk the tree.
# Arguments   : $object - the GtkObject subclass.
#############################################################################

sub GetHierarchy {
    my ($object) = @_;

    # Find object in the objects array.
    my $found = 0;
    my @children = ();
    my $i;
    my $level;
    my $j;
    for ($i = 0; $i < @Objects; $i++) {
        if ($found) {
            if ($ObjectLevels[$i] <= $level) {
            last;
        }
            elsif ($ObjectLevels[$i] == $level + 1) {
                push (@children, $Objects[$i]);
            }
        }
        elsif ($Objects[$i] eq $object) {
            $found = 1;
            $j = $i;
            $level = $ObjectLevels[$i];
        }
    }
    if (!$found) {
        return "";
    }

    # Walk up the hierarchy, pushing ancestors onto the ancestors array.
    my @ancestors = ();
    push (@ancestors, $object);
    #print "Level: $level\n";
    while ($level > 1) {
        $j--;
        if ($ObjectLevels[$j] < $level) {
            push (@ancestors, $Objects[$j]);
            $level = $ObjectLevels[$j];
            #print "Level: $level\n";
        }
    }

    # Output the ancestors list, indented and with links.
    my $hierarchy = "<synopsis>\n";
    $level = 0;
    for ($i = $#ancestors; $i >= 0; $i--) {
        my $link_text;
        # Don't add a link to the current object, i.e. when i == 0.
        if ($i > 0) {
            my $ancestor_id = &CreateValidSGMLID ($ancestors[$i]);
            $link_text = "<link linkend=\"$ancestor_id\">$ancestors[$i]</link>";
        } else {
            $link_text = "$ancestors[$i]";
        }
        if ($level == 0) {
            $hierarchy .= "  $link_text\n";
        } else {
#            $hierarchy .= ' ' x ($level * 6 - 3) . "|\n";
            $hierarchy .= ' ' x ($level * 6 - 3) . "+----$link_text\n";
        }
        $level++;
    }
    for ($i = 0; $i <= $#children; $i++) {
      my $id = &CreateValidSGMLID ($children[$i]);
      my $link_text = "<link linkend=\"$id\">$children[$i]</link>";
      $hierarchy .= ' ' x ($level * 6 - 3) . "+----$link_text\n";
    }
    $hierarchy .= "</synopsis>\n";

    return $hierarchy;
}


#############################################################################
# Function    : GetInterfaces
# Description : Returns the DocBook output describing the interfaces
#               implemented by a class. It uses the global %Interfaces hash.
# Arguments   : $object - the GtkObject subclass.
#############################################################################

sub GetInterfaces {
    my ($object) = @_;
    my $text = "";
    my $i;

    # Find object in the objects array.
    if (exists($Interfaces{$object})) {
        my @ifaces = split(' ', $Interfaces{$object});
        $text = <<EOF;
<para>
$object implements
EOF
        for ($i = 0; $i <= $#ifaces; $i++) {
            my $id = &CreateValidSGMLID ($ifaces[$i]);
            $text .= " <link linkend=\"$id\">$ifaces[$i]</link>";
            if ($i < $#ifaces - 1) {
                $text .= ', ';
            }
            elsif ($i < $#ifaces) {
                $text .= ' and ';
            }
            else {
                $text .= '.';
            }
        }
        $text .= <<EOF;
</para>
EOF
    }

    return $text;
}

#############################################################################
# Function    : GetImplementations
# Description : Returns the DocBook output describing the implementations
#               of an interface. It uses the global %Interfaces hash.
# Arguments   : $object - the GtkObject subclass.
#############################################################################

sub GetImplementations {
    my ($object) = @_;
    my @impls = ();
    my $text = "";
    my $i;
    foreach my $key (keys %Interfaces) {
        if ($Interfaces{$key} =~ /\b$object\b/) {
            push (@impls, $key);
        }
    }
    if ($#impls >= 0) {
        @impls = sort @impls;
        $text = <<EOF;
<para>
$object is implemented by
EOF
        for ($i = 0; $i <= $#impls; $i++) {
            my $id = &CreateValidSGMLID ($impls[$i]);
            $text .= " <link linkend=\"$id\">$impls[$i]</link>";
            if ($i < $#impls - 1) {
                $text .= ', ';
            }
            elsif ($i < $#impls) {
                $text .= ' and ';
            }
            else {
                $text .= '.';
            }
        }
        $text .= <<EOF;
</para>
EOF
    }
    return $text;
}


#############################################################################
# Function    : GetPrerequisites
# Description : Returns the DocBook output describing the prerequisites
#               of an interface. It uses the global %Prerequisites hash.
# Arguments   : $iface - the interface.
#############################################################################

sub GetPrerequisites {
    my ($iface) = @_;
    my $text = "";
    my $i;

    if (exists($Prerequisites{$iface})) {
        $text = <<EOF;
<para>
$iface requires
EOF
        my @prereqs = split(' ', $Prerequisites{$iface});
        for ($i = 0; $i <= $#prereqs; $i++) {
            my $id = &CreateValidSGMLID ($prereqs[$i]);
            $text .= " <link linkend=\"$id\">$prereqs[$i]</link>";
            if ($i < $#prereqs - 1) {
                $text .= ', ';
            }
            elsif ($i < $#prereqs) {
                $text .= ' and ';
            }
            else {
                $text .= '.';
            }
        }
        $text .= <<EOF;
</para>
EOF
    }
    return $text;
}

#############################################################################
# Function    : GetDerived
# Description : Returns the DocBook output describing the derived interfaces
#               of an interface. It uses the global %Prerequisites hash.
# Arguments   : $iface - the interface.
#############################################################################

sub GetDerived {
    my ($iface) = @_;
    my $text = "";
    my $i;

    my @derived = ();
    foreach my $key (keys %Prerequisites) {
        if ($Prerequisites{$key} =~ /\b$iface\b/) {
            push (@derived, $key);
        }
    }
    if ($#derived >= 0) {
        @derived = sort @derived;
        $text = <<EOF;
<para>
$iface is required by
EOF
        for ($i = 0; $i <= $#derived; $i++) {
            my $id = &CreateValidSGMLID ($derived[$i]);
            $text .= " <link linkend=\"$id\">$derived[$i]</link>";
            if ($i < $#derived - 1) {
                $text .= ', ';
            }
            elsif ($i < $#derived) {
                $text .= ' and ';
            }
            else {
                $text .= '.';
            }
        }
        $text .= <<EOF;
</para>
EOF
    }
    return $text;
}


#############################################################################
# Function    : GetSignals
# Description : Returns the synopsis and detailed description DocBook output
#                for the signal handlers of a given GtkObject subclass.
# Arguments   : $object - the GtkObject subclass, e.g. 'GtkButton'.
#############################################################################

sub GetSignals {
    my ($object) = @_;
    my $synop = "";
    my $desc = "";

    my $i;
    for ($i = 0; $i <= $#SignalObjects; $i++) {
        if ($SignalObjects[$i] eq $object) {
            #print "Found signal: $SignalNames[$i]\n";
            my $name = $SignalNames[$i];
            my $symbol = "${object}::${name}";
            my $id = &CreateValidSGMLID ("$object-$name");

            my $pad = ' ' x (46 - length($name));
            $synop .= "  &quot;<link linkend=\"$id\">$name</link>&quot;$pad ";

            $desc .= "<refsect2 id=\"$id\" role=\"signal\"><title>The <literal>&quot;$name&quot;</literal> signal</title>\n";
            $desc .= MakeIndexterms($symbol, $id);
            $desc .= "\n";
            $desc .= OutputSymbolExtraLinks($symbol);

            $desc .= "<programlisting>";

            $SignalReturns[$i] =~ m/\s*(const\s+)?(\w+)\s*(\**)/;
            my $type_modifier = defined($1) ? $1 : "";
            my $type = $2;
            my $pointer = $3;
            my $xref = &MakeXRef ($type, &tagify($type, "returnvalue"));

            my $ret_type_len = length ($type_modifier) + length ($pointer)
                + length ($type);
            my $ret_type_output = "$type_modifier$xref$pointer"
                . (' ' x ($RETURN_TYPE_FIELD_WIDTH - $ret_type_len));

            $desc  .= "${ret_type_output}user_function " . &MakeReturnField("") . " (";

            my $sourceparams = $SourceSymbolParams{$symbol};
            my @params = split ("\n", $SignalPrototypes[$i]);
            my $j;
            my $l;
            my $type_len = length("gpointer");
            my $name_len = length("user_data");
            # do two passes, the first one is to calculate padding
            for ($l = 0; $l < 2; $l++) {
                for ($j = 0; $j <= $#params; $j++) {
                    # allow alphanumerics, '_', '[' & ']' in param names
                    if ($params[$j] =~ m/^\s*(\w+)\s*(\**)\s*([\w\[\]]+)\s*$/) {
                        $type = $1;
                        $pointer = $2;
                        if (defined($sourceparams)) {
                            $name = $$sourceparams[$PARAM_FIELD_COUNT * $j];
                        }
                        else {
                            $name = $3;
                        }
                        if (!defined($name)) {
                            $name = "arg$j";
                        }
                        if ($l == 0) {
                            if (length($type) + length($pointer) > $type_len) {
                                $type_len = length($type) + length($pointer);
                            }
                            if (length($name) > $name_len) {
                                $name_len = length($name);
                            }
                        }
                        else {
                            $xref = &MakeXRef ($type, &tagify($type, "type"));
                            $pad = ' ' x ($type_len - length($type) - length($pointer));
                            $desc .= "$xref$pad $pointer$name,\n";
                            $desc .= (' ' x ($SYMBOL_FIELD_WIDTH + $RETURN_TYPE_FIELD_WIDTH));
                        }
                    } else {
                        &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                             "Can't parse arg: $params[$j]\nArgs:$SignalPrototypes[$i]");
                    }
                }
            }
            $xref = &MakeXRef ("gpointer", &tagify("gpointer", "type"));
            $pad = ' ' x ($type_len - length("gpointer"));
            $desc  .= "$xref$pad user_data)";

            my $flags = $SignalFlags[$i];
            my $flags_string = "";

            if (defined ($flags)) {
              if ($flags =~ m/f/) {
                $flags_string = "<link linkend=\"G-SIGNAL-RUN-FIRST:CAPS\"><literal>Run First</literal></link>";
              }
              elsif ($flags =~ m/l/) {
                $flags_string = "<link linkend=\"G-SIGNAL-RUN-LAST:CAPS\"><literal>Run Last</literal></link>";
              }
              elsif ($flags =~ m/c/) {
                $flags_string = "<link linkend=\"G-SIGNAL-RUN-CLEANUP:CAPS\"><literal>Cleanup</literal></link>";
                $flags_string = "Cleanup";
              }
              if ($flags =~ m/r/) {
                if ($flags_string) { $flags_string .= " / "; }
                $flags_string = "<link linkend=\"G-SIGNAL-NO-RECURSE:CAPS\"><literal>No Recursion</literal></link>";
              }
              if ($flags =~ m/d/) {
                if ($flags_string) { $flags_string .= " / "; }
                $flags_string = "<link linkend=\"G-SIGNAL-DETAILED:CAPS\"><literal>Has Details</literal></link>";
              }
              if ($flags =~ m/a/) {
                if ($flags_string) { $flags_string .= " / "; }
                $flags_string = "<link linkend=\"G-SIGNAL-ACTION:CAPS\"><literal>Action</literal></link>";
              }
              if ($flags =~ m/h/) {
                if ($flags_string) { $flags_string .= " / "; }
                $flags_string = "<link linkend=\"G-SIGNAL-NO-HOOKS:CAPS\"><literal>No Hooks</literal></link>";
              }
            }

            if ($flags_string)
              {
                $synop .= ": $flags_string\n";

                $pad = ' ' x (5 + $name_len - length("user_data"));
                $desc  .= "$pad : $flags_string</programlisting>\n";
              }
            else
              {
                $synop .= "\n";
                $desc  .= "</programlisting>\n";
              }

            $desc .= &MakeDeprecationNote($symbol);

            my $parameters = &OutputParamDescriptions ("SIGNAL", $symbol);
            my $parameters_output = 0;

            $AllSymbols{$symbol} = 1;
            if (defined ($SymbolDocs{$symbol})) {
                my $symbol_docs = &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});

                # Try to insert the parameter table at the author's desired
                # position. Otherwise we need to tag it onto the end.
                if ($symbol_docs =~ s/<!--PARAMETERS-->/$parameters/) {
                  $parameters_output = 1;
                }
                $desc .= $symbol_docs;

                if (!IsEmptyDoc($SymbolDocs{$symbol})) {
                    $AllDocumentedSymbols{$symbol} = 1;
                }
            }

            if ($parameters_output == 0) {
                $desc .= $parameters;
              }
            $desc .= OutputSymbolTraits ($symbol);
            $desc .= "</refsect2>";
        }
    }
    return ($synop, $desc);
}


#############################################################################
# Function    : GetArgs
# Description : Returns the synopsis and detailed description DocBook output
#                for the Args of a given GtkObject subclass.
# Arguments   : $object - the GtkObject subclass, e.g. 'GtkButton'.
#############################################################################

sub GetArgs {
    my ($object) = @_;
    my $synop = "";
    my $desc = "";
    my $child_synop = "";
    my $child_desc = "";
    my $style_synop = "";
    my $style_desc = "";

    my $i;
    for ($i = 0; $i <= $#ArgObjects; $i++) {
        if ($ArgObjects[$i] eq $object) {
            #print "Found arg: $ArgNames[$i]\n";
            my $name = $ArgNames[$i];
            my $flags = $ArgFlags[$i];
            my $flags_string = "";
            my $kind = "";
            my $id_sep = "";

            if ($flags =~ m/c/) {
                $kind = "child property";
                $id_sep = "c-";
            }
            elsif ($flags =~ m/s/) {
                $kind = "style property";
                $id_sep = "s-";
            }
            else {
                $kind = "property";
            }

            # Remember only one colon so we don't clash with signals.
            my $symbol = "${object}:${name}";
            # use two dashes and ev. an extra separator here for the same reason.
            my $id = &CreateValidSGMLID ("$object--$id_sep$name");

            my $type = $ArgTypes[$i];
            my $type_output;
            my $range = $ArgRanges[$i];
            my $range_output = CreateValidSGML ($range);
            my $default = $ArgDefaults[$i];
            my $default_output = CreateValidSGML ($default);

            if ($type eq "GtkString") {
                $type = "char*";
            }
            if ($type eq "GtkSignal") {
                $type = "GtkSignalFunc, gpointer";
                $type_output = &MakeXRef ("GtkSignalFunc") . ", "
                    . &MakeXRef ("gpointer");
            } elsif ($type =~ m/^(\w+)\*$/) {
                $type_output = &MakeXRef ($1, &tagify($1, "type")) . "*";
            } else {
                $type_output = &MakeXRef ($type, &tagify($type, "type"));
            }

            if ($flags =~ m/r/) {
                $flags_string = "Read";
            }
            if ($flags =~ m/w/) {
                if ($flags_string) { $flags_string .= " / "; }
                $flags_string .= "Write";
            }
            if ($flags =~ m/x/) {
                if ($flags_string) { $flags_string .= " / "; }
                $flags_string .= "Construct";
            }
            if ($flags =~ m/X/) {
                if ($flags_string) { $flags_string .= " / "; }
                $flags_string .= "Construct Only";
            }

            $AllSymbols{$symbol} = 1;
            my $blurb;
            if (defined($SymbolDocs{$symbol}) &&
                !IsEmptyDoc($SymbolDocs{$symbol})) {
                $blurb = &ExpandAbbreviations($symbol, $SymbolDocs{$symbol});
                #print ".. [$SymbolDocs{$symbol}][$blurb]\n";
                $AllDocumentedSymbols{$symbol} = 1;
            }
            else {
                if (!($ArgBlurbs[$i] eq "")) {
                    $AllDocumentedSymbols{$symbol} = 1;
                } else {
                    # FIXME: print a warning?
                    #print ".. no description\n";
                }
                $blurb = "<para>" . &CreateValidSGML ($ArgBlurbs[$i]) . "</para>";
            }

            my $pad1 = " " x (24 - length ($name));
            my $pad2 = " " x (20 - length ($type));

             my $arg_synop = "  &quot;<link linkend=\"$id\">$name</link>&quot;$pad1 $type_output $pad2 : $flags_string\n";
            my $arg_desc = "<refsect2 id=\"$id\" role=\"property\"><title>The <literal>&quot;$name&quot;</literal> $kind</title>\n";
            $arg_desc .= MakeIndexterms($symbol, $id);
            $arg_desc .= "\n";
            $arg_desc .= OutputSymbolExtraLinks($symbol);

            $arg_desc .= "<programlisting>  &quot;$name&quot;$pad1 $type_output $pad2 : $flags_string</programlisting>\n";
            $arg_desc .= &MakeDeprecationNote($symbol);
            $arg_desc .= $blurb;
            if ($range ne "") {
                $arg_desc .= "<para>Allowed values: $range_output</para>\n";
            }
            if ($default ne "") {
                $arg_desc .= "<para>Default value: $default_output</para>\n";
            }
            $arg_desc .= OutputSymbolTraits ($symbol);
            $arg_desc .= "</refsect2>\n";

            if ($flags =~ m/c/) {
                $child_synop .= $arg_synop;
                $child_desc .= $arg_desc;
            }
            elsif ($flags =~ m/s/) {
                $style_synop .= $arg_synop;
                $style_desc .= $arg_desc;
            }
            else {
                $synop .= $arg_synop;
                $desc .= $arg_desc;
            }
        }
    }
    return ($synop, $child_synop, $style_synop, $desc, $child_desc, $style_desc);
}


#############################################################################
# Function    : ReadSourceDocumentation
# Description : This reads in the documentation embedded in comment blocks
#                in the source code (for Gnome).
#
#                Parameter descriptions override any in the template files.
#                Function descriptions are placed before any description from
#                the template files.
#
#                It recursively descends the source directory looking for .c
#                files and scans them looking for specially-formatted comment
#                blocks.
#
# Arguments   : $source_dir - the directory to scan.
#############m###############################################################

sub ReadSourceDocumentation {
    my ($source_dir) = @_;
    my ($file, $dir, @suffix_list, $suffix);

    # prepend entries from @SOURCE_DIR
    for my $dir (@SOURCE_DIRS) {
        # Check if the filename is in the ignore list.
        if ($source_dir =~ m%^\Q$dir\E/(.*)$% and $IGNORE_FILES =~ m/(\s|^)\Q$1\E(\s|$)/) {
            #("Skipping source directory: $source_dir");
            return;
        }
    }

    #("Scanning source directory: $source_dir");

    # This array holds any subdirectories found.
    my (@subdirs) = ();

    @suffix_list = split (/,/, $SOURCE_SUFFIXES);

    opendir (SRCDIR, $source_dir)
        || die "Can't open source directory $source_dir: $!";

    foreach $file (readdir (SRCDIR)) {
      if ($file =~ /^\./) {
        next;
      } elsif (-d "$source_dir/$file") {
        push (@subdirs, $file);
      } elsif (@suffix_list) {
        foreach $suffix (@suffix_list) {
          if ($file =~ m/\.\Q${suffix}\E$/) {
            &ScanSourceFile ("$source_dir/$file");
          }
        }
      } elsif ($file =~ m/\.[ch]$/) {
        &ScanSourceFile ("$source_dir/$file");
      }
    }
    closedir (SRCDIR);

    # Now recursively scan the subdirectories.
    foreach $dir (@subdirs) {
        &ReadSourceDocumentation ("$source_dir/$dir");
    }
}


#############################################################################
# Function    : ScanSourceFile
# Description : Scans one source file looking for specially-formatted comment
#                blocks. Later &MergeSourceDocumentation is used to merge any
#                documentation found with the documentation already read in
#                from the template files.
#
# Arguments   : $file - the file to scan.
#############################################################################

sub ScanSourceFile {
    my ($file) = @_;
    my $basename;

    # prepend entries from @SOURCE_DIR
    for my $dir (@SOURCE_DIRS) {
        # Check if the filename is in the ignore list.
        if ($file =~ m%^\Q$dir\E/(.*)$% and $IGNORE_FILES =~ m/(\s|^)\Q$1\E(\s|$)/) {
            #("Skipping source file: $file");
            return;
        }
    }

    if ($file =~ m/^.*[\/\\]([^\/\\]*)$/) {
        $basename = $1;
    } else {
        &LogWarning ($file, 1, "Can't find basename for this filename.");
        $basename = $file;
    }

    # Check if the basename is in the list of files to ignore.
    if ($IGNORE_FILES =~ m/(\s|^)\Q${basename}\E(\s|$)/) {
        #("Skipping source file: $file");
        return;
    }

    #("Scanning source file: $file");

    open (SRCFILE, $file)
        || die "Can't open $file: $!";
    my $in_comment_block = 0;
    my $symbol;
    my ($in_description, $in_return, $in_since, $in_stability, $in_deprecated);
    my ($description, $return_desc, $return_start, $return_style);
    my ($since_desc, $stability_desc, $deprecated_desc);
    my $current_param;
    my $ignore_broken_returns;
    my @params;
    while (<SRCFILE>) {
        # Look for the start of a comment block.
        if (!$in_comment_block) {
            if (m%^\s*/\*.*\*/%) {
                #one-line comment - not gtkdoc
            } elsif (m%^\s*/\*\*\s%) {
                #print "Found comment block start\n";

                $in_comment_block = 1;

                # Reset all the symbol data.
                $symbol = "";
                $in_description = 0;
                $in_return = 0;
                $in_since = 0;
                $in_deprecated = 0;
                $in_stability = 0;
                $description = "";
                $return_desc = "";
                $return_style = "";
                $since_desc = "";
                $deprecated_desc = "";
                $stability_desc = "";
                $current_param = -1;
                $ignore_broken_returns = 0;
                @params = ();
            }
            next;
        }

        # We're in a comment block. Check if we've found the end of it.
        if (m%^\s*\*+/%) {
            if (!$symbol) {
                # maybe its not even meant to be a gtk-doc comment?
                &LogWarning ($file, $., "Symbol name not found at the start of the comment block.");
            } else {
                # Add the return value description onto the end of the params.
                if ($return_desc) {
                    push (@params, "Returns");
                    push (@params, $return_desc);
                    if ($return_style eq 'broken') {
                        &LogWarning ($file, $., "Free-form return value description in $symbol. Use `Returns:' to avoid ambiguities.");
                    }
                }
                # Convert special SGML characters
                $description = &ConvertSGMLChars ($symbol, $description);
                my $k;
                for ($k = 1; $k <= $#params; $k += $PARAM_FIELD_COUNT) {
                    $params[$k] = &ConvertSGMLChars ($symbol, $params[$k]);
                }

                # Handle Section docs
                if ($symbol =~ m/SECTION:\s*(.*)/) {
                    my $real_symbol=$1;
                    my $key;

                    if (scalar %KnownSymbols) {
                        if ((! defined($KnownSymbols{"$TMPL_DIR/$real_symbol:Long_Description"})) || $KnownSymbols{"$TMPL_DIR/$real_symbol:Long_Description"} != 1) {
                            &LogWarning ($file, $., "Section $real_symbol is not defined in the $MODULE-section.txt file.");
                        }
                    }

                    #print "SECTION DOCS found in source for : '$real_symbol'\n";
                    $ignore_broken_returns = 1;
                    for ($k = 0; $k <= $#params; $k += $PARAM_FIELD_COUNT) {
                        #print "   '".$params[$k]."'\n";
                        $params[$k] = "\L$params[$k]";
                        undef $key;
                        if ($params[$k] eq "short_description") {
                            $key = "$TMPL_DIR/$real_symbol:Short_Description";
                        } elsif ($params[$k] eq "see_also") {
                            $key = "$TMPL_DIR/$real_symbol:See_Also";
                        } elsif ($params[$k] eq "title") {
                            $key = "$TMPL_DIR/$real_symbol:Title";
                        } elsif ($params[$k] eq "stability") {
                            $key = "$TMPL_DIR/$real_symbol:Stability_Level";
                        } elsif ($params[$k] eq "section_id") {
                            $key = "$TMPL_DIR/$real_symbol:Section_Id";
                        } elsif ($params[$k] eq "include") {
                            $key = "$TMPL_DIR/$real_symbol:Include";
                        } elsif ($params[$k] eq "image") {
                            $key = "$TMPL_DIR/$real_symbol:Image";
                        }
                        if (defined($key)) {
                            $SourceSymbolDocs{$key}=$params[$k+1];
                            $SourceSymbolSourceFile{$key} = $file;
                            $SourceSymbolSourceLine{$key} = $.;
                        }
                    }
                    $SourceSymbolDocs{"$TMPL_DIR/$real_symbol:Long_Description"}=$description;
                    $SourceSymbolSourceFile{"$TMPL_DIR/$real_symbol:Long_Description"} = $file;
                    $SourceSymbolSourceLine{"$TMPL_DIR/$real_symbol:Long_Description"} = $.;
                    #$SourceSymbolTypes{$symbol} = "SECTION";
                } else {
                    #print "SYMBOL DOCS found in source for : '$symbol' ",length($description), "\n";
                    $SourceSymbolDocs{$symbol} = $description;
                    $SourceSymbolParams{$symbol} = [ @params ];
                    # FIXME $SourceSymbolTypes{$symbol} = "STRUCT,SIGNAL,ARG,FUNCTION,MACRO";
                    #if (defined $DeclarationTypes{$symbol}) {
                    #    $SourceSymbolTypes{$symbol} = $DeclarationTypes{$symbol}
                    #}
                    $SourceSymbolSourceFile{$symbol} = $file;
                    $SourceSymbolSourceLine{$symbol} = $.;
                }

                if ($since_desc) {
                     ($since_desc, my @extra_lines) = split ("\n", $since_desc);
                     $since_desc =~ s/^\s+//;
                     $since_desc =~ s/\s+$//;
                     #print "Since($symbol) : [$since_desc]\n";
                     $Since{$symbol} = &ConvertSGMLChars ($symbol, $since_desc);
                     if(scalar @extra_lines) {
                         &LogWarning ($file, $., "multi-line since docs found");
                     }
                }

                if ($stability_desc) {
                    $stability_desc = &ParseStabilityLevel($stability_desc, $file, $., "Stability level for $symbol");
                    $StabilityLevel{$symbol} = &ConvertSGMLChars ($symbol, $stability_desc);
                }

                if ($deprecated_desc) {
                    if (exists $Deprecated{$symbol}) {
                    }
                    else {
                         # don't warn for signals and properties
                         #if ($symbol !~ m/::?(.*)/) {
                         if (defined $DeclarationTypes{$symbol}) {
                             &LogWarning ($file, $.,
                                 "$symbol is deprecated in the inline comments, but no deprecation guards were found around the declaration.".
                                 " (See the --deprecated-guards option for gtkdoc-scan.)");
                         }
                    }
                    $Deprecated{$symbol} = &ConvertSGMLChars ($symbol, $deprecated_desc);
                }
            }

            $in_comment_block = 0;
            next;
        }

        # Get rid of ' * ' at start of every line in the comment block.
        s%^\s*\*\s?%%;
        # But make sure we don't get rid of the newline at the end.
        if (!$_) {
            $_ = "\n";
        }
        #print "DEBUG: scanning :$_";

        # If we haven't found the symbol name yet, look for it.
        if (!$symbol) {
            if (m%^\s*(SECTION:\s*\S+)%) {
                $symbol = $1;
                #print "SECTION DOCS found in source for : '$symbol'\n";
                $ignore_broken_returns = 1;
            } elsif (m%^\s*([\w:-]*\w)\s*:?\s*(\([a-z ]+\)\s*)*$%) {
                $symbol = $1;
                #print "SYMBOL DOCS found in source for : '$symbol'\n";
            }
            next;
        }

        # FIXME: flip this around
        # instead of repeating the other parts, just have them once and
        # do if(!$in_return) { ... }
        # also maybe have in_part="description,return,since,deprecated,stability,..."

        # If we're in the return value description, add it to the end.
        if ($in_return) {
            # If we find another valid returns line, we assume that the first
            # one was really part of the description.
            if (m/^\s*(returns:|return\s+value:)/i) {
                if ($return_style eq 'broken') {
                    $description .= $return_start . $return_desc;
                }
                $return_start = $1;
                if ($return_style eq 'sane') {
                    &LogWarning ($file, $., "Multiple Returns for $symbol.");
                }
                $return_style = 'sane';
                $ignore_broken_returns = 1;
                $return_desc = $';
            } elsif (!$ignore_broken_returns && m/^\s*(returns\b\s*)/i) {
                $description .= $return_start . $return_desc;
                $return_start = $1;
                $return_style = 'broken';
                $return_desc = $';
            } elsif (m%^\s*since:%i) {
                $since_desc = $';
                $in_since = 1;
                $in_return = 0;
            } elsif (m%^\s*stability:%i) {
                $stability_desc = $';
                $in_stability = 1;
                $in_return = 0;
            } elsif (m%^\s*deprecated:%i) {
                $deprecated_desc = $';
                $in_deprecated = 1;
                $in_return = 0;
            } else {
                $return_desc .= $_;
            }
            next;
        }

        if ($in_since) {
            if (m/^\s*(returns:|return\s+value:)/i) {
                if ($return_style eq 'broken') {
                    $description .= $return_start . $return_desc;
                }
                $return_start = $1;
                if ($return_style eq 'sane') {
                    &LogWarning ($file, $., "Multiple Returns for $symbol.");
                }
                $return_style = 'sane';
                $ignore_broken_returns = 1;
                $return_desc = $';
                $in_return = 1;
                $in_since = 0;
            } elsif (!$ignore_broken_returns && m/^\s*(returns\b\s*)/i) {
                $return_start = $1;
                $return_style = 'broken';
                $return_desc = $';
                $in_return = 1;
                $in_since = 0;
            } elsif (m%^\s*deprecated:%i) {
                $deprecated_desc = $';
                $in_deprecated = 1;
                $in_since = 0;
            } elsif (m%^\s*stability:%i) {
                $stability_desc = $';
                $in_stability = 1;
                $in_since = 0;
            } else {
                $since_desc .= $_;
            }
            next;
        }

        if ($in_stability) {
            if (m/^\s*(returns:|return\s+value:)/i) {
                if ($return_style eq 'broken') {
                    $description .= $return_start . $return_desc;
                }
                $return_start = $1;
                if ($return_style eq 'sane') {
                    &LogWarning ($file, $., "Multiple Returns for $symbol.");
                }
                $return_style = 'sane';
                $ignore_broken_returns = 1;
                $return_desc = $';
                $in_return = 1;
                $in_stability = 0;
            } elsif (!$ignore_broken_returns && m/^\s*(returns\b\s*)/i) {
                $return_start = $1;
                $return_style = 'broken';
                $return_desc = $';
                $in_return = 1;
                $in_stability = 0;
            } elsif (m%^\s*deprecated:%i) {
                $deprecated_desc = $';
                $in_deprecated = 1;
                $in_stability = 0;
            } elsif (m%^\s*since:%i) {
                $since_desc = $';
                $in_since = 1;
                $in_stability = 0;
            } else {
                $stability_desc .= $_;
            }
            next;
        }

        if ($in_deprecated) {
            if (m/^\s*(returns:|return\s+value:)/i) {
                if ($return_style eq 'broken') {
                    $description .= $return_start . $return_desc;
                }
                $return_start = $1;
                if ($return_style eq 'sane') {
                    &LogWarning ($file, $., "Multiple Returns for $symbol.");
                }
                $return_style = 'sane';
                $ignore_broken_returns = 1;
                $return_desc = $';
                $in_return = 1;
                $in_deprecated = 0;
            } elsif (!$ignore_broken_returns && m/^\s*(returns\b\s*)/i) {
                $return_start = $1;
                $return_style = 'broken';
                $return_desc = $';
                $in_return = 1;
                $in_deprecated = 0;
            } elsif (m%^\s*since:%i) {
                $since_desc = $';
                $in_since = 1;
                $in_deprecated = 0;
            } elsif (m%^\s*stability:%i) {
                $stability_desc = $';
                $in_stability = 1;
                $in_deprecated = 0;
            } else {
                $deprecated_desc .= $_;
            }
            next;
        }

        # If we're in the description part, check for the 'Returns:' line.
        # If that isn't found, add the text to the end.
        if ($in_description) {
            # Get rid of 'Description:'
            s%^\s*Description:%%;

            if (m/^\s*(returns:|return\s+value:)/i) {
                if ($return_style eq 'broken') {
                    $description .= $return_start . $return_desc;
                }
                $return_start = $1;
                if ($return_style eq 'sane') {
                    &LogWarning ($file, $., "Multiple Returns for $symbol.");
                }
                $return_style = 'sane';
                $ignore_broken_returns = 1;
                $return_desc = $';
                $in_return = 1;
                next;
            } elsif (!$ignore_broken_returns && m/^\s*(returns\b\s*)/i) {
                $return_start = $1;
                $return_style = 'broken';
                $return_desc = $';
                $in_return = 1;
                next;
            } elsif (m%^\s*since:%i) {
                $since_desc = $';
                $in_since = 1;
                next;
            } elsif (m%^\s*deprecated:%i) {
                $deprecated_desc = $';
                $in_deprecated = 1;
                next;
            } elsif (m%^\s*stability:%i) {
                $stability_desc = $';
                $in_stability = 1;
                next;
            }

            $description .= $_;
            next;
        }

        # We must be in the parameters. Check for the empty line below them.
        if (m%^\s*$%) {
            $in_description = 1;
            next;
        }

        # Look for a parameter name.
        if (m%^\s*@(\S+)\s*:\s*%) {
            my $param_name = $1;
            my $param_desc = $';

            #print "Found parameter: $param_name\n";
            # Allow varargs variations
            if ($param_name =~ m/^.*\.\.\.$/) {
                $param_name = "...";
            }
            if ("\L$param_name" eq "returns") {
                $return_style = 'sane';
                $ignore_broken_returns = 1;
            }
            #("Found param for symbol $symbol : '$param_name'= '$_'");

            push (@params, $param_name);
            push (@params, $param_desc);
            $current_param += $PARAM_FIELD_COUNT;
            next;
        }

        # We must be in the middle of a parameter description, so add it on
        # to the last element in @params.
        if ($current_param == -1) {
            &LogWarning ($file, $., "Parsing comment block file : parameter expected.");
        } else {
            $params[$#params] .= $_;
        }
    }
    close (SRCFILE);
}

#############################################################################
# Function    : OutputMissingDocumentation
# Description : Outputs report of documentation coverage to a file
#
# Arguments   : none
#############################################################################

sub OutputMissingDocumentation {
    my $old_undocumented_file = "$ROOT_DIR/$MODULE-undocumented.txt";
    my $new_undocumented_file = "$ROOT_DIR/$MODULE-undocumented.new";

    my $n_documented = 0;
    my $n_incomplete = 0;
    my $total = 0;
    my $symbol;
    my $percent;
    my $msg;
    my $buffer = "";
    my $buffer_deprecated = "";
    my $buffer_descriptions = "";

    open(UNDOCUMENTED, ">$new_undocumented_file")
      || die "Can't create $new_undocumented_file";

    foreach $symbol (sort (keys (%AllSymbols))) {
        # FIXME: should we print LogWarnings for undocumented stuff?
        # DEBUG
        #my $ssfile = &GetSymbolSourceFile($symbol);
        #my $ssline = &GetSymbolSourceLine($symbol);
        #my $location = "defined at " . (defined($ssfile)?$ssfile:"?") . ":" . (defined($ssline)?$ssline:"0") . "\n";
        # DEBUG
        if ($symbol !~ /:(Title|Long_Description|Short_Description|See_Also|Stability_Level|Include|Section_Id|Image)/) {
            $total++;
            if (exists ($AllDocumentedSymbols{$symbol})) {
                $n_documented++;
                if (exists ($AllIncompleteSymbols{$symbol})) {
                    $n_incomplete++;
                    $buffer .= $symbol . " (" . $AllIncompleteSymbols{$symbol} . ")\n";
                    #$buffer .= "\t0: ".$location;
                }
            } elsif (exists $Deprecated{$symbol}) {
                if (exists ($AllIncompleteSymbols{$symbol})) {
                    $n_incomplete++;
                    $buffer_deprecated .= $symbol . " (" . $AllIncompleteSymbols{$symbol} . ")\n";
                    #$buffer .= "\t1a: ".$location;
                } else {
                    $buffer_deprecated .= $symbol . "\n";
                    #$buffer .= "\t1b: ".$location;
                }
            } else {
                if (exists ($AllIncompleteSymbols{$symbol})) {
                    $n_incomplete++;
                    $buffer .= $symbol . " (" . $AllIncompleteSymbols{$symbol} . ")\n";
                    #$buffer .= "\t2a: ".$location;
                } else {
                    $buffer .= $symbol . "\n";
                    #$buffer .= "\t2b: ".$location;
                }
            }
        } elsif ($symbol =~ /:(Long_Description|Short_Description)/) {
            $total++;
            #my $len1=(exists($SymbolDocs{$symbol}))?length($SymbolDocs{$symbol}):-1;
            #my $len2=(exists($AllDocumentedSymbols{$symbol}))?length($AllDocumentedSymbols{$symbol}):-1;
            #print "%%%% $symbol : $len1,$len2\n";
            if (((exists ($SymbolDocs{$symbol})) && (length ($SymbolDocs{$symbol}) > 0))
            || ((exists ($AllDocumentedSymbols{$symbol})) && (length ($AllDocumentedSymbols{$symbol}) > 0))) {
              $n_documented++;
            } else {
              # cut off the leading namespace ($TMPL_DIR)
              $symbol =~ m/^.*\/(.*)$/;
              $buffer_descriptions .= $1 . "\n";
            }
        }
    }

    $buffer .= "\n" . $buffer_deprecated . "\n" . $buffer_descriptions;

    if ($total == 0) {
      $percent = 100;
    } else {
      $percent = ($n_documented / $total) * 100.0;
    }

    printf UNDOCUMENTED "%.0f%% symbol docs coverage.\n", $percent;
    print UNDOCUMENTED "$n_documented symbols documented.\n";
    print UNDOCUMENTED "$n_incomplete symbols incomplete.\n";
    print UNDOCUMENTED ($total - $n_documented) . " not documented.\n\n\n";

    print UNDOCUMENTED $buffer;
    close (UNDOCUMENTED);

    return &UpdateFileIfChanged ($old_undocumented_file, $new_undocumented_file, 0);

    printf "%.0f%% symbol docs coverage", $percent;
    print "($n_documented symbols documented, $n_incomplete symbols incomplete, " . ($total - $n_documented) . " not documented)\n";
    print "See $MODULE-undocumented.txt for a list of missing docs.\nThe doc coverage percentage doesn't include intro sections.\n";
}


#############################################################################
# Function    : OutputUndeclaredSymbols
# Description : Outputs symbols that are listed in the section file, but not
#               declaration is found in the sources
#
# Arguments   : none
#############################################################################

sub OutputUndeclaredSymbols {
    my $old_undeclared_file = "$ROOT_DIR/$MODULE-undeclared.txt";
    my $new_undeclared_file = "$ROOT_DIR/$MODULE-undeclared.new";

    open(UNDECLARED, ">$new_undeclared_file")
        || die "Can't create $new_undeclared_file";

    if (%UndeclaredSymbols) {
        print UNDECLARED (join("\n", sort keys %UndeclaredSymbols));
        print UNDECLARED "\n";
        print "See $MODULE-undeclared.txt for the list of undeclared symbols.\n"
    }
    close(UNDECLARED);

    return &UpdateFileIfChanged ($old_undeclared_file, $new_undeclared_file, 0);
}

#############################################################################
# Function    : OutputUnusedSymbols
# Description : Outputs symbols that are documented in comments, but not
#               declared in the sources
#
# Arguments   : none
#############################################################################

sub OutputUnusedSymbols {
    my $num_unused = 0;
    my $old_unused_file = "$ROOT_DIR/$MODULE-unused.txt";
    my $new_unused_file = "$ROOT_DIR/$MODULE-unused.new";

    open (UNUSED, ">$new_unused_file")
        || die "Can't open $new_unused_file";
    my ($symbol);
    foreach $symbol (sort keys (%Declarations)) {
        if (!defined ($DeclarationOutput{$symbol})) {
            print (UNUSED "$symbol\n");
            $num_unused++;
        }
    }
    foreach $symbol (sort (keys (%AllUnusedSymbols))) {
        print (UNUSED "$symbol(" . $AllUnusedSymbols{$symbol} . ")\n");
        $num_unused++;
    }
    close (UNUSED);
    if ($num_unused != 0) {
        &LogWarning ($old_unused_file, 1, "$num_unused unused declarations.".
            "They should be added to $MODULE-sections.txt in the appropriate place.");
    }

    return &UpdateFileIfChanged ($old_unused_file, $new_unused_file, 0);
}


#############################################################################
# Function    : OutputAllSymbols
# Description : Outputs list of all symbols to a file
#
# Arguments   : none
#############################################################################

sub OutputAllSymbols {
     my $n_documented = 0;
     my $total = 0;
     my $symbol;
     my $percent;
     my $msg;

     open (SYMBOLS, ">$ROOT_DIR/$MODULE-symbols.txt")
          || die "Can't create $ROOT_DIR/$MODULE-symbols.txt: $!";

     foreach $symbol (sort (keys (%AllSymbols))) {
          print SYMBOLS $symbol . "\n";
     }

     close (SYMBOLS);
}

#############################################################################
# Function    : OutputSymbolsWithoutSince
# Description : Outputs list of all symbols without a since tag to a file
#
# Arguments   : none
#############################################################################

sub OutputSymbolsWithoutSince {
     my $n_documented = 0;
     my $total = 0;
     my $symbol;
     my $percent;
     my $msg;

     open (SYMBOLS, ">$ROOT_DIR/$MODULE-nosince.txt")
          || die "Can't create $ROOT_DIR/$MODULE-nosince.txt: $!";

     foreach $symbol (sort (keys (%SourceSymbolDocs))) {
         if (!defined $Since{$symbol}) {
             print SYMBOLS $symbol . "\n";
         }
     }

     close (SYMBOLS);
}


#############################################################################
# Function    : MergeSourceDocumentation
# Description : This merges documentation read from a source file into the
#                documentation read in from a template file.
#
#                Parameter descriptions override any in the template files.
#                Function descriptions are placed before any description from
#                the template files.
#
# Arguments   : none
#############################################################################

sub MergeSourceDocumentation {
    my $symbol;
    my @Symbols;

    if (scalar %SymbolDocs) {
        @Symbols=keys (%SymbolDocs);
        #print "num existing entries: ".(scalar @Symbols)."\n";
        #print "  ",$Symbols[0], " ",$Symbols[1],"\n";
    }
    else {
        # filter scanned declarations, with what we suppress from -sections.txt
        my %tmp = ();
        foreach $symbol (keys (%Declarations)) {
            if (defined($KnownSymbols{$symbol}) && $KnownSymbols{$symbol} == 1) {
                $tmp{$symbol}=1;
            }
        }
        # , add the rest from -sections.txt
        foreach $symbol (keys (%KnownSymbols)) {
            if ($KnownSymbols{$symbol} == 1) {
                $tmp{$symbol}=1;
            }
        }
        # and add whats found in the source
        foreach $symbol (keys (%SourceSymbolDocs)) {
            $tmp{$symbol}=1;
        }
        @Symbols = keys (%tmp);
        #print "num source entries: ".(scalar @Symbols)."\n";
    }
    foreach $symbol (@Symbols) {
        $AllSymbols{$symbol} = 1;

        my $have_tmpl_docs = 0;

        ## see if the symbol is documented in template
        my $tmpl_doc = defined ($SymbolDocs{$symbol}) ? $SymbolDocs{$symbol} : "";
        my $check_tmpl_doc =$tmpl_doc;
        # remove all xml-tags and whitespaces
        $check_tmpl_doc =~ s/<.*?>//g;
        $check_tmpl_doc =~ s/\s//g;
        # anything left ?
        if ($check_tmpl_doc ne "") {
            $have_tmpl_docs = 1;
            #print "## [$check_tmpl_doc]\n";
        } else {
            # if the docs have just an empty para, don't merge that.
            $check_tmpl_doc = $tmpl_doc;
            $check_tmpl_doc =~ s/(\s|\n)//msg;
            if ($check_tmpl_doc eq "<para></para>") {
               $tmpl_doc = "";
            }
        }

        if (exists ($SourceSymbolDocs{$symbol})) {
            my $type = $DeclarationTypes {$symbol};

            #print "merging [$symbol] from source\n";

            my $item = "Parameter";
            if (defined ($type)) {
                if ($type eq 'STRUCT') {
                    $item = "Field";
                } elsif ($type eq 'ENUM') {
                    $item = "Value";
                } elsif ($type eq 'UNION') {
                    $item = "Field";
                }
            } else {
                $type="SIGNAL";
            }

            my $src_doc = $SourceSymbolDocs{$symbol};
            # remove leading and training whitespaces
            $src_doc =~ s/^\s+//;
            $src_doc =~ s/\s+$//;

            # Don't output warnings for overridden titles as titles are
            # automatically generated in the -sections.txt file, and thus they
            # are often overridden.
            if ($have_tmpl_docs && $symbol !~ m/:Title$/) {
                # check if content is different
                if ($tmpl_doc ne $src_doc) {
                    #print "[$tmpl_doc] [$src_doc]\n";
                    &LogWarning ($SourceSymbolSourceFile{$symbol}, $SourceSymbolSourceLine{$symbol},
                        "Documentation in template ".$SymbolSourceFile{$symbol}.":".$SymbolSourceLine{$symbol}." for $symbol being overridden by inline comments.");
                }
            }

            if ($src_doc ne "") {
                 $AllDocumentedSymbols{$symbol} = 1;
            }

            # Convert <!--PARAMETERS--> with any blank lines around it to
            # a </para> followed by <!--PARAMETERS--> followed by <para>.
            $src_doc =~ s%\n+\s*<!--PARAMETERS-->\s*\n+%\n</para>\n<!--PARAMETERS-->\n<para>\n%g;

            # Do not add <para> to nothing, it breaks missing docs checks.
            my $src_doc_para = "";
            if ($src_doc ne "") {
                # Expand markdown (and do paragraphs)
                $src_doc_para = &ConvertMarkDown ($src_doc, $symbol);
                ## fixup xml markup
                # FIXME: this is questionable, as we can't make assumtions on the content really
                #$src_doc_para =~ s%^<para>\n(<refsect[1-9])%$1%gms;
                #$src_doc_para =~ s%^<para>\n<para>%<para>%gms;
                #$src_doc_para =~ s%(</refsect[1-9]>)\n</para>$%$1%gms;
                #print "$symbol : [$src_doc][$src_doc_para]\n";
            }

            if ($symbol =~ m/$TMPL_DIR\/.+:Long_Description/) {
                $SymbolDocs{$symbol} = "$src_doc_para$tmpl_doc";
            } elsif ($symbol =~ m/$TMPL_DIR\/.+:.+/) {
                # For the title/summary/see also section docs we don't want to
                # add any <para> tags.
                $SymbolDocs{$symbol} = "$src_doc"
            } else {
                $SymbolDocs{$symbol} = "$src_doc_para$tmpl_doc";
            }

            # merge parameters
            if ($symbol =~ m/.*::.*/) {
                # For signals we prefer the param names from the source docs,
                # since the ones from the templates are likely to contain the
                # artificial argn names which are generated by gtkdoc-scangobj.
                $SymbolParams{$symbol} = $SourceSymbolParams{$symbol};
                # FIXME: we need to check for empty docs here as well!
            } else {
                # The templates contain the definitive parameter names and order,
                # so we will not change that. We only override the actual text.
                my $tmpl_params = $SymbolParams{$symbol};
                if (!defined ($tmpl_params)) {
                    #print "No merge needed for $symbol\n";
                    $SymbolParams{$symbol} = $SourceSymbolParams{$symbol};
                    #  FIXME: we still like to get the number of params and merge
                    #  1) we would noticed that params have been removed/renamed
                    #  2) we would catch undocumented params
                    #  params are not (yet) exported in -decl.txt so that we
                    #  could easily grab them :/
                } else {
                    my $params = $SourceSymbolParams{$symbol};
                    my $j;
                    #print "Merge needed for $symbol, tmpl_params: ",$#$tmpl_params,", source_params: ",$#$params," \n";
                    for ($j = 0; $j <= $#$tmpl_params; $j += $PARAM_FIELD_COUNT) {
                        my $tmpl_param_name = $$tmpl_params[$j];

                        # Try to find the param in the source comment documentation.
                        my $found = 0;
                        my $k;
                        #print "  try merge param $tmpl_param_name\n";
                        for ($k = 0; $k <= $#$params; $k += $PARAM_FIELD_COUNT) {
                            my $param_name = $$params[$k];
                            my $param_desc = $$params[$k + 1];

                            #print "    test param  $param_name\n";
                            # We accept changes in case, since the Gnome source
                            # docs contain a lot of these.
                            if ("\L$param_name" eq "\L$tmpl_param_name") {
                                $found = 1;

                                # Override the description.
                                $$tmpl_params[$j + 1] = $param_desc;

                                # Set the name to "" to mark it as used.
                                $$params[$k] = "";
                                last;
                            }
                        }

                        # If it looks like the parameters are there, but not
                        # in the right place, try to explain a bit better.
                        if ((!$found) && ($src_doc =~ m/\@$tmpl_param_name:/)) {
                            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                                "Parameters for $symbol must start on the line immediately after the function or macro name.");
                        }
                    }

                    # Now we output a warning if parameters have been described which
                    # do not exist.
                    for ($j = 0; $j <= $#$params; $j += $PARAM_FIELD_COUNT) {
                        my $param_name = $$params[$j];
                        if ($param_name) {
                            # the template builder cannot detect if a macro returns
                            # a result or not
                            if(($type eq "MACRO") && ($param_name eq "Returns")) {
                                # FIXME: do we need to add it then to tmpl_params[] ?
                                my $num=$#$tmpl_params;
                                #print "  adding Returns: to macro docs for $symbol.\n";
                                $$tmpl_params[$num+1]="Returns";
                                $$tmpl_params[$num+2]=$$params[$j+1];
                                next;
                            }
                            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                                "$item described in source code comment block but does not exist. $type: $symbol $item: $param_name.");
                        }
                    }
                }
            }
        } else {
            if ($have_tmpl_docs) {
                $AllDocumentedSymbols{$symbol} = 1;
                #print "merging [$symbol] from template\n";
            }
            else {
                #print "[$symbol] undocumented\n";
            }
        }

        # if this symbol is documented, check if docs are complete
        $check_tmpl_doc = defined ($SymbolDocs{$symbol}) ? $SymbolDocs{$symbol} : "";
        # remove all xml-tags and whitespaces
        $check_tmpl_doc =~ s/<.*?>//g;
        $check_tmpl_doc =~ s/\s//g;
        if ($check_tmpl_doc ne "") {
            my $tmpl_params = $SymbolParams{$symbol};
            if (defined ($tmpl_params)) {
                my $type = $DeclarationTypes {$symbol};

                my $item = "Parameter";
                if (defined ($type)) {
                    if ($type eq 'STRUCT') {
                        $item = "Field";
                    } elsif ($type eq 'ENUM') {
                        $item = "Value";
                    } elsif ($type eq 'UNION') {
                        $item = "Field";
                    }
                } else {
                    $type="SIGNAL";
                }

                #print "Check param docs for $symbol, tmpl_params: ",$#$tmpl_params," entries, type=$type\n";

                if ($#$tmpl_params > 0) {
                    my $j;
                    for ($j = 0; $j <= $#$tmpl_params; $j += $PARAM_FIELD_COUNT) {
                        # Output a warning if the parameter is empty and
                        # remember for stats.
                        my $tmpl_param_name = $$tmpl_params[$j];
                        my $tmpl_param_desc = $$tmpl_params[$j + 1];
                        if ($tmpl_param_name ne "void" && $tmpl_param_desc !~ m/\S/) {
                            if (exists ($AllIncompleteSymbols{$symbol})) {
                                $AllIncompleteSymbols{$symbol}.=", ".$tmpl_param_name;
                            } else {
                                $AllIncompleteSymbols{$symbol}=$tmpl_param_name;
                            }
                            &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                                "$item description for $symbol"."::"."$tmpl_param_name is missing in source code comment block.");
                        }
                    }
                }
                else {
                    if ($#$tmpl_params == 0) {
                        $AllIncompleteSymbols{$symbol}="<items>";
                        &LogWarning (&GetSymbolSourceFile ($symbol), &GetSymbolSourceLine($symbol),
                            "$item descriptions for $symbol are missing in source code comment block.");
                    }
                    # $#$tmpl_params==-1 means we don't know about parameters
                    # this unfortunately does not tell if there should be some
                }
            }
        }
   }
   #print "num doc entries: ".(scalar %SymbolDocs)."\n";
}

#############################################################################
# Function    : IsEmptyDoc
# Description : Check if a doc-string is empty. Its also regarded as empty if
#               it only consist of whitespace or e.g. FIXME.
# Arguments   : the doc-string
#############################################################################
sub IsEmptyDoc {
    my ($doc) = @_;

    if ($doc =~ /^\s*$/) {
        return 1;
    }

    if ($doc =~ /^\s*<para>\s*(FIXME)?\s*<\/para>\s*$/) {
        return 1;
    }

    return 0;
}


#############################################################################
# Function    : ConvertMarkDown
# Description : Converts mark down syntax to the respective docbook, but only
#               outside CDATA and <programlisting> tags.
#               http://de.wikipedia.org/wiki/Markdown
#               Code snippets have been takesn from
#               http://daringfireball.net/projects/markdown/
#                 Copyright (c) 2004 John Gruber
# Arguments   : the doc-string, the symbol name
#############################################################################
my $md_in_refsect2;
sub ConvertMarkDown {
    my ($text, $symbol) = @_;

    # reset state
    $md_in_refsect2=0;

    # convert
    $text = &ModifyXMLElements ($text, $symbol,
                               "<!\\[CDATA\\[|<programlisting[^>]*>|\\|\\[",
                               \&ConvertMarkDownEndTag,
                               \&ConvertMarkDownCallback);
    # encapsulate and terminate
    $text = "<para>\n$text\n</para>";
    if ($md_in_refsect2==1) {
        $text = "$text</refsect2>"
    }
    return $text
}

sub ConvertMarkDownEndTag {
  if ($_[0] eq "<!\[CDATA\[") {
    return "]]>";
  } elsif ($_[0] eq "|[") {
    return "]\\|";
  } else {
    return "</programlisting>";
  }
}

sub ConvertMarkDownCallback {
  my ($text, $symbol, $tag) = @_;

  # If we're not in CDATA or a <programlisting> we convert blank lines so
  # they start a new <para>.
  if ($tag eq "") {
    my $end_of_para="";
    my $end_of_section="";
    my $have_list=0;

    $end_of_para = "$end_of_para</para>";
    $end_of_section = "$end_of_section</para>";
    if ($md_in_refsect2==1) {
        $end_of_section= "$end_of_section</refsect2>";
    }

    # Setext-style headers:
    #          Header 1
    #          ========
    #
    #          Header 2
    #          --------
    #
    if($text =~ s%^\n(.+)[ \t]*\n=+[ \t]*\n\n%$end_of_section<refsect2><title>$1</title><para>\n%gm) {
        $md_in_refsect2=1;
    }

    # atx-style headers:
    #        # Header 1
    #        ## Header 2
    #        ## Header 2 with closing hashes ##
    #        ...
    #        ###### Header 6
    #
    if($text =~ s%^\n\#[ \t]*(.+?)[ \t]*\#\n+%$end_of_section<refsect2><title>$1</title><para>\n%gm) {
        $md_in_refsect2=1;
    }

    # Simple (unnested) lists:
    #   Please select:
    #   - item 1
    #   - item 2 with loooong
    #     description
    #   - item 3
    #
    #   New paragraph.
    $text.="\n"; # we need a new line to avoid too complicated matching rules below
    if ($text =~ s%(?<=\n)-\s+(.+?)(?=(?:\n-\s+)|(?:\n\n)|(?:\n$))%<listitem><para>$1</para></listitem>%gs) {
        $text =~ s%(?<!</listitem>)(\n<listitem>)%\n<itemizedlist>$1%g;
        $text =~ s%(</listitem>\n)(?!<listitem>)%$1</itemizedlist>\n%g;
    }
    chomp $text;

    # Make Paragraphs on blank lines
    $text =~ s%\n{2,}%\n$end_of_para\n<para>\n%g;
  }

  return $text;
}


#############################################################################
# LIBRARY FUNCTIONS -        These functions are used in both gtkdoc-mkdb and
#                        gtkdoc-mktmpl and should eventually be moved to a
#                        separate library.
#############################################################################

#############################################################################
# Function    : ReadDeclarationsFile
# Description : This reads in a file containing the function/macro/enum etc.
#                declarations.
#
#                Note that in some cases there are several declarations with
#                the same name, e.g. for conditional macros. In this case we
#                set a flag in the %DeclarationConditional hash so the
#                declaration is not shown in the docs.
#
#                If a macro and a function have the same name, e.g. for
#                gtk_object_ref, the function declaration takes precedence.
#
#                Some opaque structs are just declared with 'typedef struct
#                _name name;' in which case the declaration may be empty.
#                The structure may have been found later in the header, so
#                that overrides the empty declaration.
#
# Arguments   : $file - the declarations file to read
#                $override - if declarations in this file should override
#                        any current declaration.
#############################################################################

sub ReadDeclarationsFile {
    my ($file, $override) = @_;

    if ($override == 0) {
        %Declarations = ();
        %DeclarationTypes = ();
        %DeclarationConditional = ();
        %DeclarationOutput = ();
    }

    open (INPUT, $file)
        || die "Can't open $file: $!";
    my $declaration_type = "";
    my $declaration_name;
    my $declaration;
    my $is_deprecated = 0;
    while (<INPUT>) {
        if (!$declaration_type) {
            if (m/^<([^>]+)>/) {
                $declaration_type = $1;
                $declaration_name = "";
                #print "Found declaration: $declaration_type\n";
                $declaration = "";
            }
        } else {
            if (m%^<NAME>(.*)</NAME>%) {
                $declaration_name = $1;
            } elsif (m%^<DEPRECATED/>%) {
                $is_deprecated = 1;
            } elsif (m%^</$declaration_type>%) {
                #print "Found end of declaration: $declaration_name\n";
                # Check that the declaration has a name
                if ($declaration_name eq "") {
                    print "ERROR: $declaration_type has no name $file:$.\n";
                }

                # If the declaration is an empty typedef struct _XXX XXX
                # set the flag to indicate the struct has a typedef.
                if ($declaration_type eq 'STRUCT'
                    && $declaration =~ m/^\s*$/) {
                    #print "Struct has typedef: $declaration_name\n";
                    $StructHasTypedef{$declaration_name} = 1;
                }

                # Check if the symbol is already defined.
                if (defined ($Declarations{$declaration_name})
                    && $override == 0) {
                    # Function declarations take precedence.
                    if ($DeclarationTypes{$declaration_name} eq 'FUNCTION') {
                        # Ignore it.
                    } elsif ($declaration_type eq 'FUNCTION') {
                        if ($is_deprecated) {
                            $Deprecated{$declaration_name} = "";
                        }
                        $Declarations{$declaration_name} = $declaration;
                        $DeclarationTypes{$declaration_name} = $declaration_type;
                    } elsif ($DeclarationTypes{$declaration_name}
                              eq $declaration_type) {
                        # If the existing declaration is empty, or is just a
                        # forward declaration of a struct, override it.
                        if ($declaration_type eq 'STRUCT') {
                            if ($Declarations{$declaration_name} =~ m/^\s*(struct\s+\w+\s*;)?\s*$/) {
                                if ($is_deprecated) {
                                    $Deprecated{$declaration_name} = "";
                                }
                                $Declarations{$declaration_name} = $declaration;
                            } elsif ($declaration =~ m/^\s*(struct\s+\w+\s*;)?\s*$/) {
                                # Ignore an empty or forward declaration.
                            } else {
                                &LogWarning ($file, $., "Structure $declaration_name has multiple definitions.");
                            }
                        } else {
                            # set flag in %DeclarationConditional hash for
                            # multiply defined macros/typedefs.
                            $DeclarationConditional{$declaration_name} = 1;
                        }
                    } else {
                        &LogWarning ($file, $., "$declaration_name has multiple definitions.");
                    }
                } else {
                    if ($is_deprecated) {
                        $Deprecated{$declaration_name} = "";
                    }
                    $Declarations{$declaration_name} = $declaration;
                    $DeclarationTypes{$declaration_name} = $declaration_type;
                }

                $declaration_type = "";
                $is_deprecated = 0;
            } else {
                $declaration .= $_;
            }
        }
    }
    close (INPUT);
}


#############################################################################
# Function    : ReadSignalsFile
# Description : This reads in an existing file which contains information on
#                all GTK signals. It creates the arrays @SignalNames and
#                @SignalPrototypes containing info on the signals. The first
#                line of the SignalPrototype is the return type of the signal
#                handler. The remaining lines are the parameters passed to it.
#                The last parameter, "gpointer user_data" is always the same
#                so is not included.
# Arguments   : $file - the file containing the signal handler prototype
#                        information.
#############################################################################

sub ReadSignalsFile {
    my ($file) = @_;

    my $in_signal = 0;
    my $signal_object;
    my $signal_name;
    my $signal_returns;
    my $signal_flags;
    my $signal_prototype;

    # Reset the signal info.
    @SignalObjects = ();
    @SignalNames = ();
    @SignalReturns = ();
    @SignalFlags = ();
    @SignalPrototypes = ();

    if (! -f $file) {
        return;
    }
    if (!open (INPUT, $file)) {
        warn "Can't open $file - skipping signals\n";
        return;
    }
    while (<INPUT>) {
        if (!$in_signal) {
            if (m/^<SIGNAL>/) {
                $in_signal = 1;
                $signal_object = "";
                $signal_name = "";
                $signal_returns = "";
                $signal_prototype = "";
            }
        } else {
            if (m/^<NAME>(.*)<\/NAME>/) {
                $signal_name = $1;
                if ($signal_name =~ m/^(.*)::(.*)$/) {
                    $signal_object = $1;
                    ($signal_name = $2) =~ s/_/-/g;
                    #print "Found signal: $signal_name\n";
                } else {
                    &LogWarning ($file, $., "Invalid signal name: $signal_name.");
                }
            } elsif (m/^<RETURNS>(.*)<\/RETURNS>/) {
                $signal_returns = $1;
            } elsif (m/^<FLAGS>(.*)<\/FLAGS>/) {
                $signal_flags = $1;
            } elsif (m%^</SIGNAL>%) {
                #print "Found end of signal: ${signal_object}::${signal_name}\nReturns: ${signal_returns}\n${signal_prototype}";
                push (@SignalObjects, $signal_object);
                push (@SignalNames, $signal_name);
                push (@SignalReturns, $signal_returns);
                push (@SignalFlags, $signal_flags);
                push (@SignalPrototypes, $signal_prototype);
                $in_signal = 0;
            } else {
                $signal_prototype .= $_;
            }
        }
    }
    close (INPUT);
}


#############################################################################
# Function    : ReadTemplateFile
# Description : This reads in the manually-edited documentation file
#                corresponding to the file currently being created, so we can
#                insert the documentation at the appropriate places.
#                It outputs %SymbolTypes, %SymbolDocs and %SymbolParams, which
#                is a hash of arrays.
#                NOTE: This function is duplicated in gtkdoc-mktmpl (but
#                slightly different).
# Arguments   : $docsfile - the template file to read in.
#                $skip_unused_params - 1 if the unused parameters should be
#                        skipped.
#############################################################################

sub ReadTemplateFile {
    my ($docsfile, $skip_unused_params) = @_;

    my $template = "$docsfile.sgml";
    if (! -f $template) {
        #print "File doesn't exist: $template\n";
        return 0;
    }

    # start with empty hashes, we merge the source comment for each file
    # afterwards
    %SymbolDocs = ();
    %SymbolTypes = ();
    %SymbolParams = ();

    my $current_type = "";        # Type of symbol being read.
    my $current_symbol = "";        # Name of symbol being read.
    my $symbol_doc = "";                # Description of symbol being read.
    my @params;                        # Parameter names and descriptions of current
                                #   function/macro/function typedef.
    my $current_param = -1;        # Index of parameter currently being read.
                                #   Note that the param array contains pairs
                                #   of param name & description.
    my $in_unused_params = 0;        # True if we are reading in the unused params.
    my $in_deprecated = 0;
    my $in_since = 0;
    my $in_stability = 0;

    open (DOCS, "$template")
        || die "Can't open $template: $!";

    #("reading template $template");

    while (<DOCS>) {
        if (m/^<!-- ##### ([A-Z_]+) (\S+) ##### -->/) {
            my $type = $1;
            my $symbol = $2;
            if ($symbol eq "Title"
                || $symbol eq "Short_Description"
                || $symbol eq "Long_Description"
                || $symbol eq "See_Also"
                || $symbol eq "Stability_Level"
                || $symbol eq "Include"
                || $symbol eq "Image") {

                $symbol = $docsfile . ":" . $symbol;
            }

            #print "Found symbol: $symbol\n";
            # Remember file and line for the symbol
            $SymbolSourceFile{$symbol} = $template;
            $SymbolSourceLine{$symbol} = $.;

            # Store previous symbol, but remove any trailing blank lines.
            if ($current_symbol ne "") {
                $symbol_doc =~ s/\s+$//;
                $SymbolTypes{$current_symbol} = $current_type;
                $SymbolDocs{$current_symbol} = $symbol_doc;

                # Check that the stability level is valid.
                if ($StabilityLevel{$current_symbol}) {
                    $StabilityLevel{$current_symbol} = &ParseStabilityLevel($StabilityLevel{$current_symbol}, $template, $., "Stability level for $current_symbol");
                }

                if ($current_param >= 0) {
                    $SymbolParams{$current_symbol} = [ @params ];
                } else {
                    # Delete any existing params in case we are overriding a
                    # previously read template.
                    delete $SymbolParams{$current_symbol};
                }
            }
            $current_type = $type;
            $current_symbol = $symbol;
            $current_param = -1;
            $in_unused_params = 0;
            $in_deprecated = 0;
            $in_since = 0;
            $in_stability = 0;
            $symbol_doc = "";
            @params = ();

        } elsif (m/^<!-- # Unused Parameters # -->/) {
            #print "DEBUG: Found unused parameters\n";
            $in_unused_params = 1;
            next;

        } elsif ($in_unused_params && $skip_unused_params) {
            # When outputting the DocBook we skip unused parameters.
            #print "DEBUG: Skipping unused param: $_";
            next;

        } else {
            # Check if param found. Need to handle "..." and "format...".
            if (s/^\@([\w\.]+):\040?//) {
                my $param_name = $1;
                my $param_desc = $_;
                # Allow variations of 'Returns'
                if ($param_name =~ m/^[Rr]eturns?$/) {
                    $param_name = "Returns";
                }
                # Allow varargs variations
                if ($param_name =~ m/^.*\.\.\.$/) {
                    $param_name = "...";
                }

                # strip trailing whitespaces and blank lines
                s/\s+\n$/\n/m;
                s/\n+$/\n/sm;
                #("Found param for symbol $current_symbol : '$param_name'= '$_'");

                if ($param_name eq "Deprecated") {
                    $in_deprecated = 1;
                    $Deprecated{$current_symbol} = $_;
                } elsif ($param_name eq "Since") {
                    $in_since = 1;
                    chomp;
                    $Since{$current_symbol} = $_;
                } elsif ($param_name eq "Stability") {
                    $in_stability = 1;
                    $StabilityLevel{$current_symbol} = $_;
                } else {
                    push (@params, $param_name);
                    push (@params, $param_desc);
                    $current_param += $PARAM_FIELD_COUNT;
                }
            } else {
                # strip trailing whitespaces and blank lines
                s/\s+\n$/\n/m;
                s/\n+$/\n/sm;

                if (!m/^\s+$/) {
                    if ($in_deprecated) {
                        $Deprecated{$current_symbol} .= $_;
                    } elsif ($in_since) {
                        &LogWarning ($template, $., "multi-line since docs found");
                        #$Since{$current_symbol} .= $_;
                    } elsif ($in_stability) {
                        $StabilityLevel{$current_symbol} .= $_;
                    } elsif ($current_param >= 0) {
                        $params[$current_param] .= $_;
                    } else {
                        $symbol_doc .= $_;
                    }
                }
            }
        }
    }

    # Remember to finish the current symbol doccs.
    if ($current_symbol ne "") {

        $symbol_doc =~ s/\s+$//;
        $SymbolTypes{$current_symbol} = $current_type;
        $SymbolDocs{$current_symbol} = $symbol_doc;

        # Check that the stability level is valid.
        if ($StabilityLevel{$current_symbol}) {
            $StabilityLevel{$current_symbol} = &ParseStabilityLevel($StabilityLevel{$current_symbol}, $template, $., "Stability level for $current_symbol");
        }

        if ($current_param >= 0) {
            $SymbolParams{$current_symbol} = [ @params ];
        } else {
            # Delete any existing params in case we are overriding a
            # previously read template.
            delete $SymbolParams{$current_symbol};
        }
    }

    close (DOCS);
    return 1;
}


#############################################################################
# Function    : ReadObjectHierarchy
# Description : This reads in the $MODULE-hierarchy.txt file containing all
#                the GtkObject subclasses described in this module (and their
#                ancestors).
#                It places them in the @Objects array, and places their level
#                in the object hierarchy in the @ObjectLevels array, at the
#                same index. GtkObject, the root object, has a level of 1.
#
#               FIXME: the version in gtkdoc-mkdb also generates tree_index.sgml
#               as it goes along, this should be split out into a separate
#               function.
#
# Arguments   : none
#############################################################################

sub ReadObjectHierarchy {
    @Objects = ();
    @ObjectLevels = ();

    if (! -f $OBJECT_TREE_FILE) {
        return;
    }
    if (!open (INPUT, $OBJECT_TREE_FILE)) {
        warn "Can't open $OBJECT_TREE_FILE - skipping object tree\n";
        return;
    }

    # FIXME: use $OUTPUT_FORMAT
    # my $old_tree_index = "$SGML_OUTPUT_DIR/tree_index.$OUTPUT_FORMAT";
    my $old_tree_index = "$SGML_OUTPUT_DIR/tree_index.sgml";
    my $new_tree_index = "$SGML_OUTPUT_DIR/tree_index.new";

    open (OUTPUT, ">$new_tree_index")
        || die "Can't create $new_tree_index: $!";

    if ($OUTPUT_FORMAT eq "xml") {
        my $tree_header = $doctype_header;

        $tree_header =~ s/<!DOCTYPE \w+/<!DOCTYPE screen/;
        print (OUTPUT "$tree_header");
    }
    print (OUTPUT "<screen>\n");

    # Only emit objects if they are supposed to be documented, or if
    # they have documented children. To implement this, we maintain a
    # stack of pending objects which will be emitted if a documented
    # child turns up.
    my @pending_objects = ();
    my @pending_levels = ();
    my $root;
    while (<INPUT>) {
        if (m/\S+/) {
            my $object = $&;
            my $level = (length($`)) / 2 + 1;
            my $xref = "";

            if ($level == 1) {
                $root = $object;
            }

            while (($#pending_levels >= 0) && ($pending_levels[$#pending_levels] >= $level)) {
                my $pobject = pop(@pending_objects);
                my $plevel = pop(@pending_levels);
            }

               push (@pending_objects, $object);
            push (@pending_levels, $level);

            if (exists($KnownSymbols{$object}) && $KnownSymbols{$object} == 1) {
                   while ($#pending_levels >= 0) {
                    $object = shift @pending_objects;
                    $level = shift @pending_levels;
                       $xref = &MakeXRef ($object);

                     print (OUTPUT ' ' x ($level * 4), "$xref\n");
                    push (@Objects, $object);
                    push (@ObjectLevels, $level);
                    $ObjectRoots{$object} = $root;
                }
            }
            #else {
            #    LogWarning ($OBJECT_TREE_FILE, $., "unknown type $object");
            #}
        }
    }
    print (OUTPUT "</screen>\n");

    close (INPUT);
    close (OUTPUT);

    &UpdateFileIfChanged ($old_tree_index, $new_tree_index, 0);

    &OutputObjectList;
}

#############################################################################
# Function    : ReadInterfaces
# Description : This reads in the $MODULE.interfaces file.
#
# Arguments   : none
#############################################################################

sub ReadInterfaces {
    %Interfaces = ();

    if (! -f $INTERFACES_FILE) {
        return;
    }
    if (!open (INPUT, $INTERFACES_FILE)) {
        warn "Can't open $INTERFACES_FILE - skipping interfaces\n";
        return;
    }

    while (<INPUT>) {
       chomp;
       my ($object, @ifaces) = split;
       if (exists($KnownSymbols{$object}) && $KnownSymbols{$object} == 1) {
           my @knownIfaces = ();

           # filter out private interfaces, but leave foreign interfaces
           foreach my $iface (@ifaces) {
               if (!exists($KnownSymbols{$iface}) || $KnownSymbols{$iface} == 1) {
                   push (@knownIfaces, $iface);
               }
             }

           $Interfaces{$object} = join(' ', @knownIfaces);
       }
    }
    close (INPUT);
}

#############################################################################
# Function    : ReadPrerequisites
# Description : This reads in the $MODULE.prerequisites file.
#
# Arguments   : none
#############################################################################

sub ReadPrerequisites {
    %Prerequisites = ();

    if (! -f $PREREQUISITES_FILE) {
        return;
    }
    if (!open (INPUT, $PREREQUISITES_FILE)) {
        warn "Can't open $PREREQUISITES_FILE - skipping prerequisites\n";
        return;
    }

    while (<INPUT>) {
       chomp;
       my ($iface, @prereqs) = split;
       if (exists($KnownSymbols{$iface}) && $KnownSymbols{$iface} == 1) {
           my @knownPrereqs = ();

           # filter out private prerequisites, but leave foreign prerequisites
           foreach my $prereq (@prereqs) {
               if (!exists($KnownSymbols{$prereq}) || $KnownSymbols{$prereq} == 1) {
                  push (@knownPrereqs, $prereq);
               }
           }

           $Prerequisites{$iface} = join(' ', @knownPrereqs);
       }
    }
    close (INPUT);
}

#############################################################################
# Function    : ReadArgsFile
# Description : This reads in an existing file which contains information on
#                all GTK args. It creates the arrays @ArgObjects, @ArgNames,
#                @ArgTypes, @ArgFlags, @ArgNicks and @ArgBlurbs containing info
#               on the args.
# Arguments   : $file - the file containing the arg information.
#############################################################################

sub ReadArgsFile {
    my ($file) = @_;

    my $in_arg = 0;
    my $arg_object;
    my $arg_name;
    my $arg_type;
    my $arg_flags;
    my $arg_nick;
    my $arg_blurb;
    my $arg_default;
    my $arg_range;

    # Reset the args info.
    @ArgObjects = ();
    @ArgNames = ();
    @ArgTypes = ();
    @ArgFlags = ();
    @ArgNicks = ();
    @ArgBlurbs = ();
    @ArgDefaults = ();
    @ArgRanges = ();

    if (! -f $file) {
        return;
    }
    if (!open (INPUT, $file)) {
        warn "Can't open $file - skipping args\n";
        return;
    }
    while (<INPUT>) {
        if (!$in_arg) {
            if (m/^<ARG>/) {
                $in_arg = 1;
                $arg_object = "";
                $arg_name = "";
                $arg_type = "";
                $arg_flags = "";
                $arg_nick = "";
                $arg_blurb = "";
                $arg_default = "";
                $arg_range = "";
            }
        } else {
            if (m/^<NAME>(.*)<\/NAME>/) {
                $arg_name = $1;
                if ($arg_name =~ m/^(.*)::(.*)$/) {
                    $arg_object = $1;
                    ($arg_name = $2) =~ s/_/-/g;
                    #print "Found arg: $arg_name\n";
                } else {
                    &LogWarning ($file, $., "Invalid argument name: $arg_name");
                }
            } elsif (m/^<TYPE>(.*)<\/TYPE>/) {
                $arg_type = $1;
            } elsif (m/^<RANGE>(.*)<\/RANGE>/) {
                $arg_range = $1;
            } elsif (m/^<FLAGS>(.*)<\/FLAGS>/) {
                $arg_flags = $1;
            } elsif (m/^<NICK>(.*)<\/NICK>/) {
                $arg_nick = $1;
            } elsif (m/^<BLURB>(.*)<\/BLURB>/) {
                $arg_blurb = $1;
                if ($arg_blurb eq "(null)") {
                  $arg_blurb = "";
                  &LogWarning ($file, $., "Property ${arg_object}:${arg_name} has no documentation.");
                }
            } elsif (m/^<DEFAULT>(.*)<\/DEFAULT>/) {
                $arg_default = $1;
            } elsif (m%^</ARG>%) {
                #print "Found end of arg: ${arg_object}::${arg_name}\n${arg_type} : ${arg_flags}\n";
                push (@ArgObjects, $arg_object);
                push (@ArgNames, $arg_name);
                push (@ArgTypes, $arg_type);
                push (@ArgRanges, $arg_range);
                push (@ArgFlags, $arg_flags);
                push (@ArgNicks, $arg_nick);
                push (@ArgBlurbs, $arg_blurb);
                push (@ArgDefaults, $arg_default);
                $in_arg = 0;
            }
        }
    }
    close (INPUT);
}


#############################################################################
# Function    : CheckIsObject
# Description : Returns 1 if the given name is a GObject or a subclass.
#                It uses the global @Objects array.
#                Note that the @Objects array only contains classes in the
#                current module and their ancestors - not all GObject classes.
# Arguments   : $name - the name to check.
#############################################################################

sub CheckIsObject {
    my ($name) = @_;
    my $root = $ObjectRoots{$name};
    # Let GBoxed pass as an object here to get -struct appended to the id
    # and prevent conflicts with sections.
    return defined($root) and $root ne 'GEnum' and $root ne 'GFlags';
}


#############################################################################
# Function    : MakeReturnField
# Description : Pads a string to $RETURN_TYPE_FIELD_WIDTH.
# Arguments   : $str - the string to pad.
#############################################################################

sub MakeReturnField {
    my ($str) = @_;

    return $str . (' ' x ($RETURN_TYPE_FIELD_WIDTH - length ($str)));
}

#############################################################################
# Function    : GetSymbolSourceFile
# Description : Get the filename where the symbol docs where taken from.
# Arguments   : $symbol - the symbol name
#############################################################################

sub GetSymbolSourceFile {
    my ($symbol) = @_;

    if (defined($SourceSymbolSourceFile{$symbol})) {
        return $SourceSymbolSourceFile{$symbol};
    } elsif (defined($SymbolSourceFile{$symbol})) {
        return $SymbolSourceFile{$symbol};
    } else {
        return "";
    }
}

#############################################################################
# Function    : GetSymbolSourceLine
# Description : Get the file line where the symbol docs where taken from.
# Arguments   : $symbol - the symbol name
#############################################################################

sub GetSymbolSourceLine {
    my ($symbol) = @_;

    if (defined($SourceSymbolSourceLine{$symbol})) {
        return $SourceSymbolSourceLine{$symbol};
    } elsif (defined($SymbolSourceLine{$symbol})) {
        return $SymbolSourceLine{$symbol};
    } else {
        return 0;
    }
}

