<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Llvm_analysis.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Llvm" rel="Chapter" href="Llvm.html">
<link title="Llvm_analysis" rel="Chapter" href="Llvm_analysis.html">
<link title="Llvm_bitreader" rel="Chapter" href="Llvm_bitreader.html">
<link title="Llvm_bitwriter" rel="Chapter" href="Llvm_bitwriter.html">
<link title="Llvm_executionengine" rel="Chapter" href="Llvm_executionengine.html">
<link title="Llvm_ipo" rel="Chapter" href="Llvm_ipo.html">
<link title="Llvm_scalar_opts" rel="Chapter" href="Llvm_scalar_opts.html">
<link title="Llvm_target" rel="Chapter" href="Llvm_target.html"><link title="Abstract types" rel="Section" href="#6_Abstracttypes">
<link title="Iteration" rel="Section" href="#6_Iteration">
<link title="Exceptions" rel="Section" href="#6_Exceptions">
<link title="Contexts" rel="Section" href="#6_Contexts">
<link title="Modules" rel="Section" href="#6_Modules">
<link title="Types" rel="Section" href="#6_Types">
<link title="Instruction builders" rel="Section" href="#6_Instructionbuilders">
<link title="Memory buffers" rel="Section" href="#6_Memorybuffers">
<link title="Pass Managers" rel="Section" href="#6_PassManagers">
<link title="Operations on integer types" rel="Subsection" href="#7_Operationsonintegertypes">
<link title="Operations on real types" rel="Subsection" href="#7_Operationsonrealtypes">
<link title="Operations on function types" rel="Subsection" href="#7_Operationsonfunctiontypes">
<link title="Operations on struct types" rel="Subsection" href="#7_Operationsonstructtypes">
<link title="Operations on pointer, vector, and array types" rel="Subsection" href="#7_Operationsonpointervectorandarraytypes">
<link title="Operations on other types" rel="Subsection" href="#7_Operationsonothertypes">
<link title="Operations on constants of (mostly) any type" rel="Subsection" href="#7_Operationsonconstantsofmostlyanytype">
<link title="Operations on metadata" rel="Subsection" href="#7_Operationsonmetadata">
<link title="Operations on scalar constants" rel="Subsection" href="#7_Operationsonscalarconstants">
<link title="Operations on composite constants" rel="Subsection" href="#7_Operationsoncompositeconstants">
<link title="Constant expressions" rel="Subsection" href="#7_Constantexpressions">
<link title="Operations on global variables, functions, and aliases (globals)" rel="Subsection" href="#7_Operationsonglobalvariablesfunctionsandaliasesglobals">
<link title="Operations on global variables" rel="Subsection" href="#7_Operationsonglobalvariables">
<link title="Operations on aliases" rel="Subsection" href="#7_Operationsonaliases">
<link title="Operations on functions" rel="Subsection" href="#7_Operationsonfunctions">
<link title="Operations on params" rel="Subsection" href="#7_Operationsonparams">
<link title="Operations on basic blocks" rel="Subsection" href="#7_Operationsonbasicblocks">
<link title="Operations on instructions" rel="Subsection" href="#7_Operationsoninstructions">
<link title="Operations on call sites" rel="Subsection" href="#7_Operationsoncallsites">
<link title="Operations on phi nodes" rel="Subsection" href="#7_Operationsonphinodes">
<link title="Metadata" rel="Subsection" href="#7_Metadata">
<link title="Terminators" rel="Subsection" href="#7_Terminators">
<link title="Arithmetic" rel="Subsection" href="#7_Arithmetic">
<link title="Memory" rel="Subsection" href="#7_Memory">
<link title="Casts" rel="Subsection" href="#7_Casts">
<link title="Comparisons" rel="Subsection" href="#7_Comparisons">
<link title="Miscellaneous instructions" rel="Subsection" href="#7_Miscellaneousinstructions">
<title>Llvm</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Llvm_analysis.html">Next</a>
</div>
<center><h1>Module <a href="type_Llvm.html">Llvm</a></h1></center>
<br>
<pre><span class="keyword">module</span> Llvm: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>Core API.
<p>

    This interface provides an ocaml API for the LLVM intermediate
    representation, the classes in the VMCore library.<br>
<hr width="100%">
<br>
<span id="6_Abstracttypes"><h6>Abstract types</h6></span>
<p>

    These abstract types correlate directly to the LLVM VMCore classes.<br>
<pre><span id="TYPEllcontext"><span class="keyword">type</span> <code class="type"></code>llcontext</span> </pre>
<div class="info">
The top-level container for all LLVM global data. See the
    <code class="code">llvm::<span class="constructor">LLVMContext</span></code> class.<br>
</div>

<pre><span id="TYPEllmodule"><span class="keyword">type</span> <code class="type"></code>llmodule</span> </pre>
<div class="info">
The top-level container for all other LLVM Intermediate Representation (IR)
    objects. See the <code class="code">llvm::<span class="constructor">Module</span></code> class.<br>
</div>

<pre><span id="TYPElltype"><span class="keyword">type</span> <code class="type"></code>lltype</span> </pre>
<div class="info">
Each value in the LLVM IR has a type, an instance of <code class="code">lltype</code>. See the
    <code class="code">llvm::<span class="constructor">Type</span></code> class.<br>
</div>

<pre><span id="TYPEllvalue"><span class="keyword">type</span> <code class="type"></code>llvalue</span> </pre>
<div class="info">
Any value in the LLVM IR. Functions, instructions, global variables,
    constants, and much more are all <code class="code">llvalues</code>. See the <code class="code">llvm::<span class="constructor">Value</span></code> class.
    This type covers a wide range of subclasses.<br>
</div>

<pre><span id="TYPElluse"><span class="keyword">type</span> <code class="type"></code>lluse</span> </pre>
<div class="info">
Used to store users and usees of values. See the <code class="code">llvm::<span class="constructor">Use</span></code> class.<br>
</div>

<pre><span id="TYPEllbasicblock"><span class="keyword">type</span> <code class="type"></code>llbasicblock</span> </pre>
<div class="info">
A basic block in LLVM IR. See the <code class="code">llvm::<span class="constructor">BasicBlock</span></code> class.<br>
</div>

<pre><span id="TYPEllbuilder"><span class="keyword">type</span> <code class="type"></code>llbuilder</span> </pre>
<div class="info">
Used to generate instructions in the LLVM IR. See the <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>
    class.<br>
</div>

<pre><span id="TYPEllmemorybuffer"><span class="keyword">type</span> <code class="type"></code>llmemorybuffer</span> </pre>
<div class="info">
Used to efficiently handle large buffers of read-only binary data.
    See the <code class="code">llvm::<span class="constructor">MemoryBuffer</span></code> class.<br>
</div>

<pre><span class="keyword">module</span> <a href="Llvm.TypeKind.html">TypeKind</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.TypeKind.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The kind of an <code class="code">lltype</code>, the result of <code class="code">classify_type ty</code>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Linkage.html">Linkage</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Linkage.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The linkage of a global value, accessed with <a href="Llvm.html#VALlinkage"><code class="code"><span class="constructor">Llvm</span>.linkage</code></a> and
    <a href="Llvm.html#VALset_linkage"><code class="code"><span class="constructor">Llvm</span>.set_linkage</code></a>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Visibility.html">Visibility</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Visibility.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The linker visibility of a global value, accessed with <a href="Llvm.html#VALvisibility"><code class="code"><span class="constructor">Llvm</span>.visibility</code></a> and
    <a href="Llvm.html#VALset_visibility"><code class="code"><span class="constructor">Llvm</span>.set_visibility</code></a>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.CallConv.html">CallConv</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.CallConv.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The following calling convention values may be accessed with
    <a href="Llvm.html#VALfunction_call_conv"><code class="code"><span class="constructor">Llvm</span>.function_call_conv</code></a> and <a href="Llvm.html#VALset_function_call_conv"><code class="code"><span class="constructor">Llvm</span>.set_function_call_conv</code></a>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Attribute.html">Attribute</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Attribute.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><pre><span class="keyword">module</span> <a href="Llvm.Icmp.html">Icmp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Icmp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The predicate for an integer comparison (<code class="code">icmp</code>) instruction.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Fcmp.html">Fcmp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Fcmp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The predicate for a floating-point comparison (<code class="code">fcmp</code>) instruction.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Opcode.html">Opcode</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Opcode.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The opcodes for LLVM instructions and constant expressions.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.ValueKind.html">ValueKind</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.ValueKind.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The kind of an <code class="code">llvalue</code>, the result of <code class="code">classify_value v</code>.
</div>
<br>
<span id="6_Iteration"><h6>Iteration</h6></span><br>
<br><code><span id="TYPEllpos"><span class="keyword">type</span> <code class="type">('a, 'b)</code> llpos</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">At_end</span> <span class="keyword">of</span> <code class="type">'a</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Before</span> <span class="keyword">of</span> <code class="type">'b</code></code></td>

</tr></table>

<div class="info">
<code class="code"><span class="constructor">Before</span> b</code> and <code class="code"><span class="constructor">At_end</span> a</code> specify positions from the start of the <code class="code"><span class="keywordsign">'</span>b</code> list
    of <code class="code">a</code>. <code class="code">llpos</code> is used to specify positions in and for forward iteration
    through the various value lists maintained by the LLVM IR.<br>
</div>

<br><code><span id="TYPEllrev_pos"><span class="keyword">type</span> <code class="type">('a, 'b)</code> llrev_pos</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">At_start</span> <span class="keyword">of</span> <code class="type">'a</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">After</span> <span class="keyword">of</span> <code class="type">'b</code></code></td>

</tr></table>

<div class="info">
<code class="code"><span class="constructor">After</span> b</code> and <code class="code"><span class="constructor">At_start</span> a</code> specify positions from the end of the <code class="code"><span class="keywordsign">'</span>b</code> list
    of <code class="code">a</code>. <code class="code">llrev_pos</code> is used for reverse iteration through the various value
    lists maintained by the LLVM IR.<br>
</div>

<br>
<span id="6_Exceptions"><h6>Exceptions</h6></span><br>
<pre><span id="EXCEPTIONIoError"><span class="keyword">exception</span> IoError</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<br>
<span id="6_Contexts"><h6>Contexts</h6></span><br>
<pre><span id="VALcreate_context"><span class="keyword">val</span> create_context</span> : <code class="type">unit -> <a href="Llvm.html#TYPEllcontext">llcontext</a></code></pre><div class="info">
<code class="code">create_context ()</code> creates a context for storing the "global" state in
    LLVM. See the constructor <code class="code">llvm::<span class="constructor">LLVMContext</span></code>.<br>
</div>
<pre><span id="VALdispose_context"><span class="keyword">val</span> dispose_context</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> unit</code></pre><div class="info">
<code class="code">destroy_context ()</code> destroys a context. See the destructor
    <code class="code">llvm::<span class="constructor">LLVMContext</span>::~<span class="constructor">LLVMContext</span></code>.<br>
</div>
<pre><span id="VALglobal_context"><span class="keyword">val</span> global_context</span> : <code class="type">unit -> <a href="Llvm.html#TYPEllcontext">llcontext</a></code></pre><div class="info">
See the function <code class="code">llvm::getGlobalContext</code>.<br>
</div>
<pre><span id="VALmdkind_id"><span class="keyword">val</span> mdkind_id</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> int</code></pre><div class="info">
<code class="code">mdkind_id context name</code> returns the MDKind ID that corresponds to the
    name <code class="code">name</code> in the context <code class="code">context</code>.  See the function
    <code class="code">llvm::<span class="constructor">LLVMContext</span>::getMDKindID</code>.<br>
</div>
<br>
<span id="6_Modules"><h6>Modules</h6></span><br>
<pre><span id="VALcreate_module"><span class="keyword">val</span> create_module</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllmodule">llmodule</a></code></pre><div class="info">
<code class="code">create_module context id</code> creates a module with the supplied module ID in
    the context <code class="code">context</code>.  Modules are not garbage collected; it is mandatory
    to call <a href="Llvm.html#VALdispose_module"><code class="code"><span class="constructor">Llvm</span>.dispose_module</code></a> to free memory. See the constructor
    <code class="code">llvm::<span class="constructor">Module</span>::<span class="constructor">Module</span></code>.<br>
</div>
<pre><span id="VALdispose_module"><span class="keyword">val</span> dispose_module</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">dispose_module m</code> destroys a module <code class="code">m</code> and all of the IR objects it
    contained. All references to subordinate objects are invalidated;
    referencing them will invoke undefined behavior. See the destructor
    <code class="code">llvm::<span class="constructor">Module</span>::~<span class="constructor">Module</span></code>.<br>
</div>
<pre><span id="VALtarget_triple"><span class="keyword">val</span> target_triple</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string</code></pre><div class="info">
<code class="code">target_triple m</code> is the target specifier for the module <code class="code">m</code>, something like
    <code class="code">i686-apple-darwin8</code>. See the method <code class="code">llvm::<span class="constructor">Module</span>::getTargetTriple</code>.<br>
</div>
<pre><span id="VALset_target_triple"><span class="keyword">val</span> set_target_triple</span> : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">target_triple triple m</code> changes the target specifier for the module <code class="code">m</code> to
    the string <code class="code">triple</code>. See the method <code class="code">llvm::<span class="constructor">Module</span>::setTargetTriple</code>.<br>
</div>
<pre><span id="VALdata_layout"><span class="keyword">val</span> data_layout</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string</code></pre><div class="info">
<code class="code">data_layout m</code> is the data layout specifier for the module <code class="code">m</code>, something
    like <code class="code">e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-...-a0:0:64-f80:128:128</code>. See the
    method <code class="code">llvm::<span class="constructor">Module</span>::getDataLayout</code>.<br>
</div>
<pre><span id="VALset_data_layout"><span class="keyword">val</span> set_data_layout</span> : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">set_data_layout s m</code> changes the data layout specifier for the module <code class="code">m</code>
    to the string <code class="code">s</code>. See the method <code class="code">llvm::<span class="constructor">Module</span>::setDataLayout</code>.<br>
</div>
<pre><span id="VALdump_module"><span class="keyword">val</span> dump_module</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">dump_module m</code> prints the .ll representation of the module <code class="code">m</code> to standard
    error. See the method <code class="code">llvm::<span class="constructor">Module</span>::dump</code>.<br>
</div>
<pre><span id="VALset_module_inline_asm"><span class="keyword">val</span> set_module_inline_asm</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string -> unit</code></pre><div class="info">
<code class="code">set_module_inline_asm m asm</code> sets the inline assembler for the module. See
    the method <code class="code">llvm::<span class="constructor">Module</span>::setModuleInlineAsm</code>.<br>
</div>
<pre><span id="VALmodule_context"><span class="keyword">val</span> module_context</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllcontext">llcontext</a></code></pre><div class="info">
<code class="code">module_context m</code> returns the context of the specified module.
 * See the method <code class="code">llvm::<span class="constructor">Module</span>::getContext</code><br>
</div>
<br>
<span id="6_Types"><h6>Types</h6></span><br>
<pre><span id="VALclassify_type"><span class="keyword">val</span> classify_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.TypeKind.html#TYPEt">TypeKind.t</a></code></pre><div class="info">
<code class="code">classify_type ty</code> returns the <a href="Llvm.TypeKind.html#TYPEt"><code class="code"><span class="constructor">Llvm</span>.<span class="constructor">TypeKind</span>.t</code></a> corresponding to the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">Type</span>::getTypeID</code>.<br>
</div>
<pre><span id="VALtype_is_sized"><span class="keyword">val</span> type_is_sized</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> bool</code></pre><div class="info">
<code class="code">type_is_sized ty</code> returns whether the type has a size or not.
 * If it doesn't then it is not safe to call the <code class="code"><span class="constructor">TargetData</span>::</code> methods on it.
 *<br>
</div>
<pre><span id="VALtype_context"><span class="keyword">val</span> type_context</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllcontext">llcontext</a></code></pre><div class="info">
<code class="code">type_context ty</code> returns the <a href="Llvm.html#TYPEllcontext"><code class="code"><span class="constructor">Llvm</span>.llcontext</code></a> corresponding to the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">Type</span>::getContext</code>.<br>
</div>
<pre><span id="VALstring_of_lltype"><span class="keyword">val</span> string_of_lltype</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string</code></pre><div class="info">
<code class="code">string_of_lltype ty</code> returns a string describing the type <code class="code">ty</code>.<br>
</div>
<br>
<span id="7_Operationsonintegertypes"><div class="h7">Operations on integer types</div></span><br>
<pre><span id="VALi1_type"><span class="keyword">val</span> i1_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i1_type c</code> returns an integer type of bitwidth 1 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int1Ty</span></code>.<br>
</div>
<pre><span id="VALi8_type"><span class="keyword">val</span> i8_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i8_type c</code> returns an integer type of bitwidth 8 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int8Ty</span></code>.<br>
</div>
<pre><span id="VALi16_type"><span class="keyword">val</span> i16_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i16_type c</code> returns an integer type of bitwidth 16 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int16Ty</span></code>.<br>
</div>
<pre><span id="VALi32_type"><span class="keyword">val</span> i32_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i32_type c</code> returns an integer type of bitwidth 32 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int32Ty</span></code>.<br>
</div>
<pre><span id="VALi64_type"><span class="keyword">val</span> i64_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i64_type c</code> returns an integer type of bitwidth 64 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int64Ty</span></code>.<br>
</div>
<pre><span id="VALinteger_type"><span class="keyword">val</span> integer_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">integer_type c n</code> returns an integer type of bitwidth <code class="code">n</code> in the context
    <code class="code">c</code>. See the method <code class="code">llvm::<span class="constructor">IntegerType</span>::get</code>.<br>
</div>
<pre><span id="VALinteger_bitwidth"><span class="keyword">val</span> integer_bitwidth</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">integer_bitwidth c ty</code> returns the number of bits in the integer type <code class="code">ty</code>
    in the context <code class="code">c</code>.  See the method <code class="code">llvm::<span class="constructor">IntegerType</span>::getBitWidth</code>.<br>
</div>
<br>
<span id="7_Operationsonrealtypes"><div class="h7">Operations on real types</div></span><br>
<pre><span id="VALfloat_type"><span class="keyword">val</span> float_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">float_type c</code> returns the IEEE 32-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">FloatTy</span></code>.<br>
</div>
<pre><span id="VALdouble_type"><span class="keyword">val</span> double_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">double_type c</code> returns the IEEE 64-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">DoubleTy</span></code>.<br>
</div>
<pre><span id="VALx86fp80_type"><span class="keyword">val</span> x86fp80_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">x86fp80_type c</code> returns the x87 80-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">X86_FP80Ty</span></code>.<br>
</div>
<pre><span id="VALfp128_type"><span class="keyword">val</span> fp128_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">fp128_type c</code> returns the IEEE 128-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">FP128Ty</span></code>.<br>
</div>
<pre><span id="VALppc_fp128_type"><span class="keyword">val</span> ppc_fp128_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">ppc_fp128_type c</code> returns the PowerPC 128-bit floating point type in the
    context <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">PPC_FP128Ty</span></code>.<br>
</div>
<br>
<span id="7_Operationsonfunctiontypes"><div class="h7">Operations on function types</div></span><br>
<pre><span id="VALfunction_type"><span class="keyword">val</span> function_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">function_type ret_ty param_tys</code> returns the function type returning
    <code class="code">ret_ty</code> and taking <code class="code">param_tys</code> as parameters.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::get</code>.<br>
</div>
<pre><span id="VALvar_arg_function_type"><span class="keyword">val</span> var_arg_function_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">var_arg_function_type ret_ty param_tys</code> is just like
    <code class="code">function_type ret_ty param_tys</code> except that it returns the function type
    which also takes a variable number of arguments.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::get</code>.<br>
</div>
<pre><span id="VALis_var_arg"><span class="keyword">val</span> is_var_arg</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> bool</code></pre><div class="info">
<code class="code">is_var_arg fty</code> returns <code class="code"><span class="keyword">true</span></code> if <code class="code">fty</code> is a varargs function type, <code class="code"><span class="keyword">false</span></code>
    otherwise. See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::isVarArg</code>.<br>
</div>
<pre><span id="VALreturn_type"><span class="keyword">val</span> return_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">return_type fty</code> gets the return type of the function type <code class="code">fty</code>.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::getReturnType</code>.<br>
</div>
<pre><span id="VALparam_types"><span class="keyword">val</span> param_types</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array</code></pre><div class="info">
<code class="code">param_types fty</code> gets the parameter types of the function type <code class="code">fty</code>.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::getParamType</code>.<br>
</div>
<br>
<span id="7_Operationsonstructtypes"><div class="h7">Operations on struct types</div></span><br>
<pre><span id="VALstruct_type"><span class="keyword">val</span> struct_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">struct_type context tys</code> returns the structure type in the context
    <code class="code">context</code> containing in the types in the array <code class="code">tys</code>. See the method
    <code class="code">llvm::<span class="constructor">StructType</span>::get</code>.<br>
</div>
<pre><span id="VALpacked_struct_type"><span class="keyword">val</span> packed_struct_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">packed_struct_type context ys</code> returns the packed structure type in the
    context <code class="code">context</code> containing in the types in the array <code class="code">tys</code>. See the method
    <code class="code">llvm::<span class="constructor">StructType</span>::get</code>.<br>
</div>
<pre><span id="VALstruct_name"><span class="keyword">val</span> struct_name</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string option</code></pre><div class="info">
<code class="code">struct_name ty</code> returns the name of the named structure type <code class="code">ty</code>,
 * or None if the structure type is not named<br>
</div>
<pre><span id="VALnamed_struct_type"><span class="keyword">val</span> named_struct_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">named_struct_type context name</code> returns the named structure type <code class="code">name</code>
 * in the context <code class="code">context</code>.
 * See the method <code class="code">llvm::<span class="constructor">StructType</span>::get</code>.<br>
</div>
<pre><span id="VALstruct_set_body"><span class="keyword">val</span> struct_set_body</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> bool -> unit</code></pre><div class="info">
<code class="code">struct_set_body ty elts ispacked</code> sets the body of the named struct <code class="code">ty</code>
 * to the <code class="code">elts</code> elements.
 * See the moethd <code class="code">llvm::<span class="constructor">StructType</span>::setBody</code>.<br>
</div>
<pre><span id="VALstruct_element_types"><span class="keyword">val</span> struct_element_types</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array</code></pre><div class="info">
<code class="code">struct_element_types sty</code> returns the constituent types of the struct type
    <code class="code">sty</code>. See the method <code class="code">llvm::<span class="constructor">StructType</span>::getElementType</code>.<br>
</div>
<pre><span id="VALis_packed"><span class="keyword">val</span> is_packed</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> bool</code></pre><div class="info">
<code class="code">is_packed sty</code> returns <code class="code"><span class="keyword">true</span></code> if the structure type <code class="code">sty</code> is packed,
    <code class="code"><span class="keyword">false</span></code> otherwise. See the method <code class="code">llvm::<span class="constructor">StructType</span>::isPacked</code>.<br>
</div>
<pre><span id="VALis_opaque"><span class="keyword">val</span> is_opaque</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> bool</code></pre><div class="info">
<code class="code">is_opaque sty</code> returns <code class="code"><span class="keyword">true</span></code> if the structure type <code class="code">sty</code> is opaque.
    <code class="code"><span class="keyword">false</span></code> otherwise. See the method <code class="code">llvm::<span class="constructor">StructType</span>::isOpaque</code>.<br>
</div>
<br>
<span id="7_Operationsonpointervectorandarraytypes"><div class="h7">Operations on pointer, vector, and array types</div></span><br>
<pre><span id="VALarray_type"><span class="keyword">val</span> array_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">array_type ty n</code> returns the array type containing <code class="code">n</code> elements of type
    <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">ArrayType</span>::get</code>.<br>
</div>
<pre><span id="VALpointer_type"><span class="keyword">val</span> pointer_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">pointer_type ty</code> returns the pointer type referencing objects of type
    <code class="code">ty</code> in the default address space (0).
    See the method <code class="code">llvm::<span class="constructor">PointerType</span>::getUnqual</code>.<br>
</div>
<pre><span id="VALqualified_pointer_type"><span class="keyword">val</span> qualified_pointer_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">qualified_pointer_type ty <span class="keyword">as</span></code> returns the pointer type referencing objects
    of type <code class="code">ty</code> in address space <code class="code"><span class="keyword">as</span></code>.
    See the method <code class="code">llvm::<span class="constructor">PointerType</span>::get</code>.<br>
</div>
<pre><span id="VALvector_type"><span class="keyword">val</span> vector_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">vector_type ty n</code> returns the array type containing <code class="code">n</code> elements of the
    primitive type <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">ArrayType</span>::get</code>.<br>
</div>
<pre><span id="VALelement_type"><span class="keyword">val</span> element_type</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">element_type ty</code> returns the element type of the pointer, vector, or array
    type <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">SequentialType</span>::get</code>.<br>
</div>
<pre><span id="VALarray_length"><span class="keyword">val</span> array_length</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">element_type aty</code> returns the element count of the array type <code class="code">aty</code>.
    See the method <code class="code">llvm::<span class="constructor">ArrayType</span>::getNumElements</code>.<br>
</div>
<pre><span id="VALaddress_space"><span class="keyword">val</span> address_space</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">address_space pty</code> returns the address space qualifier of the pointer type
    <code class="code">pty</code>. See the method <code class="code">llvm::<span class="constructor">PointerType</span>::getAddressSpace</code>.<br>
</div>
<pre><span id="VALvector_size"><span class="keyword">val</span> vector_size</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">element_type ty</code> returns the element count of the vector type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">VectorType</span>::getNumElements</code>.<br>
</div>
<br>
<span id="7_Operationsonothertypes"><div class="h7">Operations on other types</div></span><br>
<pre><span id="VALvoid_type"><span class="keyword">val</span> void_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">void_type c</code> creates a type of a function which does not return any
    value in the context <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">VoidTy</span></code>.<br>
</div>
<pre><span id="VALlabel_type"><span class="keyword">val</span> label_type</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">label_type c</code> creates a type of a basic block in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">LabelTy</span></code>.<br>
</div>
<pre><span id="VALtype_by_name"><span class="keyword">val</span> type_by_name</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string -> <a href="Llvm.html#TYPElltype">lltype</a> option</code></pre><div class="info">
<code class="code">type_by_name m name</code> returns the specified type from the current module
 * if it exists.
 * See the method <code class="code">llvm::<span class="constructor">Module</span>::getTypeByName</code><br>
</div>
<pre><span id="VALtype_of"><span class="keyword">val</span> type_of</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">type_of v</code> returns the type of the value <code class="code">v</code>.
    See the method <code class="code">llvm::<span class="constructor">Value</span>::getType</code>.<br>
</div>
<pre><span id="VALclassify_value"><span class="keyword">val</span> classify_value</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.ValueKind.html#TYPEt">ValueKind.t</a></code></pre><pre><span id="VALvalue_name"><span class="keyword">val</span> value_name</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string</code></pre><div class="info">
<code class="code">value_name v</code> returns the name of the value <code class="code">v</code>. For global values, this is
    the symbol name. For instructions and basic blocks, it is the SSA register
    name. It is meaningless for constants.
    See the method <code class="code">llvm::<span class="constructor">Value</span>::getName</code>.<br>
</div>
<pre><span id="VALset_value_name"><span class="keyword">val</span> set_value_name</span> : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_value_name n v</code> sets the name of the value <code class="code">v</code> to <code class="code">n</code>. See the method
    <code class="code">llvm::<span class="constructor">Value</span>::setName</code>.<br>
</div>
<pre><span id="VALdump_value"><span class="keyword">val</span> dump_value</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">dump_value v</code> prints the .ll representation of the value <code class="code">v</code> to standard
    error. See the method <code class="code">llvm::<span class="constructor">Value</span>::dump</code>.<br>
</div>
<pre><span id="VALreplace_all_uses_with"><span class="keyword">val</span> replace_all_uses_with</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">replace_all_uses_with old <span class="keyword">new</span></code> replaces all uses of the value <code class="code">old</code>
 * with the value <code class="code"><span class="keyword">new</span></code>. See the method <code class="code">llvm::<span class="constructor">Value</span>::replaceAllUsesWith</code>.<br>
</div>
<pre><span id="VALuse_begin"><span class="keyword">val</span> use_begin</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElluse">lluse</a> option</code></pre><div class="info">
<code class="code">use_begin v</code> returns the first position in the use list for the value <code class="code">v</code>.
    <code class="code">use_begin</code> and <code class="code">use_succ</code> can e used to iterate over the use list in order.
    See the method <code class="code">llvm::<span class="constructor">Value</span>::use_begin</code>.<br>
</div>
<pre><span id="VALuse_succ"><span class="keyword">val</span> use_succ</span> : <code class="type"><a href="Llvm.html#TYPElluse">lluse</a> -> <a href="Llvm.html#TYPElluse">lluse</a> option</code></pre><div class="info">
<code class="code">use_succ u</code> returns the use list position succeeding <code class="code">u</code>.
    See the method <code class="code">llvm::use_value_iterator::operator++</code>.<br>
</div>
<pre><span id="VALuser"><span class="keyword">val</span> user</span> : <code class="type"><a href="Llvm.html#TYPElluse">lluse</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">user u</code> returns the user of the use <code class="code">u</code>.
    See the method <code class="code">llvm::<span class="constructor">Use</span>::getUser</code>.<br>
</div>
<pre><span id="VALused_value"><span class="keyword">val</span> used_value</span> : <code class="type"><a href="Llvm.html#TYPElluse">lluse</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">used_value u</code> returns the usee of the use <code class="code">u</code>.
    See the method <code class="code">llvm::<span class="constructor">Use</span>::getUsedValue</code>.<br>
</div>
<pre><span id="VALiter_uses"><span class="keyword">val</span> iter_uses</span> : <code class="type">(<a href="Llvm.html#TYPElluse">lluse</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">iter_uses f v</code> applies function <code class="code">f</code> to each of the users of the value <code class="code">v</code>
    in order. Tail recursive.<br>
</div>
<pre><span id="VALfold_left_uses"><span class="keyword">val</span> fold_left_uses</span> : <code class="type">('a -> <a href="Llvm.html#TYPElluse">lluse</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_uses f init v</code> is <code class="code">f (... (f init u1) ...) uN</code> where
    <code class="code">u1,...,uN</code> are the users of the value <code class="code">v</code>. Tail recursive.<br>
</div>
<pre><span id="VALfold_right_uses"><span class="keyword">val</span> fold_right_uses</span> : <code class="type">(<a href="Llvm.html#TYPElluse">lluse</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_uses f v init</code> is <code class="code">f u1 (... (f uN init) ...)</code> where
    <code class="code">u1,...,uN</code> are the users of the value <code class="code">v</code>. Not tail recursive.<br>
</div>
<pre><span id="VALoperand"><span class="keyword">val</span> operand</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">operand v i</code> returns the operand at index <code class="code">i</code> for the value <code class="code">v</code>. See the
    method <code class="code">llvm::<span class="constructor">User</span>::getOperand</code>.<br>
</div>
<pre><span id="VALset_operand"><span class="keyword">val</span> set_operand</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_operand v i o</code> sets the operand of the value <code class="code">v</code> at the index <code class="code">i</code> to
    the value <code class="code">o</code>.
    See the method <code class="code">llvm::<span class="constructor">User</span>::setOperand</code>.<br>
</div>
<pre><span id="VALnum_operands"><span class="keyword">val</span> num_operands</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">num_operands v</code> returns the number of operands for the value <code class="code">v</code>.
    See the method <code class="code">llvm::<span class="constructor">User</span>::getNumOperands</code>.<br>
</div>
<br>
<span id="7_Operationsonconstantsofmostlyanytype"><div class="h7">Operations on constants of (mostly) any type</div></span><br>
<pre><span id="VALis_constant"><span class="keyword">val</span> is_constant</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_constant v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is a constant, <code class="code"><span class="keyword">false</span></code>
    otherwise. Similar to <code class="code">llvm::isa&lt;<span class="constructor">Constant</span>&gt;</code>.<br>
</div>
<pre><span id="VALconst_null"><span class="keyword">val</span> const_null</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_null ty</code> returns the constant null (zero) of the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">Constant</span>::getNullValue</code>.<br>
</div>
<pre><span id="VALconst_all_ones"><span class="keyword">val</span> const_all_ones</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_all_ones ty</code> returns the constant '-1' of the integer or vector type
    <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">Constant</span>::getAllOnesValue</code>.<br>
</div>
<pre><span id="VALconst_pointer_null"><span class="keyword">val</span> const_pointer_null</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_pointer_null ty</code> returns the constant null (zero) pointer of the type
    <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">ConstantPointerNull</span>::get</code>.<br>
</div>
<pre><span id="VALundef"><span class="keyword">val</span> undef</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">undef ty</code> returns the undefined value of the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">UndefValue</span>::get</code>.<br>
</div>
<pre><span id="VALis_null"><span class="keyword">val</span> is_null</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_null v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is the null (zero) value.
    See the method <code class="code">llvm::<span class="constructor">Constant</span>::isNullValue</code>.<br>
</div>
<pre><span id="VALis_undef"><span class="keyword">val</span> is_undef</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_undef v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is an undefined value, <code class="code"><span class="keyword">false</span></code>
    otherwise. Similar to <code class="code">llvm::isa&lt;<span class="constructor">UndefValue</span>&gt;</code>.<br>
</div>
<pre><span id="VALconstexpr_opcode"><span class="keyword">val</span> constexpr_opcode</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Opcode.html#TYPEt">Opcode.t</a></code></pre><div class="info">
<span id="7_Operationsoninstructions"><div class="h7">Operations on instructions</div></span><br>
</div>
<pre><span id="VALhas_metadata"><span class="keyword">val</span> has_metadata</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">has_metadata i</code> returns whether or not the instruction <code class="code">i</code> has any
    metadata attached to it. See the function
    <code class="code">llvm::<span class="constructor">Instruction</span>::hasMetadata</code>.<br>
</div>
<pre><span id="VALmetadata"><span class="keyword">val</span> metadata</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">metadata i kind</code> optionally returns the metadata associated with the
    kind <code class="code">kind</code> in the instruction <code class="code">i</code> See the function
    <code class="code">llvm::<span class="constructor">Instruction</span>::getMetadata</code>.<br>
</div>
<pre><span id="VALset_metadata"><span class="keyword">val</span> set_metadata</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_metadata i kind md</code> sets the metadata <code class="code">md</code> of kind <code class="code">kind</code> in the
    instruction <code class="code">i</code>. See the function <code class="code">llvm::<span class="constructor">Instruction</span>::setMetadata</code>.<br>
</div>
<pre><span id="VALclear_metadata"><span class="keyword">val</span> clear_metadata</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> unit</code></pre><div class="info">
<code class="code">clear_metadata i kind</code> clears the metadata of kind <code class="code">kind</code> in the
    instruction <code class="code">i</code>. See the function <code class="code">llvm::<span class="constructor">Instruction</span>::setMetadata</code>.<br>
</div>
<br>
<span id="7_Operationsonmetadata"><div class="h7">Operations on metadata</div></span><br>
<pre><span id="VALmdstring"><span class="keyword">val</span> mdstring</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">mdstring c s</code> returns the MDString of the string <code class="code">s</code> in the context <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">MDNode</span>::get</code>.<br>
</div>
<pre><span id="VALmdnode"><span class="keyword">val</span> mdnode</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">mdnode c elts</code> returns the MDNode containing the values <code class="code">elts</code> in the
    context <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">MDNode</span>::get</code>.<br>
</div>
<pre><span id="VALget_mdstring"><span class="keyword">val</span> get_mdstring</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string option</code></pre><div class="info">
<code class="code">get_mdstring v</code> returns the MDString.
 * See the method <code class="code">llvm::<span class="constructor">MDString</span>::getString</code><br>
</div>
<pre><span id="VALget_named_metadata"><span class="keyword">val</span> get_named_metadata</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array</code></pre><div class="info">
<code class="code">get_named_metadata m name</code> return all the MDNodes belonging to the named
 * metadata (if any).
 * See the method <code class="code">llvm::<span class="constructor">NamedMDNode</span>::getOperand</code>.<br>
</div>
<br>
<span id="7_Operationsonscalarconstants"><div class="h7">Operations on scalar constants</div></span><br>
<pre><span id="VALconst_int"><span class="keyword">val</span> const_int</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_int ty i</code> returns the integer constant of type <code class="code">ty</code> and value <code class="code">i</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantInt</span>::get</code>.<br>
</div>
<pre><span id="VALconst_of_int64"><span class="keyword">val</span> const_of_int64</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> Int64.t -> bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_of_int64 ty i</code> returns the integer constant of type <code class="code">ty</code> and value
    <code class="code">i</code>. See the method <code class="code">llvm::<span class="constructor">ConstantInt</span>::get</code>.<br>
</div>
<pre><span id="VALint64_of_const"><span class="keyword">val</span> int64_of_const</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> Int64.t option</code></pre><div class="info">
<code class="code">int64_of_const c</code> returns the int64 value of the <code class="code">c</code> constant integer.
 * None is returned if this is not an integer constant, or bitwidth exceeds 64.
 * See the method <code class="code">llvm::<span class="constructor">ConstantInt</span>::getSExtValue</code>.<br>
</div>
<pre><span id="VALconst_int_of_string"><span class="keyword">val</span> const_int_of_string</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_int_of_string ty s r</code> returns the integer constant of type <code class="code">ty</code> and
 * value <code class="code">s</code>, with the radix <code class="code">r</code>. See the method <code class="code">llvm::<span class="constructor">ConstantInt</span>::get</code>.<br>
</div>
<pre><span id="VALconst_float"><span class="keyword">val</span> const_float</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> float -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_float ty n</code> returns the floating point constant of type <code class="code">ty</code> and
    value <code class="code">n</code>. See the method <code class="code">llvm::<span class="constructor">ConstantFP</span>::get</code>.<br>
</div>
<pre><span id="VALconst_float_of_string"><span class="keyword">val</span> const_float_of_string</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_float_of_string ty s</code> returns the floating point constant of type
    <code class="code">ty</code> and value <code class="code">n</code>. See the method <code class="code">llvm::<span class="constructor">ConstantFP</span>::get</code>.<br>
</div>
<br>
<span id="7_Operationsoncompositeconstants"><div class="h7">Operations on composite constants</div></span><br>
<pre><span id="VALconst_string"><span class="keyword">val</span> const_string</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_string c s</code> returns the constant <code class="code">i8</code> array with the values of the
    characters in the string <code class="code">s</code> in the context <code class="code">c</code>. The array is not 
    null-terminated (but see <a href="Llvm.html#VALconst_stringz"><code class="code"><span class="constructor">Llvm</span>.const_stringz</code></a>). This value can in turn be used
    as the initializer for a global variable. See the method
    <code class="code">llvm::<span class="constructor">ConstantArray</span>::get</code>.<br>
</div>
<pre><span id="VALconst_stringz"><span class="keyword">val</span> const_stringz</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_stringz c s</code> returns the constant <code class="code">i8</code> array with the values of the
    characters in the string <code class="code">s</code> and a null terminator in the context <code class="code">c</code>. This
    value can in turn be used as the initializer for a global variable.
    See the method <code class="code">llvm::<span class="constructor">ConstantArray</span>::get</code>.<br>
</div>
<pre><span id="VALconst_array"><span class="keyword">val</span> const_array</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_array ty elts</code> returns the constant array of type
    <code class="code">array_type ty (<span class="constructor">Array</span>.length elts)</code> and containing the values <code class="code">elts</code>.
    This value can in turn be used as the initializer for a global variable.
    See the method <code class="code">llvm::<span class="constructor">ConstantArray</span>::get</code>.<br>
</div>
<pre><span id="VALconst_struct"><span class="keyword">val</span> const_struct</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_struct context elts</code> returns the structured constant of type
    <code class="code">struct_type (<span class="constructor">Array</span>.map type_of elts)</code> and containing the values <code class="code">elts</code>
    in the context <code class="code">context</code>. This value can in turn be used as the initializer
    for a global variable. See the method <code class="code">llvm::<span class="constructor">ConstantStruct</span>::getAnon</code>.<br>
</div>
<pre><span id="VALconst_named_struct"><span class="keyword">val</span> const_named_struct</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_named_struct namedty elts</code> returns the structured constant of type
    <code class="code">namedty</code> (which must be a named structure type) and containing the values <code class="code">elts</code>.
    This value can in turn be used as the initializer
    for a global variable. See the method <code class="code">llvm::<span class="constructor">ConstantStruct</span>::get</code>.<br>
</div>
<pre><span id="VALconst_packed_struct"><span class="keyword">val</span> const_packed_struct</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_packed_struct context elts</code> returns the structured constant of
    type <a href="Llvm.html#VALpacked_struct_type"><code class="code"><span class="constructor">Llvm</span>.packed_struct_type</code></a> <code class="code">(<span class="constructor">Array</span>.map type_of elts)</code> and containing the
    values <code class="code">elts</code> in the context <code class="code">context</code>. This value can in turn be used as
    the initializer for a global variable. See the method
    <code class="code">llvm::<span class="constructor">ConstantStruct</span>::get</code>.<br>
</div>
<pre><span id="VALconst_vector"><span class="keyword">val</span> const_vector</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_vector elts</code> returns the vector constant of type
    <code class="code">vector_type (type_of elts.(0)) (<span class="constructor">Array</span>.length elts)</code> and containing the
    values <code class="code">elts</code>. See the method <code class="code">llvm::<span class="constructor">ConstantVector</span>::get</code>.<br>
</div>
<br>
<span id="7_Constantexpressions"><div class="h7">Constant expressions</div></span><br>
<pre><span id="VALalign_of"><span class="keyword">val</span> align_of</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">align_of ty</code> returns the alignof constant for the type <code class="code">ty</code>. This is
    equivalent to <code class="code">const_ptrtoint (const_gep (const_null (pointer_type {i8,ty}))
    (const_int i32_type 0) (const_int i32_type 1)) i32_type</code>, but considerably
    more readable.  See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAlignOf</code>.<br>
</div>
<pre><span id="VALsize_of"><span class="keyword">val</span> size_of</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">size_of ty</code> returns the sizeof constant for the type <code class="code">ty</code>. This is
    equivalent to <code class="code">const_ptrtoint (const_gep (const_null (pointer_type ty))
    (const_int i32_type 1)) i64_type</code>, but considerably more readable.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSizeOf</code>.<br>
</div>
<pre><span id="VALconst_neg"><span class="keyword">val</span> const_neg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_neg c</code> returns the arithmetic negation of the constant <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNeg</code>.<br>
</div>
<pre><span id="VALconst_nsw_neg"><span class="keyword">val</span> const_nsw_neg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_neg c</code> returns the arithmetic negation of the constant <code class="code">c</code> with
    no signed wrapping. The result is undefined if the negation overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWNeg</code>.<br>
</div>
<pre><span id="VALconst_nuw_neg"><span class="keyword">val</span> const_nuw_neg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_neg c</code> returns the arithmetic negation of the constant <code class="code">c</code> with
    no unsigned wrapping. The result is undefined if the negation overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNUWNeg</code>.<br>
</div>
<pre><span id="VALconst_fneg"><span class="keyword">val</span> const_fneg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fneg c</code> returns the arithmetic negation of the constant float <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFNeg</code>.<br>
</div>
<pre><span id="VALconst_not"><span class="keyword">val</span> const_not</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_not c</code> returns the bitwise inverse of the constant <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNot</code>.<br>
</div>
<pre><span id="VALconst_add"><span class="keyword">val</span> const_add</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_add c1 c2</code> returns the constant sum of two constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAdd</code>.<br>
</div>
<pre><span id="VALconst_nsw_add"><span class="keyword">val</span> const_nsw_add</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_add c1 c2</code> returns the constant sum of two constants with no
    signed wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWAdd</code>.<br>
</div>
<pre><span id="VALconst_nuw_add"><span class="keyword">val</span> const_nuw_add</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_add c1 c2</code> returns the constant sum of two constants with no
    unsigned wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWAdd</code>.<br>
</div>
<pre><span id="VALconst_fadd"><span class="keyword">val</span> const_fadd</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fadd c1 c2</code> returns the constant sum of two constant floats.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFAdd</code>.<br>
</div>
<pre><span id="VALconst_sub"><span class="keyword">val</span> const_sub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sub c1 c2</code> returns the constant difference, <code class="code">c1 - c2</code>, of two
    constants. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSub</code>.<br>
</div>
<pre><span id="VALconst_nsw_sub"><span class="keyword">val</span> const_nsw_sub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_sub c1 c2</code> returns the constant difference of two constants with
    no signed wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWSub</code>.<br>
</div>
<pre><span id="VALconst_nuw_sub"><span class="keyword">val</span> const_nuw_sub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_sub c1 c2</code> returns the constant difference of two constants with
    no unsigned wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWSub</code>.<br>
</div>
<pre><span id="VALconst_fsub"><span class="keyword">val</span> const_fsub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fsub c1 c2</code> returns the constant difference, <code class="code">c1 - c2</code>, of two
    constant floats. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFSub</code>.<br>
</div>
<pre><span id="VALconst_mul"><span class="keyword">val</span> const_mul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_mul c1 c2</code> returns the constant product of two constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getMul</code>.<br>
</div>
<pre><span id="VALconst_nsw_mul"><span class="keyword">val</span> const_nsw_mul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_mul c1 c2</code> returns the constant product of two constants with
    no signed wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWMul</code>.<br>
</div>
<pre><span id="VALconst_nuw_mul"><span class="keyword">val</span> const_nuw_mul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_mul c1 c2</code> returns the constant product of two constants with
    no unsigned wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWMul</code>.<br>
</div>
<pre><span id="VALconst_fmul"><span class="keyword">val</span> const_fmul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fmul c1 c2</code> returns the constant product of two constants floats.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFMul</code>.<br>
</div>
<pre><span id="VALconst_udiv"><span class="keyword">val</span> const_udiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_udiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two unsigned
    integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getUDiv</code>.<br>
</div>
<pre><span id="VALconst_sdiv"><span class="keyword">val</span> const_sdiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sdiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two signed
    integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSDiv</code>.<br>
</div>
<pre><span id="VALconst_exact_sdiv"><span class="keyword">val</span> const_exact_sdiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_exact_sdiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two
    signed integer constants. The result is undefined if the result is rounded
    or overflows. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getExactSDiv</code>.<br>
</div>
<pre><span id="VALconst_fdiv"><span class="keyword">val</span> const_fdiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fdiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two floating
    point constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFDiv</code>.<br>
</div>
<pre><span id="VALconst_urem"><span class="keyword">val</span> const_urem</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_urem c1 c2</code> returns the constant remainder <code class="code">c1 <span class="constructor">MOD</span> c2</code> of two
    unsigned integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getURem</code>.<br>
</div>
<pre><span id="VALconst_srem"><span class="keyword">val</span> const_srem</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_srem c1 c2</code> returns the constant remainder <code class="code">c1 <span class="constructor">MOD</span> c2</code> of two
    signed integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSRem</code>.<br>
</div>
<pre><span id="VALconst_frem"><span class="keyword">val</span> const_frem</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_frem c1 c2</code> returns the constant remainder <code class="code">c1 <span class="constructor">MOD</span> c2</code> of two
    signed floating point constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFRem</code>.<br>
</div>
<pre><span id="VALconst_and"><span class="keyword">val</span> const_and</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_and c1 c2</code> returns the constant bitwise <code class="code"><span class="constructor">AND</span></code> of two integer
    constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAnd</code>.<br>
</div>
<pre><span id="VALconst_or"><span class="keyword">val</span> const_or</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_or c1 c2</code> returns the constant bitwise <code class="code"><span class="constructor">OR</span></code> of two integer
    constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getOr</code>.<br>
</div>
<pre><span id="VALconst_xor"><span class="keyword">val</span> const_xor</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_xor c1 c2</code> returns the constant bitwise <code class="code"><span class="constructor">XOR</span></code> of two integer
    constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getXor</code>.<br>
</div>
<pre><span id="VALconst_icmp"><span class="keyword">val</span> const_icmp</span> : <code class="type"><a href="Llvm.Icmp.html#TYPEt">Icmp.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_icmp pred c1 c2</code> returns the constant comparison of two integer
    constants, <code class="code">c1 pred c2</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getICmp</code>.<br>
</div>
<pre><span id="VALconst_fcmp"><span class="keyword">val</span> const_fcmp</span> : <code class="type"><a href="Llvm.Fcmp.html#TYPEt">Fcmp.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fcmp pred c1 c2</code> returns the constant comparison of two floating
    point constants, <code class="code">c1 pred c2</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFCmp</code>.<br>
</div>
<pre><span id="VALconst_shl"><span class="keyword">val</span> const_shl</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_shl c1 c2</code> returns the constant integer <code class="code">c1</code> left-shifted by the
    constant integer <code class="code">c2</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getShl</code>.<br>
</div>
<pre><span id="VALconst_lshr"><span class="keyword">val</span> const_lshr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_lshr c1 c2</code> returns the constant integer <code class="code">c1</code> right-shifted by the
    constant integer <code class="code">c2</code> with zero extension.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getLShr</code>.<br>
</div>
<pre><span id="VALconst_ashr"><span class="keyword">val</span> const_ashr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_ashr c1 c2</code> returns the constant integer <code class="code">c1</code> right-shifted by the
    constant integer <code class="code">c2</code> with sign extension.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAShr</code>.<br>
</div>
<pre><span id="VALconst_gep"><span class="keyword">val</span> const_gep</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_gep pc indices</code> returns the constant <code class="code">getElementPtr</code> of <code class="code">p1</code> with the
    constant integers indices from the array <code class="code">indices</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getGetElementPtr</code>.<br>
</div>
<pre><span id="VALconst_in_bounds_gep"><span class="keyword">val</span> const_in_bounds_gep</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_in_bounds_gep pc indices</code> returns the constant <code class="code">getElementPtr</code> of <code class="code">p1</code>
    with the constant integers indices from the array <code class="code">indices</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getInBoundsGetElementPtr</code>.<br>
</div>
<pre><span id="VALconst_trunc"><span class="keyword">val</span> const_trunc</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_trunc c ty</code> returns the constant truncation of integer constant <code class="code">c</code>
    to the smaller integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getTrunc</code>.<br>
</div>
<pre><span id="VALconst_sext"><span class="keyword">val</span> const_sext</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sext c ty</code> returns the constant sign extension of integer constant
    <code class="code">c</code> to the larger integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSExt</code>.<br>
</div>
<pre><span id="VALconst_zext"><span class="keyword">val</span> const_zext</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_zext c ty</code> returns the constant zero extension of integer constant
    <code class="code">c</code> to the larger integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getZExt</code>.<br>
</div>
<pre><span id="VALconst_fptrunc"><span class="keyword">val</span> const_fptrunc</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fptrunc c ty</code> returns the constant truncation of floating point
    constant <code class="code">c</code> to the smaller floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPTrunc</code>.<br>
</div>
<pre><span id="VALconst_fpext"><span class="keyword">val</span> const_fpext</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fpext c ty</code> returns the constant extension of floating point constant
    <code class="code">c</code> to the larger floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPExt</code>.<br>
</div>
<pre><span id="VALconst_uitofp"><span class="keyword">val</span> const_uitofp</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_uitofp c ty</code> returns the constant floating point conversion of
    unsigned integer constant <code class="code">c</code> to the floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getUIToFP</code>.<br>
</div>
<pre><span id="VALconst_sitofp"><span class="keyword">val</span> const_sitofp</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sitofp c ty</code> returns the constant floating point conversion of
    signed integer constant <code class="code">c</code> to the floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSIToFP</code>.<br>
</div>
<pre><span id="VALconst_fptoui"><span class="keyword">val</span> const_fptoui</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fptoui c ty</code> returns the constant unsigned integer conversion of
    floating point constant <code class="code">c</code> to integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPToUI</code>.<br>
</div>
<pre><span id="VALconst_fptosi"><span class="keyword">val</span> const_fptosi</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fptoui c ty</code> returns the constant unsigned integer conversion of
    floating point constant <code class="code">c</code> to integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPToSI</code>.<br>
</div>
<pre><span id="VALconst_ptrtoint"><span class="keyword">val</span> const_ptrtoint</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_ptrtoint c ty</code> returns the constant integer conversion of
    pointer constant <code class="code">c</code> to integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getPtrToInt</code>.<br>
</div>
<pre><span id="VALconst_inttoptr"><span class="keyword">val</span> const_inttoptr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_inttoptr c ty</code> returns the constant pointer conversion of
    integer constant <code class="code">c</code> to pointer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getIntToPtr</code>.<br>
</div>
<pre><span id="VALconst_bitcast"><span class="keyword">val</span> const_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_bitcast c ty</code> returns the constant bitwise conversion of constant <code class="code">c</code>
    to type <code class="code">ty</code> of equal size.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getBitCast</code>.<br>
</div>
<pre><span id="VALconst_zext_or_bitcast"><span class="keyword">val</span> const_zext_or_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_zext_or_bitcast c ty</code> returns a constant zext or bitwise cast
    conversion of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getZExtOrBitCast</code>.<br>
</div>
<pre><span id="VALconst_sext_or_bitcast"><span class="keyword">val</span> const_sext_or_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sext_or_bitcast c ty</code> returns a constant sext or bitwise cast
    conversion of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSExtOrBitCast</code>.<br>
</div>
<pre><span id="VALconst_trunc_or_bitcast"><span class="keyword">val</span> const_trunc_or_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_trunc_or_bitcast c ty</code> returns a constant trunc or bitwise cast
    conversion of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getTruncOrBitCast</code>.<br>
</div>
<pre><span id="VALconst_pointercast"><span class="keyword">val</span> const_pointercast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_pointercast c ty</code> returns a constant bitcast or a pointer-to-int
    cast conversion of constant <code class="code">c</code> to type <code class="code">ty</code> of equal size.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getPointerCast</code>.<br>
</div>
<pre><span id="VALconst_intcast"><span class="keyword">val</span> const_intcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_intcast c ty</code> returns a constant zext, bitcast, or trunc for integer
    -&gt; integer casts of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getIntCast</code>.<br>
</div>
<pre><span id="VALconst_fpcast"><span class="keyword">val</span> const_fpcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fpcast c ty</code> returns a constant fpext, bitcast, or fptrunc for fp -&gt;
    fp casts of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPCast</code>.<br>
</div>
<pre><span id="VALconst_select"><span class="keyword">val</span> const_select</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_select cond t f</code> returns the constant conditional which returns value
    <code class="code">t</code> if the boolean constant <code class="code">cond</code> is true and the value <code class="code">f</code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSelect</code>.<br>
</div>
<pre><span id="VALconst_extractelement"><span class="keyword">val</span> const_extractelement</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_extractelement vec i</code> returns the constant <code class="code">i</code>th element of
    constant vector <code class="code">vec</code>. <code class="code">i</code> must be a constant <code class="code">i32</code> value unsigned less than
    the size of the vector.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getExtractElement</code>.<br>
</div>
<pre><span id="VALconst_insertelement"><span class="keyword">val</span> const_insertelement</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_insertelement vec v i</code> returns the constant vector with the same
    elements as constant vector <code class="code">v</code> but the <code class="code">i</code>th element replaced by the
    constant <code class="code">v</code>. <code class="code">v</code> must be a constant value with the type of the vector
    elements. <code class="code">i</code> must be a constant <code class="code">i32</code> value unsigned less than the size
    of the vector.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getInsertElement</code>.<br>
</div>
<pre><span id="VALconst_shufflevector"><span class="keyword">val</span> const_shufflevector</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_shufflevector a b mask</code> returns a constant <code class="code">shufflevector</code>.
    See the LLVM Language Reference for details on the <code class="code">shufflevector</code>
    instruction.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getShuffleVector</code>.<br>
</div>
<pre><span id="VALconst_extractvalue"><span class="keyword">val</span> const_extractvalue</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_extractvalue agg idxs</code> returns the constant <code class="code">idxs</code>th value of
    constant aggregate <code class="code">agg</code>. Each <code class="code">idxs</code> must be less than the size of the
    aggregate.  See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getExtractValue</code>.<br>
</div>
<pre><span id="VALconst_insertvalue"><span class="keyword">val</span> const_insertvalue</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> int array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_insertvalue agg <span class="keyword">val</span> idxs</code> inserts the value <code class="code"><span class="keyword">val</span></code> in the specified
    indexs <code class="code">idxs</code> in the aggegate <code class="code">agg</code>. Each <code class="code">idxs</code> must be less than the size
    of the aggregate. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getInsertValue</code>.<br>
</div>
<pre><span id="VALconst_inline_asm"><span class="keyword">val</span> const_inline_asm</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> string -> bool -> bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_inline_asm ty asm con side align</code> inserts a inline assembly string.
    See the method <code class="code">llvm::<span class="constructor">InlineAsm</span>::get</code>.<br>
</div>
<pre><span id="VALblock_address"><span class="keyword">val</span> block_address</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">block_address f bb</code> returns the address of the basic block <code class="code">bb</code> in the
    function <code class="code">f</code>. See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::get</code>.<br>
</div>
<br>
<span id="7_Operationsonglobalvariablesfunctionsandaliasesglobals"><div class="h7">Operations on global variables, functions, and aliases (globals)</div></span><br>
<pre><span id="VALglobal_parent"><span class="keyword">val</span> global_parent</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a></code></pre><div class="info">
<code class="code">global_parent g</code> is the enclosing module of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getParent</code>.<br>
</div>
<pre><span id="VALis_declaration"><span class="keyword">val</span> is_declaration</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_declaration g</code> returns <code class="code"><span class="keyword">true</span></code> if the global value <code class="code">g</code> is a declaration
    only. Returns <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::isDeclaration</code>.<br>
</div>
<pre><span id="VALlinkage"><span class="keyword">val</span> linkage</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Linkage.html#TYPEt">Linkage.t</a></code></pre><div class="info">
<code class="code">linkage g</code> returns the linkage of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getLinkage</code>.<br>
</div>
<pre><span id="VALset_linkage"><span class="keyword">val</span> set_linkage</span> : <code class="type"><a href="Llvm.Linkage.html#TYPEt">Linkage.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_linkage l g</code> sets the linkage of the global value <code class="code">g</code> to <code class="code">l</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setLinkage</code>.<br>
</div>
<pre><span id="VALsection"><span class="keyword">val</span> section</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string</code></pre><div class="info">
<code class="code">section g</code> returns the linker section of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getSection</code>.<br>
</div>
<pre><span id="VALset_section"><span class="keyword">val</span> set_section</span> : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_section s g</code> sets the linker section of the global value <code class="code">g</code> to <code class="code">s</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setSection</code>.<br>
</div>
<pre><span id="VALvisibility"><span class="keyword">val</span> visibility</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Visibility.html#TYPEt">Visibility.t</a></code></pre><div class="info">
<code class="code">visibility g</code> returns the linker visibility of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getVisibility</code>.<br>
</div>
<pre><span id="VALset_visibility"><span class="keyword">val</span> set_visibility</span> : <code class="type"><a href="Llvm.Visibility.html#TYPEt">Visibility.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_visibility v g</code> sets the linker visibility of the global value <code class="code">g</code> to
    <code class="code">v</code>. See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setVisibility</code>.<br>
</div>
<pre><span id="VALalignment"><span class="keyword">val</span> alignment</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">alignment g</code> returns the required alignment of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getAlignment</code>.<br>
</div>
<pre><span id="VALset_alignment"><span class="keyword">val</span> set_alignment</span> : <code class="type">int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_alignment n g</code> sets the required alignment of the global value <code class="code">g</code> to
    <code class="code">n</code> bytes. See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setAlignment</code>.<br>
</div>
<br>
<span id="7_Operationsonglobalvariables"><div class="h7">Operations on global variables</div></span><br>
<pre><span id="VALdeclare_global"><span class="keyword">val</span> declare_global</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">declare_global ty name m</code> returns a new global variable of type <code class="code">ty</code> and
    with name <code class="code">name</code> in module <code class="code">m</code> in the default address space (0). If such a
    global variable already exists, it is returned. If the type of the existing
    global differs, then a bitcast to <code class="code">ty</code> is returned.<br>
</div>
<pre><span id="VALdeclare_qualified_global"><span class="keyword">val</span> declare_qualified_global</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> int -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">declare_qualified_global ty name addrspace m</code> returns a new global variable
    of type <code class="code">ty</code> and with name <code class="code">name</code> in module <code class="code">m</code> in the address space
    <code class="code">addrspace</code>. If such a global variable already exists, it is returned. If
    the type of the existing global differs, then a bitcast to <code class="code">ty</code> is
    returned.<br>
</div>
<pre><span id="VALdefine_global"><span class="keyword">val</span> define_global</span> : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">define_global name init m</code> returns a new global with name <code class="code">name</code> and
    initializer <code class="code">init</code> in module <code class="code">m</code> in the default address space (0). If the
    named global already exists, it is renamed.
    See the constructor of <code class="code">llvm::<span class="constructor">GlobalVariable</span></code>.<br>
</div>
<pre><span id="VALdefine_qualified_global"><span class="keyword">val</span> define_qualified_global</span> : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">define_qualified_global name init addrspace m</code> returns a new global with
    name <code class="code">name</code> and initializer <code class="code">init</code> in module <code class="code">m</code> in the address space
    <code class="code">addrspace</code>. If the named global already exists, it is renamed.
    See the constructor of <code class="code">llvm::<span class="constructor">GlobalVariable</span></code>.<br>
</div>
<pre><span id="VALlookup_global"><span class="keyword">val</span> lookup_global</span> : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">lookup_global name m</code> returns <code class="code"><span class="constructor">Some</span> g</code> if a global variable with name
    <code class="code">name</code> exists in module <code class="code">m</code>. If no such global exists, returns <code class="code"><span class="constructor">None</span></code>.
    See the <code class="code">llvm::<span class="constructor">GlobalVariable</span></code> constructor.<br>
</div>
<pre><span id="VALdelete_global"><span class="keyword">val</span> delete_global</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">delete_global gv</code> destroys the global variable <code class="code">gv</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::eraseFromParent</code>.<br>
</div>
<pre><span id="VALglobal_begin"><span class="keyword">val</span> global_begin</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">global_begin m</code> returns the first position in the global variable list of
    the module <code class="code">m</code>. <code class="code">global_begin</code> and <code class="code">global_succ</code> can be used to iterate
    over the global list in order.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_begin</code>.<br>
</div>
<pre><span id="VALglobal_succ"><span class="keyword">val</span> global_succ</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">global_succ gv</code> returns the global variable list position succeeding
    <code class="code"><span class="constructor">Before</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_iterator::operator++</code>.<br>
</div>
<pre><span id="VALiter_globals"><span class="keyword">val</span> iter_globals</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">iter_globals f m</code> applies function <code class="code">f</code> to each of the global variables of
    module <code class="code">m</code> in order. Tail recursive.<br>
</div>
<pre><span id="VALfold_left_globals"><span class="keyword">val</span> fold_left_globals</span> : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_globals f init m</code> is <code class="code">f (... (f init g1) ...) gN</code> where
    <code class="code">g1,...,gN</code> are the global variables of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span id="VALglobal_end"><span class="keyword">val</span> global_end</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">global_end m</code> returns the last position in the global variable list of the
    module <code class="code">m</code>. <code class="code">global_end</code> and <code class="code">global_pred</code> can be used to iterate over the
    global list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_end</code>.<br>
</div>
<pre><span id="VALglobal_pred"><span class="keyword">val</span> global_pred</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">global_pred gv</code> returns the global variable list position preceding
    <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_iterator::operator--</code>.<br>
</div>
<pre><span id="VALrev_iter_globals"><span class="keyword">val</span> rev_iter_globals</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_globals f m</code> applies function <code class="code">f</code> to each of the global variables
    of module <code class="code">m</code> in reverse order. Tail recursive.<br>
</div>
<pre><span id="VALfold_right_globals"><span class="keyword">val</span> fold_right_globals</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_globals f m init</code> is <code class="code">f g1 (... (f gN init) ...)</code> where
    <code class="code">g1,...,gN</code> are the global variables of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span id="VALis_global_constant"><span class="keyword">val</span> is_global_constant</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_global_constant gv</code> returns <code class="code"><span class="keyword">true</span></code> if the global variabile <code class="code">gv</code> is a
    constant. Returns <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::isConstant</code>.<br>
</div>
<pre><span id="VALset_global_constant"><span class="keyword">val</span> set_global_constant</span> : <code class="type">bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_global_constant c gv</code> sets the global variable <code class="code">gv</code> to be a constant if
    <code class="code">c</code> is <code class="code"><span class="keyword">true</span></code> and not if <code class="code">c</code> is <code class="code"><span class="keyword">false</span></code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setConstant</code>.<br>
</div>
<pre><span id="VALglobal_initializer"><span class="keyword">val</span> global_initializer</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">global_initializer gv</code> returns the initializer for the global variable
    <code class="code">gv</code>. See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::getInitializer</code>.<br>
</div>
<pre><span id="VALset_initializer"><span class="keyword">val</span> set_initializer</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_initializer c gv</code> sets the initializer for the global variable
    <code class="code">gv</code> to the constant <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setInitializer</code>.<br>
</div>
<pre><span id="VALremove_initializer"><span class="keyword">val</span> remove_initializer</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">remove_initializer gv</code> unsets the initializer for the global variable
    <code class="code">gv</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setInitializer</code>.<br>
</div>
<pre><span id="VALis_thread_local"><span class="keyword">val</span> is_thread_local</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_thread_local gv</code> returns <code class="code"><span class="keyword">true</span></code> if the global variable <code class="code">gv</code> is
    thread-local and <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::isThreadLocal</code>.<br>
</div>
<pre><span id="VALset_thread_local"><span class="keyword">val</span> set_thread_local</span> : <code class="type">bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_thread_local c gv</code> sets the global variable <code class="code">gv</code> to be thread local if
    <code class="code">c</code> is <code class="code"><span class="keyword">true</span></code> and not otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setThreadLocal</code>.<br>
</div>
<br>
<span id="7_Operationsonaliases"><div class="h7">Operations on aliases</div></span><br>
<pre><span id="VALadd_alias"><span class="keyword">val</span> add_alias</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">add_alias m t a n</code> inserts an alias in the module <code class="code">m</code> with the type <code class="code">t</code> and
    the aliasee <code class="code">a</code> with the name <code class="code">n</code>.
    See the constructor for <code class="code">llvm::<span class="constructor">GlobalAlias</span></code>.<br>
</div>
<br>
<span id="7_Operationsonfunctions"><div class="h7">Operations on functions</div></span><br>
<pre><span id="VALdeclare_function"><span class="keyword">val</span> declare_function</span> : <code class="type">string -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">declare_function name ty m</code> returns a new function of type <code class="code">ty</code> and
    with name <code class="code">name</code> in module <code class="code">m</code>. If such a function already exists,
    it is returned. If the type of the existing function differs, then a bitcast
    to <code class="code">ty</code> is returned.<br>
</div>
<pre><span id="VALdefine_function"><span class="keyword">val</span> define_function</span> : <code class="type">string -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">define_function name ty m</code> creates a new function with name <code class="code">name</code> and
    type <code class="code">ty</code> in module <code class="code">m</code>. If the named function already exists, it is
    renamed. An entry basic block is created in the function.
    See the constructor of <code class="code">llvm::<span class="constructor">GlobalVariable</span></code>.<br>
</div>
<pre><span id="VALlookup_function"><span class="keyword">val</span> lookup_function</span> : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">lookup_function name m</code> returns <code class="code"><span class="constructor">Some</span> f</code> if a function with name
    <code class="code">name</code> exists in module <code class="code">m</code>. If no such function exists, returns <code class="code"><span class="constructor">None</span></code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span></code> constructor.<br>
</div>
<pre><span id="VALdelete_function"><span class="keyword">val</span> delete_function</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">delete_function f</code> destroys the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::eraseFromParent</code>.<br>
</div>
<pre><span id="VALfunction_begin"><span class="keyword">val</span> function_begin</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">function_begin m</code> returns the first position in the function list of the
    module <code class="code">m</code>. <code class="code">function_begin</code> and <code class="code">function_succ</code> can be used to iterate over
    the function list in order.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::<span class="keyword">begin</span></code>.<br>
</div>
<pre><span id="VALfunction_succ"><span class="keyword">val</span> function_succ</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">function_succ gv</code> returns the function list position succeeding
    <code class="code"><span class="constructor">Before</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::iterator::operator++</code>.<br>
</div>
<pre><span id="VALiter_functions"><span class="keyword">val</span> iter_functions</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">iter_functions f m</code> applies function <code class="code">f</code> to each of the functions of module
    <code class="code">m</code> in order. Tail recursive.<br>
</div>
<pre><span id="VALfold_left_functions"><span class="keyword">val</span> fold_left_functions</span> : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_function f init m</code> is <code class="code">f (... (f init f1) ...) fN</code> where
    <code class="code">f1,...,fN</code> are the functions of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span id="VALfunction_end"><span class="keyword">val</span> function_end</span> : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">function_end m</code> returns the last position in the function list of
    the module <code class="code">m</code>. <code class="code">function_end</code> and <code class="code">function_pred</code> can be used to iterate
    over the function list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::<span class="keyword">end</span></code>.<br>
</div>
<pre><span id="VALfunction_pred"><span class="keyword">val</span> function_pred</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">function_pred gv</code> returns the function list position preceding <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::iterator::operator--</code>.<br>
</div>
<pre><span id="VALrev_iter_functions"><span class="keyword">val</span> rev_iter_functions</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_functions f fn</code> applies function <code class="code">f</code> to each of the functions of
    module <code class="code">m</code> in reverse order. Tail recursive.<br>
</div>
<pre><span id="VALfold_right_functions"><span class="keyword">val</span> fold_right_functions</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_functions f m init</code> is <code class="code">f (... (f init fN) ...) f1</code> where
    <code class="code">f1,...,fN</code> are the functions of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span id="VALis_intrinsic"><span class="keyword">val</span> is_intrinsic</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_intrinsic f</code> returns true if the function <code class="code">f</code> is an intrinsic.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::isIntrinsic</code>.<br>
</div>
<pre><span id="VALfunction_call_conv"><span class="keyword">val</span> function_call_conv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">function_call_conv f</code> returns the calling convention of the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getCallingConv</code>.<br>
</div>
<pre><span id="VALset_function_call_conv"><span class="keyword">val</span> set_function_call_conv</span> : <code class="type">int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_function_call_conv cc f</code> sets the calling convention of the function
    <code class="code">f</code> to the calling convention numbered <code class="code">cc</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::setCallingConv</code>.<br>
</div>
<pre><span id="VALgc"><span class="keyword">val</span> gc</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string option</code></pre><div class="info">
<code class="code">gc f</code> returns <code class="code"><span class="constructor">Some</span> name</code> if the function <code class="code">f</code> has a garbage
    collection algorithm specified and <code class="code"><span class="constructor">None</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getGC</code>.<br>
</div>
<pre><span id="VALset_gc"><span class="keyword">val</span> set_gc</span> : <code class="type">string option -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_gc gc f</code> sets the collection algorithm for the function <code class="code">f</code> to
    <code class="code">gc</code>. See the method <code class="code">llvm::<span class="constructor">Function</span>::setGC</code>.<br>
</div>
<pre><span id="VALadd_function_attr"><span class="keyword">val</span> add_function_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">add_function_attr f a</code> adds attribute <code class="code">a</code> to the return type of function
    <code class="code">f</code>.<br>
</div>
<pre><span id="VALfunction_attr"><span class="keyword">val</span> function_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> list</code></pre><div class="info">
<code class="code">function_attr f</code> returns the function attribute for the function <code class="code">f</code>.
 * See the method <code class="code">llvm::<span class="constructor">Function</span>::getAttributes</code><br>
</div>
<pre><span id="VALremove_function_attr"><span class="keyword">val</span> remove_function_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">remove_function_attr f a</code> removes attribute <code class="code">a</code> from the return type of
    function <code class="code">f</code>.<br>
</div>
<br>
<span id="7_Operationsonparams"><div class="h7">Operations on params</div></span><br>
<pre><span id="VALparams"><span class="keyword">val</span> params</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array</code></pre><div class="info">
<code class="code">params f</code> returns the parameters of function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getArgumentList</code>.<br>
</div>
<pre><span id="VALparam"><span class="keyword">val</span> param</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">param f n</code> returns the <code class="code">n</code>th parameter of function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getArgumentList</code>.<br>
</div>
<pre><span id="VALparam_attr"><span class="keyword">val</span> param_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> list</code></pre><div class="info">
<code class="code">param_attr p</code> returns the attributes of parameter <code class="code">p</code>.
 * See the methods <code class="code">llvm::<span class="constructor">Function</span>::getAttributes</code> and
 * <code class="code">llvm::<span class="constructor">Attributes</span>::getParamAttributes</code><br>
</div>
<pre><span id="VALparam_parent"><span class="keyword">val</span> param_parent</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">param_parent p</code> returns the parent function that owns the parameter.
    See the method <code class="code">llvm::<span class="constructor">Argument</span>::getParent</code>.<br>
</div>
<pre><span id="VALparam_begin"><span class="keyword">val</span> param_begin</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">param_begin f</code> returns the first position in the parameter list of the
    function <code class="code">f</code>. <code class="code">param_begin</code> and <code class="code">param_succ</code> can be used to iterate over
    the parameter list in order.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_begin</code>.<br>
</div>
<pre><span id="VALparam_succ"><span class="keyword">val</span> param_succ</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">param_succ bb</code> returns the parameter list position succeeding
    <code class="code"><span class="constructor">Before</span> bb</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_iterator::operator++</code>.<br>
</div>
<pre><span id="VALiter_params"><span class="keyword">val</span> iter_params</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">iter_params f fn</code> applies function <code class="code">f</code> to each of the parameters
    of function <code class="code">fn</code> in order. Tail recursive.<br>
</div>
<pre><span id="VALfold_left_params"><span class="keyword">val</span> fold_left_params</span> : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_params f init fn</code> is <code class="code">f (... (f init b1) ...) bN</code> where
    <code class="code">b1,...,bN</code> are the parameters of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span id="VALparam_end"><span class="keyword">val</span> param_end</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">param_end f</code> returns the last position in the parameter list of
    the function <code class="code">f</code>. <code class="code">param_end</code> and <code class="code">param_pred</code> can be used to iterate
    over the parameter list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_end</code>.<br>
</div>
<pre><span id="VALparam_pred"><span class="keyword">val</span> param_pred</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">param_pred gv</code> returns the function list position preceding <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_iterator::operator--</code>.<br>
</div>
<pre><span id="VALrev_iter_params"><span class="keyword">val</span> rev_iter_params</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_params f fn</code> applies function <code class="code">f</code> to each of the parameters
    of function <code class="code">fn</code> in reverse order. Tail recursive.<br>
</div>
<pre><span id="VALfold_right_params"><span class="keyword">val</span> fold_right_params</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_params f fn init</code> is <code class="code">f (... (f init bN) ...) b1</code> where
    <code class="code">b1,...,bN</code> are the parameters of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span id="VALadd_param_attr"><span class="keyword">val</span> add_param_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">add_param p a</code> adds attribute <code class="code">a</code> to parameter <code class="code">p</code>.<br>
</div>
<pre><span id="VALremove_param_attr"><span class="keyword">val</span> remove_param_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">remove_param_attr p a</code> removes attribute <code class="code">a</code> from parameter <code class="code">p</code>.<br>
</div>
<pre><span id="VALset_param_alignment"><span class="keyword">val</span> set_param_alignment</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> unit</code></pre><div class="info">
<code class="code">set_param_alignment p a</code> set the alignment of parameter <code class="code">p</code> to <code class="code">a</code>.<br>
</div>
<br>
<span id="7_Operationsonbasicblocks"><div class="h7">Operations on basic blocks</div></span><br>
<pre><span id="VALbasic_blocks"><span class="keyword">val</span> basic_blocks</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> array</code></pre><div class="info">
<code class="code">basic_blocks fn</code> returns the basic blocks of the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getBasicBlockList</code>.<br>
</div>
<pre><span id="VALentry_block"><span class="keyword">val</span> entry_block</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">entry_block fn</code> returns the entry basic block of the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getEntryBlock</code>.<br>
</div>
<pre><span id="VALdelete_block"><span class="keyword">val</span> delete_block</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">delete_block bb</code> deletes the basic block <code class="code">bb</code>.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::eraseFromParent</code>.<br>
</div>
<pre><span id="VALappend_block"><span class="keyword">val</span> append_block</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">append_block c name f</code> creates a new basic block named <code class="code">name</code> at the end of
    function <code class="code">f</code> in the context <code class="code">c</code>.
    See the constructor of <code class="code">llvm::<span class="constructor">BasicBlock</span></code>.<br>
</div>
<pre><span id="VALinsert_block"><span class="keyword">val</span> insert_block</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">insert_block c name bb</code> creates a new basic block named <code class="code">name</code> before the
    basic block <code class="code">bb</code> in the context <code class="code">c</code>.
    See the constructor of <code class="code">llvm::<span class="constructor">BasicBlock</span></code>.<br>
</div>
<pre><span id="VALblock_parent"><span class="keyword">val</span> block_parent</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">block_parent bb</code> returns the parent function that owns the basic block.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::getParent</code>.<br>
</div>
<pre><span id="VALblock_begin"><span class="keyword">val</span> block_begin</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">block_begin f</code> returns the first position in the basic block list of the
    function <code class="code">f</code>. <code class="code">block_begin</code> and <code class="code">block_succ</code> can be used to iterate over
    the basic block list in order.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::<span class="keyword">begin</span></code>.<br>
</div>
<pre><span id="VALblock_succ"><span class="keyword">val</span> block_succ</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">block_succ bb</code> returns the basic block list position succeeding
    <code class="code"><span class="constructor">Before</span> bb</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::iterator::operator++</code>.<br>
</div>
<pre><span id="VALiter_blocks"><span class="keyword">val</span> iter_blocks</span> : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">iter_blocks f fn</code> applies function <code class="code">f</code> to each of the basic blocks
    of function <code class="code">fn</code> in order. Tail recursive.<br>
</div>
<pre><span id="VALfold_left_blocks"><span class="keyword">val</span> fold_left_blocks</span> : <code class="type">('a -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_blocks f init fn</code> is <code class="code">f (... (f init b1) ...) bN</code> where
    <code class="code">b1,...,bN</code> are the basic blocks of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span id="VALblock_end"><span class="keyword">val</span> block_end</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">block_end f</code> returns the last position in the basic block list of
    the function <code class="code">f</code>. <code class="code">block_end</code> and <code class="code">block_pred</code> can be used to iterate
    over the basic block list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::<span class="keyword">end</span></code>.<br>
</div>
<pre><span id="VALblock_pred"><span class="keyword">val</span> block_pred</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">block_pred gv</code> returns the function list position preceding <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::iterator::operator--</code>.<br>
</div>
<pre><span id="VALblock_terminator"><span class="keyword">val</span> block_terminator</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><pre><span id="VALrev_iter_blocks"><span class="keyword">val</span> rev_iter_blocks</span> : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_blocks f fn</code> applies function <code class="code">f</code> to each of the basic blocks
    of function <code class="code">fn</code> in reverse order. Tail recursive.<br>
</div>
<pre><span id="VALfold_right_blocks"><span class="keyword">val</span> fold_right_blocks</span> : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_blocks f fn init</code> is <code class="code">f (... (f init bN) ...) b1</code> where
    <code class="code">b1,...,bN</code> are the basic blocks of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span id="VALvalue_of_block"><span class="keyword">val</span> value_of_block</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">value_of_block bb</code> losslessly casts <code class="code">bb</code> to an <code class="code">llvalue</code>.<br>
</div>
<pre><span id="VALvalue_is_block"><span class="keyword">val</span> value_is_block</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">value_is_block v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is a basic block and
    <code class="code"><span class="keyword">false</span></code> otherwise.
    Similar to <code class="code">llvm::isa&lt;<span class="constructor">BasicBlock</span>&gt;</code>.<br>
</div>
<pre><span id="VALblock_of_value"><span class="keyword">val</span> block_of_value</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">block_of_value v</code> losslessly casts <code class="code">v</code> to an <code class="code">llbasicblock</code>.<br>
</div>
<br>
<span id="7_Operationsoninstructions"><div class="h7">Operations on instructions</div></span><br>
<pre><span id="VALinstr_parent"><span class="keyword">val</span> instr_parent</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">instr_parent i</code> is the enclosing basic block of the instruction <code class="code">i</code>.
    See the method <code class="code">llvm::<span class="constructor">Instruction</span>::getParent</code>.<br>
</div>
<pre><span id="VALinstr_begin"><span class="keyword">val</span> instr_begin</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">instr_begin bb</code> returns the first position in the instruction list of the
    basic block <code class="code">bb</code>. <code class="code">instr_begin</code> and <code class="code">instr_succ</code> can be used to iterate over
    the instruction list in order.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::<span class="keyword">begin</span></code>.<br>
</div>
<pre><span id="VALinstr_succ"><span class="keyword">val</span> instr_succ</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">instr_succ i</code> returns the instruction list position succeeding <code class="code"><span class="constructor">Before</span> i</code>.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::iterator::operator++</code>.<br>
</div>
<pre><span id="VALiter_instrs"><span class="keyword">val</span> iter_instrs</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">iter_instrs f bb</code> applies function <code class="code">f</code> to each of the instructions of basic
    block <code class="code">bb</code> in order. Tail recursive.<br>
</div>
<pre><span id="VALfold_left_instrs"><span class="keyword">val</span> fold_left_instrs</span> : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_instrs f init bb</code> is <code class="code">f (... (f init g1) ...) gN</code> where
    <code class="code">g1,...,gN</code> are the instructions of basic block <code class="code">bb</code>. Tail recursive.<br>
</div>
<pre><span id="VALinstr_end"><span class="keyword">val</span> instr_end</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">instr_end bb</code> returns the last position in the instruction list of the
    basic block <code class="code">bb</code>. <code class="code">instr_end</code> and <code class="code">instr_pred</code> can be used to iterate over
    the instruction list in reverse.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::<span class="keyword">end</span></code>.<br>
</div>
<pre><span id="VALinstr_pred"><span class="keyword">val</span> instr_pred</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">instr_pred i</code> returns the instruction list position preceding <code class="code"><span class="constructor">After</span> i</code>.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::iterator::operator--</code>.<br>
</div>
<pre><span id="VALfold_right_instrs"><span class="keyword">val</span> fold_right_instrs</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_instrs f bb init</code> is <code class="code">f (... (f init fN) ...) f1</code> where
    <code class="code">f1,...,fN</code> are the instructions of basic block <code class="code">bb</code>. Tail recursive.<br>
</div>
<pre><span id="VALinstr_opcode"><span class="keyword">val</span> instr_opcode</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Opcode.html#TYPEt">Opcode.t</a></code></pre><pre><span id="VALicmp_predicate"><span class="keyword">val</span> icmp_predicate</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Icmp.html#TYPEt">Icmp.t</a> option</code></pre><br>
<span id="7_Operationsoncallsites"><div class="h7">Operations on call sites</div></span><br>
<pre><span id="VALinstruction_call_conv"><span class="keyword">val</span> instruction_call_conv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">instruction_call_conv ci</code> is the calling convention for the call or invoke
    instruction <code class="code">ci</code>, which may be one of the values from the module
    <a href="Llvm.CallConv.html"><code class="code"><span class="constructor">Llvm</span>.<span class="constructor">CallConv</span></code></a>. See the method <code class="code">llvm::<span class="constructor">CallInst</span>::getCallingConv</code> and
    <code class="code">llvm::<span class="constructor">InvokeInst</span>::getCallingConv</code>.<br>
</div>
<pre><span id="VALset_instruction_call_conv"><span class="keyword">val</span> set_instruction_call_conv</span> : <code class="type">int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_instruction_call_conv cc ci</code> sets the calling convention for the call
    or invoke instruction <code class="code">ci</code> to the integer <code class="code">cc</code>, which can be one of the
    values from the module <a href="Llvm.CallConv.html"><code class="code"><span class="constructor">Llvm</span>.<span class="constructor">CallConv</span></code></a>.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::setCallingConv</code>
    and <code class="code">llvm::<span class="constructor">InvokeInst</span>::setCallingConv</code>.<br>
</div>
<pre><span id="VALadd_instruction_param_attr"><span class="keyword">val</span> add_instruction_param_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">add_instruction_param_attr ci i a</code> adds attribute <code class="code">a</code> to the <code class="code">i</code>th
    parameter of the call or invoke instruction <code class="code">ci</code>. <code class="code">i</code>=0 denotes the return
    value.<br>
</div>
<pre><span id="VALremove_instruction_param_attr"><span class="keyword">val</span> remove_instruction_param_attr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">remove_instruction_param_attr ci i a</code> removes attribute <code class="code">a</code> from the
    <code class="code">i</code>th parameter of the call or invoke instruction <code class="code">ci</code>. <code class="code">i</code>=0 denotes the
    return value.<br>
</div>
<br>
<br>
<pre><span id="VALis_tail_call"><span class="keyword">val</span> is_tail_call</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_tail_call ci</code> is <code class="code"><span class="keyword">true</span></code> if the call instruction <code class="code">ci</code> is flagged as
    eligible for tail call optimization, <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::isTailCall</code>.<br>
</div>
<pre><span id="VALset_tail_call"><span class="keyword">val</span> set_tail_call</span> : <code class="type">bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_tail_call tc ci</code> flags the call instruction <code class="code">ci</code> as eligible for tail
    call optimization if <code class="code">tc</code> is <code class="code"><span class="keyword">true</span></code>, clears otherwise.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::setTailCall</code>.<br>
</div>
<br>
<span id="7_Operationsonphinodes"><div class="h7">Operations on phi nodes</div></span><br>
<pre><span id="VALadd_incoming"><span class="keyword">val</span> add_incoming</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> * <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">add_incoming (v, bb) pn</code> adds the value <code class="code">v</code> to the phi node <code class="code">pn</code> for use
    with branches from <code class="code">bb</code>. See the method <code class="code">llvm::<span class="constructor">PHINode</span>::addIncoming</code>.<br>
</div>
<pre><span id="VALincoming"><span class="keyword">val</span> incoming</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a> * <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) list</code></pre><div class="info">
<code class="code">incoming pn</code> returns the list of value-block pairs for phi node <code class="code">pn</code>.
    See the method <code class="code">llvm::<span class="constructor">PHINode</span>::getIncomingValue</code>.<br>
</div>
<pre><span id="VALdelete_instruction"><span class="keyword">val</span> delete_instruction</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">delete_instruction i</code> deletes the instruction <code class="code">i</code>.
 * See the method <code class="code">llvm::<span class="constructor">Instruction</span>::eraseFromParent</code>.<br>
</div>
<br>
<span id="6_Instructionbuilders"><h6>Instruction builders</h6></span><br>
<pre><span id="VALbuilder"><span class="keyword">val</span> builder</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder context</code> creates an instruction builder with no position in
    the context <code class="code">context</code>. It is invalid to use this builder until its position
    is set with <a href="Llvm.html#VALposition_before"><code class="code"><span class="constructor">Llvm</span>.position_before</code></a> or <a href="Llvm.html#VALposition_at_end"><code class="code"><span class="constructor">Llvm</span>.position_at_end</code></a>. See the constructor
    for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span id="VALbuilder_at"><span class="keyword">val</span> builder_at</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -><br>       (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder_at ip</code> creates an instruction builder positioned at <code class="code">ip</code>.
    See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span id="VALbuilder_before"><span class="keyword">val</span> builder_before</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder_before ins</code> creates an instruction builder positioned before the
    instruction <code class="code">isn</code>. See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span id="VALbuilder_at_end"><span class="keyword">val</span> builder_at_end</span> : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder_at_end bb</code> creates an instruction builder positioned at the end of
    the basic block <code class="code">bb</code>. See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span id="VALposition_builder"><span class="keyword">val</span> position_builder</span> : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">position_builder ip bb</code> moves the instruction builder <code class="code">bb</code> to the position
    <code class="code">ip</code>.
    See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span id="VALposition_before"><span class="keyword">val</span> position_before</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">position_before ins b</code> moves the instruction builder <code class="code">b</code> to before the
    instruction <code class="code">isn</code>. See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">SetInsertPoint</span></code>.<br>
</div>
<pre><span id="VALposition_at_end"><span class="keyword">val</span> position_at_end</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">position_at_end bb b</code> moves the instruction builder <code class="code">b</code> to the end of the
    basic block <code class="code">bb</code>. See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">SetInsertPoint</span></code>.<br>
</div>
<pre><span id="VALinsertion_block"><span class="keyword">val</span> insertion_block</span> : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">insertion_block b</code> returns the basic block that the builder <code class="code">b</code> is
    positioned to insert into. Raises <code class="code"><span class="constructor">Not_Found</span></code> if the instruction builder is
    uninitialized.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">GetInsertBlock</span></code>.<br>
</div>
<pre><span id="VALinsert_into_builder"><span class="keyword">val</span> insert_into_builder</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">insert_into_builder i name b</code> inserts the specified instruction <code class="code">i</code> at the
    position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">Insert</span></code>.<br>
</div>
<br>
<span id="7_Metadata"><div class="h7">Metadata</div></span><br>
<pre><span id="VALset_current_debug_location"><span class="keyword">val</span> set_current_debug_location</span> : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_current_debug_location b md</code> sets the current debug location <code class="code">md</code> in
    the builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">IRBuilder</span>::<span class="constructor">SetDebugLocation</span></code>.<br>
</div>
<pre><span id="VALclear_current_debug_location"><span class="keyword">val</span> clear_current_debug_location</span> : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">clear_current_debug_location b</code> clears the current debug location in the
    builder <code class="code">b</code>.<br>
</div>
<pre><span id="VALcurrent_debug_location"><span class="keyword">val</span> current_debug_location</span> : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">current_debug_location b</code> returns the current debug location, or None
    if none is currently set.
    See the method <code class="code">llvm::<span class="constructor">IRBuilder</span>::<span class="constructor">GetDebugLocation</span></code>.<br>
</div>
<pre><span id="VALset_inst_debug_location"><span class="keyword">val</span> set_inst_debug_location</span> : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_inst_debug_location b i</code> sets the current debug location of the builder
    <code class="code">b</code> to the instruction <code class="code">i</code>.
    See the method <code class="code">llvm::<span class="constructor">IRBuilder</span>::<span class="constructor">SetInstDebugLocation</span></code>.<br>
</div>
<br>
<span id="7_Terminators"><div class="h7">Terminators</div></span><br>
<pre><span id="VALbuild_ret_void"><span class="keyword">val</span> build_ret_void</span> : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ret_void b</code> creates a
    <code class="code">ret void</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateRetVoid</span></code>.<br>
</div>
<pre><span id="VALbuild_ret"><span class="keyword">val</span> build_ret</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ret v b</code> creates a
    <code class="code">ret %v</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateRet</span></code>.<br>
</div>
<pre><span id="VALbuild_aggregate_ret"><span class="keyword">val</span> build_aggregate_ret</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_aggregate_ret vs b</code> creates a
    <code class="code">ret {...} { %v1, %v2, ... } </code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAggregateRet</span></code>.<br>
</div>
<pre><span id="VALbuild_br"><span class="keyword">val</span> build_br</span> : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_br bb b</code> creates a
    <code class="code">br %bb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateBr</span></code>.<br>
</div>
<pre><span id="VALbuild_cond_br"><span class="keyword">val</span> build_cond_br</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_cond_br cond tbb fbb b</code> creates a
    <code class="code">br %cond, %tbb, %fbb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateCondBr</span></code>.<br>
</div>
<pre><span id="VALbuild_switch"><span class="keyword">val</span> build_switch</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> int -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_switch case elsebb count b</code> creates an empty
    <code class="code">switch %case, %elsebb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code> with
    space reserved for <code class="code">count</code> cases.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSwitch</span></code>.<br>
</div>
<pre><span id="VALbuild_malloc"><span class="keyword">val</span> build_malloc</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_malloc ty name b</code> creates an <code class="code">malloc</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::<span class="constructor">CreateMalloc</span></code>.<br>
</div>
<pre><span id="VALbuild_array_malloc"><span class="keyword">val</span> build_array_malloc</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_array_malloc ty <span class="keyword">val</span> name b</code> creates an <code class="code">array malloc</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::<span class="constructor">CreateArrayMalloc</span></code>.<br>
</div>
<pre><span id="VALbuild_free"><span class="keyword">val</span> build_free</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_free p b</code> creates a <code class="code">free</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFree</span></code>.<br>
</div>
<pre><span id="VALadd_case"><span class="keyword">val</span> add_case</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">add_case sw onval bb</code> causes switch instruction <code class="code">sw</code> to branch to <code class="code">bb</code>
    when its input matches the constant <code class="code">onval</code>.
    See the method <code class="code">llvm::<span class="constructor">SwitchInst</span>::addCase</code>. *<br>
</div>
<pre><span id="VALswitch_default_dest"><span class="keyword">val</span> switch_default_dest</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">switch_default_dest sw</code> returns the default destination of the <code class="code">switch</code>
 * instruction.
 * See the method <code class="code">llvm:;<span class="constructor">SwitchInst</span>::getDefaultDest</code>. *<br>
</div>
<pre><span id="VALbuild_indirect_br"><span class="keyword">val</span> build_indirect_br</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_indirect_br addr count b</code> creates a
    <code class="code">indirectbr %addr</code>
    instruction at the position specified by the instruction builder <code class="code">b</code> with
    space reserved for <code class="code">count</code> destinations.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIndirectBr</span></code>.<br>
</div>
<pre><span id="VALadd_destination"><span class="keyword">val</span> add_destination</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">add_destination br bb</code> adds the basic block <code class="code">bb</code> as a possible branch
    location for the indirectbr instruction <code class="code">br</code>.
    See the method <code class="code">llvm::<span class="constructor">IndirectBrInst</span>::addDestination</code>. *<br>
</div>
<pre><span id="VALbuild_invoke"><span class="keyword">val</span> build_invoke</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -><br>       <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -><br>       <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_invoke fn args tobb unwindbb name b</code> creates an
    <code class="code">%name = invoke %fn(args) <span class="keyword">to</span> %tobb unwind %unwindbb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInvoke</span></code>.<br>
</div>
<pre><span id="VALbuild_landingpad"><span class="keyword">val</span> build_landingpad</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_landingpad ty persfn numclauses name b</code> creates an
    <code class="code">landingpad</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateLandingPad</span></code>.<br>
</div>
<pre><span id="VALset_cleanup"><span class="keyword">val</span> set_cleanup</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool -> unit</code></pre><div class="info">
<code class="code">set_cleanup lp</code> sets the cleanup flag in the <code class="code">landingpad</code>instruction.
    See the method <code class="code">llvm::<span class="constructor">LandingPadInst</span>::setCleanup</code>.<br>
</div>
<pre><span id="VALadd_clause"><span class="keyword">val</span> add_clause</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">add_clause lp clause</code> adds the clause to the <code class="code">landingpad</code>instruction.
    See the method <code class="code">llvm::<span class="constructor">LandingPadInst</span>::addClause</code>.<br>
</div>
<pre><span id="VALbuild_resume"><span class="keyword">val</span> build_resume</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><pre><span id="VALbuild_unreachable"><span class="keyword">val</span> build_unreachable</span> : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_unreachable b</code> creates an
    <code class="code">unreachable</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateUnwind</span></code>.<br>
</div>
<br>
<span id="7_Arithmetic"><div class="h7">Arithmetic</div></span><br>
<pre><span id="VALbuild_add"><span class="keyword">val</span> build_add</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_add x y name b</code> creates a
    <code class="code">%name = add %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAdd</span></code>.<br>
</div>
<pre><span id="VALbuild_nsw_add"><span class="keyword">val</span> build_nsw_add</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_add x y name b</code> creates a
    <code class="code">%name = nsw add %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNSWAdd</span></code>.<br>
</div>
<pre><span id="VALbuild_nuw_add"><span class="keyword">val</span> build_nuw_add</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_add x y name b</code> creates a
    <code class="code">%name = nuw add %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNUWAdd</span></code>.<br>
</div>
<pre><span id="VALbuild_fadd"><span class="keyword">val</span> build_fadd</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fadd x y name b</code> creates a
    <code class="code">%name = fadd %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFAdd</span></code>.<br>
</div>
<pre><span id="VALbuild_sub"><span class="keyword">val</span> build_sub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sub x y name b</code> creates a
    <code class="code">%name = sub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSub</span></code>.<br>
</div>
<pre><span id="VALbuild_nsw_sub"><span class="keyword">val</span> build_nsw_sub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_sub x y name b</code> creates a
    <code class="code">%name = nsw sub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNSWSub</span></code>.<br>
</div>
<pre><span id="VALbuild_nuw_sub"><span class="keyword">val</span> build_nuw_sub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_sub x y name b</code> creates a
    <code class="code">%name = nuw sub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNUWSub</span></code>.<br>
</div>
<pre><span id="VALbuild_fsub"><span class="keyword">val</span> build_fsub</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fsub x y name b</code> creates a
    <code class="code">%name = fsub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFSub</span></code>.<br>
</div>
<pre><span id="VALbuild_mul"><span class="keyword">val</span> build_mul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_mul x y name b</code> creates a
    <code class="code">%name = mul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateMul</span></code>.<br>
</div>
<pre><span id="VALbuild_nsw_mul"><span class="keyword">val</span> build_nsw_mul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_mul x y name b</code> creates a
    <code class="code">%name = nsw mul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNSWMul</span></code>.<br>
</div>
<pre><span id="VALbuild_nuw_mul"><span class="keyword">val</span> build_nuw_mul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_mul x y name b</code> creates a
    <code class="code">%name = nuw mul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNUWMul</span></code>.<br>
</div>
<pre><span id="VALbuild_fmul"><span class="keyword">val</span> build_fmul</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fmul x y name b</code> creates a
    <code class="code">%name = fmul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFMul</span></code>.<br>
</div>
<pre><span id="VALbuild_udiv"><span class="keyword">val</span> build_udiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_udiv x y name b</code> creates a
    <code class="code">%name = udiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateUDiv</span></code>.<br>
</div>
<pre><span id="VALbuild_sdiv"><span class="keyword">val</span> build_sdiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sdiv x y name b</code> creates a
    <code class="code">%name = sdiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSDiv</span></code>.<br>
</div>
<pre><span id="VALbuild_exact_sdiv"><span class="keyword">val</span> build_exact_sdiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_exact_sdiv x y name b</code> creates a
    <code class="code">%name = exact sdiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateExactSDiv</span></code>.<br>
</div>
<pre><span id="VALbuild_fdiv"><span class="keyword">val</span> build_fdiv</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fdiv x y name b</code> creates a
    <code class="code">%name = fdiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFDiv</span></code>.<br>
</div>
<pre><span id="VALbuild_urem"><span class="keyword">val</span> build_urem</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_urem x y name b</code> creates a
    <code class="code">%name = urem %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateURem</span></code>.<br>
</div>
<pre><span id="VALbuild_srem"><span class="keyword">val</span> build_srem</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_SRem x y name b</code> creates a
    <code class="code">%name = srem %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSRem</span></code>.<br>
</div>
<pre><span id="VALbuild_frem"><span class="keyword">val</span> build_frem</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_frem x y name b</code> creates a
    <code class="code">%name = frem %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFRem</span></code>.<br>
</div>
<pre><span id="VALbuild_shl"><span class="keyword">val</span> build_shl</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_shl x y name b</code> creates a
    <code class="code">%name = shl %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateShl</span></code>.<br>
</div>
<pre><span id="VALbuild_lshr"><span class="keyword">val</span> build_lshr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_lshr x y name b</code> creates a
    <code class="code">%name = lshr %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateLShr</span></code>.<br>
</div>
<pre><span id="VALbuild_ashr"><span class="keyword">val</span> build_ashr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ashr x y name b</code> creates a
    <code class="code">%name = ashr %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAShr</span></code>.<br>
</div>
<pre><span id="VALbuild_and"><span class="keyword">val</span> build_and</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_and x y name b</code> creates a
    <code class="code">%name = <span class="keyword">and</span> %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAnd</span></code>.<br>
</div>
<pre><span id="VALbuild_or"><span class="keyword">val</span> build_or</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_or x y name b</code> creates a
    <code class="code">%name = <span class="keyword">or</span> %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateOr</span></code>.<br>
</div>
<pre><span id="VALbuild_xor"><span class="keyword">val</span> build_xor</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_xor x y name b</code> creates a
    <code class="code">%name = xor %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateXor</span></code>.<br>
</div>
<pre><span id="VALbuild_neg"><span class="keyword">val</span> build_neg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_neg x name b</code> creates a
    <code class="code">%name = sub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNeg</span></code>.<br>
</div>
<pre><span id="VALbuild_nsw_neg"><span class="keyword">val</span> build_nsw_neg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_neg x name b</code> creates a
    <code class="code">%name = nsw sub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNeg</span></code>.<br>
</div>
<pre><span id="VALbuild_nuw_neg"><span class="keyword">val</span> build_nuw_neg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_neg x name b</code> creates a
    <code class="code">%name = nuw sub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNeg</span></code>.<br>
</div>
<pre><span id="VALbuild_fneg"><span class="keyword">val</span> build_fneg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fneg x name b</code> creates a
    <code class="code">%name = fsub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFNeg</span></code>.<br>
</div>
<pre><span id="VALbuild_not"><span class="keyword">val</span> build_not</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_xor x name b</code> creates a
    <code class="code">%name = xor %x, -1</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-1</code> is the correct "all ones" value for the type of <code class="code">x</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateXor</span></code>.<br>
</div>
<br>
<span id="7_Memory"><div class="h7">Memory</div></span><br>
<pre><span id="VALbuild_alloca"><span class="keyword">val</span> build_alloca</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_alloca ty name b</code> creates a
    <code class="code">%name = alloca %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAlloca</span></code>.<br>
</div>
<pre><span id="VALbuild_array_alloca"><span class="keyword">val</span> build_array_alloca</span> : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_array_alloca ty n name b</code> creates a
    <code class="code">%name = alloca %ty, %n</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAlloca</span></code>.<br>
</div>
<pre><span id="VALbuild_load"><span class="keyword">val</span> build_load</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_load v name b</code> creates a
    <code class="code">%name = load %v</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateLoad</span></code>.<br>
</div>
<pre><span id="VALbuild_store"><span class="keyword">val</span> build_store</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_store v p b</code> creates a
    <code class="code">store %v, %p</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateStore</span></code>.<br>
</div>
<pre><span id="VALbuild_gep"><span class="keyword">val</span> build_gep</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_gep p indices name b</code> creates a
    <code class="code">%name = getelementptr %p, indices...</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateGetElementPtr</span></code>.<br>
</div>
<pre><span id="VALbuild_in_bounds_gep"><span class="keyword">val</span> build_in_bounds_gep</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_in_bounds_gep p indices name b</code> creates a
    <code class="code">%name = gelementptr inbounds %p, indices...</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInBoundsGetElementPtr</span></code>.<br>
</div>
<pre><span id="VALbuild_struct_gep"><span class="keyword">val</span> build_struct_gep</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_struct_gep p idx name b</code> creates a
    <code class="code">%name = getelementptr %p, 0, idx</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateStructGetElementPtr</span></code>.<br>
</div>
<pre><span id="VALbuild_global_string"><span class="keyword">val</span> build_global_string</span> : <code class="type">string -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_global_string str name b</code> creates a series of instructions that adds
    a global string at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateGlobalString</span></code>.<br>
</div>
<pre><span id="VALbuild_global_stringptr"><span class="keyword">val</span> build_global_stringptr</span> : <code class="type">string -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_global_stringptr str name b</code> creates a series of instructions that
    adds a global string pointer at the position specified by the instruction
    builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateGlobalStringPtr</span></code>.<br>
</div>
<br>
<span id="7_Casts"><div class="h7">Casts</div></span><br>
<pre><span id="VALbuild_trunc"><span class="keyword">val</span> build_trunc</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_trunc v ty name b</code> creates a
    <code class="code">%name = trunc %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateTrunc</span></code>.<br>
</div>
<pre><span id="VALbuild_zext"><span class="keyword">val</span> build_zext</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_zext v ty name b</code> creates a
    <code class="code">%name = zext %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateZExt</span></code>.<br>
</div>
<pre><span id="VALbuild_sext"><span class="keyword">val</span> build_sext</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sext v ty name b</code> creates a
    <code class="code">%name = sext %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSExt</span></code>.<br>
</div>
<pre><span id="VALbuild_fptoui"><span class="keyword">val</span> build_fptoui</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fptoui v ty name b</code> creates a
    <code class="code">%name = fptoui %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPToUI</span></code>.<br>
</div>
<pre><span id="VALbuild_fptosi"><span class="keyword">val</span> build_fptosi</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fptosi v ty name b</code> creates a
    <code class="code">%name = fptosi %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPToSI</span></code>.<br>
</div>
<pre><span id="VALbuild_uitofp"><span class="keyword">val</span> build_uitofp</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_uitofp v ty name b</code> creates a
    <code class="code">%name = uitofp %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateUIToFP</span></code>.<br>
</div>
<pre><span id="VALbuild_sitofp"><span class="keyword">val</span> build_sitofp</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sitofp v ty name b</code> creates a
    <code class="code">%name = sitofp %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSIToFP</span></code>.<br>
</div>
<pre><span id="VALbuild_fptrunc"><span class="keyword">val</span> build_fptrunc</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fptrunc v ty name b</code> creates a
    <code class="code">%name = fptrunc %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPTrunc</span></code>.<br>
</div>
<pre><span id="VALbuild_fpext"><span class="keyword">val</span> build_fpext</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fpext v ty name b</code> creates a
    <code class="code">%name = fpext %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPExt</span></code>.<br>
</div>
<pre><span id="VALbuild_ptrtoint"><span class="keyword">val</span> build_ptrtoint</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ptrtoint v ty name b</code> creates a
    <code class="code">%name = prtotint %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePtrToInt</span></code>.<br>
</div>
<pre><span id="VALbuild_inttoptr"><span class="keyword">val</span> build_inttoptr</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_inttoptr v ty name b</code> creates a
    <code class="code">%name = inttoptr %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIntToPtr</span></code>.<br>
</div>
<pre><span id="VALbuild_bitcast"><span class="keyword">val</span> build_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_bitcast v ty name b</code> creates a
    <code class="code">%name = bitcast %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateBitCast</span></code>.<br>
</div>
<pre><span id="VALbuild_zext_or_bitcast"><span class="keyword">val</span> build_zext_or_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_zext_or_bitcast v ty name b</code> creates a zext or bitcast
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateZExtOrBitCast</span></code>.<br>
</div>
<pre><span id="VALbuild_sext_or_bitcast"><span class="keyword">val</span> build_sext_or_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sext_or_bitcast v ty name b</code> creates a sext or bitcast
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSExtOrBitCast</span></code>.<br>
</div>
<pre><span id="VALbuild_trunc_or_bitcast"><span class="keyword">val</span> build_trunc_or_bitcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_trunc_or_bitcast v ty name b</code> creates a trunc or bitcast
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateZExtOrBitCast</span></code>.<br>
</div>
<pre><span id="VALbuild_pointercast"><span class="keyword">val</span> build_pointercast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_pointercast v ty name b</code> creates a bitcast or pointer-to-int
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePointerCast</span></code>.<br>
</div>
<pre><span id="VALbuild_intcast"><span class="keyword">val</span> build_intcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_intcast v ty name b</code> creates a zext, bitcast, or trunc
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIntCast</span></code>.<br>
</div>
<pre><span id="VALbuild_fpcast"><span class="keyword">val</span> build_fpcast</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fpcast v ty name b</code> creates a fpext, bitcast, or fptrunc
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPCast</span></code>.<br>
</div>
<br>
<span id="7_Comparisons"><div class="h7">Comparisons</div></span><br>
<pre><span id="VALbuild_icmp"><span class="keyword">val</span> build_icmp</span> : <code class="type"><a href="Llvm.Icmp.html#TYPEt">Icmp.t</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_icmp pred x y name b</code> creates a
    <code class="code">%name = icmp %pred %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateICmp</span></code>.<br>
</div>
<pre><span id="VALbuild_fcmp"><span class="keyword">val</span> build_fcmp</span> : <code class="type"><a href="Llvm.Fcmp.html#TYPEt">Fcmp.t</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fcmp pred x y name b</code> creates a
    <code class="code">%name = fcmp %pred %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFCmp</span></code>.<br>
</div>
<br>
<span id="7_Miscellaneousinstructions"><div class="h7">Miscellaneous instructions</div></span><br>
<pre><span id="VALbuild_phi"><span class="keyword">val</span> build_phi</span> : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> * <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) list -><br>       string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_phi incoming name b</code> creates a
    <code class="code">%name = phi %incoming</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">incoming</code> is a list of <code class="code">(llvalue, llbasicblock)</code> tuples.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePHI</span></code>.<br>
</div>
<pre><span id="VALbuild_call"><span class="keyword">val</span> build_call</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_call fn args name b</code> creates a
    <code class="code">%name = call %fn(args...)</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateCall</span></code>.<br>
</div>
<pre><span id="VALbuild_select"><span class="keyword">val</span> build_select</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_select cond thenv elsev name b</code> creates a
    <code class="code">%name = select %cond, %thenv, %elsev</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSelect</span></code>.<br>
</div>
<pre><span id="VALbuild_va_arg"><span class="keyword">val</span> build_va_arg</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_va_arg valist argty name b</code> creates a
    <code class="code">%name = va_arg %valist, %argty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateVAArg</span></code>.<br>
</div>
<pre><span id="VALbuild_extractelement"><span class="keyword">val</span> build_extractelement</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_extractelement vec i name b</code> creates a
    <code class="code">%name = extractelement %vec, %i</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateExtractElement</span></code>.<br>
</div>
<pre><span id="VALbuild_insertelement"><span class="keyword">val</span> build_insertelement</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_insertelement vec elt i name b</code> creates a
    <code class="code">%name = insertelement %vec, %elt, %i</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInsertElement</span></code>.<br>
</div>
<pre><span id="VALbuild_shufflevector"><span class="keyword">val</span> build_shufflevector</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_shufflevector veca vecb mask name b</code> creates a
    <code class="code">%name = shufflevector %veca, %vecb, %mask</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateShuffleVector</span></code>.<br>
</div>
<pre><span id="VALbuild_extractvalue"><span class="keyword">val</span> build_extractvalue</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_insertvalue agg idx name b</code> creates a
    <code class="code">%name = extractvalue %agg, %idx</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateExtractValue</span></code>.<br>
</div>
<pre><span id="VALbuild_insertvalue"><span class="keyword">val</span> build_insertvalue</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_insertvalue agg <span class="keyword">val</span> idx name b</code> creates a
    <code class="code">%name = insertvalue %agg, %<span class="keyword">val</span>, %idx</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInsertValue</span></code>.<br>
</div>
<pre><span id="VALbuild_is_null"><span class="keyword">val</span> build_is_null</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_is_null <span class="keyword">val</span> name b</code> creates a
    <code class="code">%name = icmp eq %<span class="keyword">val</span>, null</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIsNull</span></code>.<br>
</div>
<pre><span id="VALbuild_is_not_null"><span class="keyword">val</span> build_is_not_null</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_is_not_null <span class="keyword">val</span> name b</code> creates a
    <code class="code">%name = icmp ne %<span class="keyword">val</span>, null</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIsNotNull</span></code>.<br>
</div>
<pre><span id="VALbuild_ptrdiff"><span class="keyword">val</span> build_ptrdiff</span> : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ptrdiff lhs rhs name b</code> creates a series of instructions that measure
    the difference between two pointer values at the position specified by the
    instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePtrDiff</span></code>.<br>
</div>
<br>
<span id="6_Memorybuffers"><h6>Memory buffers</h6></span><br>
<pre><span class="keyword">module</span> <a href="Llvm.MemoryBuffer.html">MemoryBuffer</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.MemoryBuffer.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<span id="6_PassManagers"><h6>Pass Managers</h6></span><br>
<pre><span class="keyword">module</span> <a href="Llvm.PassManager.html">PassManager</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.PassManager.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>