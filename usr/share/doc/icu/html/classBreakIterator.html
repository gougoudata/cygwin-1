<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ICU 4.8.1: BreakIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>BreakIterator Class Reference</h1><!-- doxytag: class="BreakIterator" --><!-- doxytag: inherits="UObject" -->
<p>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> class implements methods for finding the location of boundaries in text.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="brkiter_8h_source.html">brkiter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BreakIterator:</div>
<div class="dynsection">
 <div class="center">
  <img src="classBreakIterator.gif" usemap="#BreakIterator_map" alt=""/>
  <map id="BreakIterator_map" name="BreakIterator_map">
<area href="classUObject.html" alt="UObject" shape="rect" coords="0,56,145,80"/>
<area href="classUMemory.html" alt="UMemory" shape="rect" coords="0,0,145,24"/>
<area href="classRuleBasedBreakIterator.html" alt="RuleBasedBreakIterator" shape="rect" coords="0,168,145,192"/>
</map>
 </div>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classBreakIterator.html#a08bd7354c8ac72497a46bbe4d3f4a3feae32f847673a92726e06dfce66fea909c">DONE</a> =  (int32_t)-1
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a3cbedcb4750bac9e8d301138d61a8411">~BreakIterator</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destructor  <a href="#a3cbedcb4750bac9e8d301138d61a8411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#adef035120a8805b350ae7ec789b43093">operator==</a> (const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if another object is semantically equal to this one.  <a href="#adef035120a8805b350ae7ec789b43093"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a188fb5d54bae55e4f9ea9730e44919a5">operator!=</a> (const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the complement of the result of operator==.  <a href="#a188fb5d54bae55e4f9ea9730e44919a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#aa17a81d41fa791049a10c37594dad88f">clone</a> (void) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a polymorphic copy of this object.  <a href="#aa17a81d41fa791049a10c37594dad88f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#aeaf98baae1d91e224ef8ccced5d2266c">getDynamicClassID</a> (void) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a polymorphic class ID for this object.  <a href="#aeaf98baae1d91e224ef8ccced5d2266c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCharacterIterator.html">CharacterIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ab12b76622eaa6df7d0df48778f5de1aa">getText</a> (void) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over the text being analyzed.  <a href="#ab12b76622eaa6df7d0df48778f5de1aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a724d55795f3edb7748e6d6dffd80d926">getUText</a> (<a class="el" href="structUText.html">UText</a> *fillIn, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed.  <a href="#a724d55795f3edb7748e6d6dffd80d926"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ac50a6618fe83b9b96a7a9213c5da3f21">setText</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;text)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the text over which this operates.  <a href="#ac50a6618fe83b9b96a7a9213c5da3f21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a74d79d97bbc2265753486704111d29eb">setText</a> (<a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="#a74d79d97bbc2265753486704111d29eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a729dbe9a6437070d9fb056c6c7589563">adoptText</a> (<a class="el" href="classCharacterIterator.html">CharacterIterator</a> *it)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the text over which this operates.  <a href="#a729dbe9a6437070d9fb056c6c7589563"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ae09bd26e3559e18e8e46699075f477e4">first</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index of the first character in the text being scanned.  <a href="#ae09bd26e3559e18e8e46699075f477e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ab21a3083a947dd4b4f3653a0a51080c2">last</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index immediately BEYOND the last character in the text being scanned.  <a href="#ab21a3083a947dd4b4f3653a0a51080c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ac4f27d685b8c1bacbad7e27a6af141f2">previous</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the boundary preceding the current boundary.  <a href="#ac4f27d685b8c1bacbad7e27a6af141f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a68f3b6be789195b55204a6d86d58a8ad">next</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the boundary following the current boundary.  <a href="#a68f3b6be789195b55204a6d86d58a8ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a36835a8123d823f333af822d9c7cb8a6">current</a> (void) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return character index of the current interator position within the text.  <a href="#a36835a8123d823f333af822d9c7cb8a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a57f98a77f67b2ca34c26ee2e77d76e09">following</a> (int32_t offset)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first boundary following the specified offset.  <a href="#a57f98a77f67b2ca34c26ee2e77d76e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a9230e330fd08bad1b6c278d322ef2385">preceding</a> (int32_t offset)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first boundary preceding the specified offset.  <a href="#a9230e330fd08bad1b6c278d322ef2385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a9ac740557f08c879cceffdbb4a15fe7b">isBoundary</a> (int32_t offset)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the specfied position is a boundary position.  <a href="#a9ac740557f08c879cceffdbb4a15fe7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#abc5223195e31b93657dffa305592bcd7">next</a> (int32_t n)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the nth boundary from the current boundary.  <a href="#abc5223195e31b93657dffa305592bcd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a6ea0e9828c9ef650086f4d3a17ce5c61">createBufferClone</a> (void *stackBuffer, int32_t &amp;BufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone, since 'new' is not used to create it.  <a href="#a6ea0e9828c9ef650086f4d3a17ce5c61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#afd5e718cd3b674c792f65ab8fd0da3d0">isBufferClone</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> was created in user memory by <a class="el" href="classBreakIterator.html#a6ea0e9828c9ef650086f4d3a17ce5c61" title="Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone...">createBufferClone()</a>, and thus should not be deleted.  <a href="#afd5e718cd3b674c792f65ab8fd0da3d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocale.html">Locale</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a4be3c06bc51b35a5f5fbc75f7f0a47c9">getLocale</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the locale for this break iterator.  <a href="#a4be3c06bc51b35a5f5fbc75f7f0a47c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ab934df15f2b12f8f1cbf7053abf8192a">getLocaleID</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the locale for this break iterator object.  <a href="#ab934df15f2b12f8f1cbf7053abf8192a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#afc0385b348d5156de7cc45f34ba660fa">createWordInstance</a> (const <a class="el" href="classLocale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for word-breaks using the given locale.  <a href="#afc0385b348d5156de7cc45f34ba660fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a83ed35d09a8ab8b18ace13e073cf8434">createLineInstance</a> (const <a class="el" href="classLocale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for line-breaks using specified locale.  <a href="#a83ed35d09a8ab8b18ace13e073cf8434"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ae2cac7b85aa5407a98d4849bb38cdcc3">createCharacterInstance</a> (const <a class="el" href="classLocale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for character-breaks using specified locale Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing character breaks.  <a href="#ae2cac7b85aa5407a98d4849bb38cdcc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#aa8dde1f41bd781071e3c61b77020a279">createSentenceInstance</a> (const <a class="el" href="classLocale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for sentence-breaks using specified locale Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing sentence breaks.  <a href="#aa8dde1f41bd781071e3c61b77020a279"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ac4472928a37903bc7144e7cb9b52cf85">createTitleInstance</a> (const <a class="el" href="classLocale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for title-casing breaks using the specified locale Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing title breaks.  <a href="#ac4472928a37903bc7144e7cb9b52cf85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classLocale.html">Locale</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a4df68870381a0f18b32df66f4b3e3b84">getAvailableLocales</a> (int32_t &amp;count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the set of Locales for which TextBoundaries are installed.  <a href="#a4df68870381a0f18b32df66f4b3e3b84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a226fa492661a3c5168711dfd76b3db17">getDisplayName</a> (const <a class="el" href="classLocale.html">Locale</a> &amp;objectLocale, const <a class="el" href="classLocale.html">Locale</a> &amp;displayLocale, <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a>, in the desired langauge.  <a href="#a226fa492661a3c5168711dfd76b3db17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a0f3ae6a2de27880e9037452591c428b7">getDisplayName</a> (const <a class="el" href="classLocale.html">Locale</a> &amp;objectLocale, <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a>, in the langauge of the default locale.  <a href="#a0f3ae6a2de27880e9037452591c428b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a25f88e97609e60d6efd832869e3a8f20">registerInstance</a> (<a class="el" href="classBreakIterator.html">BreakIterator</a> *toAdopt, const <a class="el" href="classLocale.html">Locale</a> &amp;locale, <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> kind, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a new break iterator of the indicated kind, to use in the given locale.  <a href="#a25f88e97609e60d6efd832869e3a8f20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a4c010d2a3f111fd49801eabe28375096">unregister</a> (<a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a> key, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a previously-registered <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> using the key returned from the register call.  <a href="#a4c010d2a3f111fd49801eabe28375096"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classStringEnumeration.html">StringEnumeration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a3cdd392e1a0b5683f9932f471c016cca">getAvailableLocales</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classStringEnumeration.html" title="Base class for &#39;pure&#39; C++ implementations of uenum api.">StringEnumeration</a> over the locales available at the time of the call, including registered locales.  <a href="#a3cdd392e1a0b5683f9932f471c016cca"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#acea8fffaad4c79ddded9a53a718fc33e">BreakIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#ab8538351f56a2bbfee9af33f2417e553">BreakIterator</a> (const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;other)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBreakIterator.html#a9fa7a1741b71fa9b2228455b0dad3c6a">fBufferClone</a></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d94f465eba6b867a8e081a6650d0aa7"></a><!-- doxytag: member="BreakIterator::ICUBreakIteratorFactory" ref="a9d94f465eba6b867a8e081a6650d0aa7" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>ICUBreakIteratorFactory</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab98b7c14471379197ac959b4d8e12e4e"></a><!-- doxytag: member="BreakIterator::ICUBreakIteratorService" ref="ab98b7c14471379197ac959b4d8e12e4e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>ICUBreakIteratorService</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> class implements methods for finding the location of boundaries in text. </p>
<p><a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> is an abstract base class. Instances of <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> maintain a current position and scan over text returning the index of characters where boundaries occur. </p>
<p>Line boundary analysis determines where a text string can be broken when line-wrapping. The mechanism correctly handles punctuation and hyphenated words. </p>
<p>Sentence boundary analysis allows selection with correct interpretation of periods within numbers and abbreviations, and trailing punctuation marks such as quotation marks and parentheses. </p>
<p>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides. </p>
<p>Character boundary analysis allows users to interact with characters as they expect to, for example, when moving the cursor through a text string. Character boundary analysis provides correct navigation of through character strings, regardless of how the character is stored. For example, an accented character might be stored as a base character and a diacritical mark. What users consider to be a character can differ between languages. </p>
<p>The text boundary positions are found according to the rules described in Unicode Standard Annex #29, Text Boundaries, and Unicode Standard Annex #14, Line Breaking Properties. These are available at <a href="http://www.unicode.org/reports/tr14/">http://www.unicode.org/reports/tr14/</a> and <a href="http://www.unicode.org/reports/tr29/.">http://www.unicode.org/reports/tr29/.</a> </p>
<p>In addition to the C++ API defined in this header file, a plain C API with equivalent functionality is defined in the file <a class="el" href="ubrk_8h.html" title="C API: BreakIterator.">ubrk.h</a> </p>
<p>Code snippets illustrating the use of the Break Iterator APIs are available in the ICU User Guide, <a href="http://icu-project.org/userguide/boundaryAnalysis.html">http://icu-project.org/userguide/boundaryAnalysis.html</a> and in the sample program icu/source/samples/break/break.cpp </p>

<p>Definition at line <a class="el" href="brkiter_8h_source.html#l00100">100</a> of file <a class="el" href="brkiter_8h_source.html">brkiter.h</a>.</p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a08bd7354c8ac72497a46bbe4d3f4a3fe"></a><!-- doxytag: member="BreakIterator::@0" ref="a08bd7354c8ac72497a46bbe4d3f4a3fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a08bd7354c8ac72497a46bbe4d3f4a3feae32f847673a92726e06dfce66fea909c"></a><!-- doxytag: member="DONE" ref="a08bd7354c8ac72497a46bbe4d3f4a3feae32f847673a92726e06dfce66fea909c" args="" -->DONE</em>&nbsp;</td><td>
<p>DONE is returned by <a class="el" href="classBreakIterator.html#ac4f27d685b8c1bacbad7e27a6af141f2" title="Return the boundary preceding the current boundary.">previous()</a> and <a class="el" href="classBreakIterator.html#a68f3b6be789195b55204a6d86d58a8ad" title="Return the boundary following the current boundary.">next()</a> after all valid boundaries have been returned. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000034">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="brkiter_8h_source.html#l00201">201</a> of file <a class="el" href="brkiter_8h_source.html">brkiter.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3cbedcb4750bac9e8d301138d61a8411"></a><!-- doxytag: member="BreakIterator::~BreakIterator" ref="a3cbedcb4750bac9e8d301138d61a8411" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual BreakIterator::~BreakIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>destructor </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000001">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="acea8fffaad4c79ddded9a53a718fc33e"></a><!-- doxytag: member="BreakIterator::BreakIterator" ref="acea8fffaad4c79ddded9a53a718fc33e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BreakIterator::BreakIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000013">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8538351f56a2bbfee9af33f2417e553"></a><!-- doxytag: member="BreakIterator::BreakIterator" ref="ab8538351f56a2bbfee9af33f2417e553" args="(const BreakIterator &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BreakIterator::BreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000015">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="brkiter_8h_source.html#l00531">531</a> of file <a class="el" href="brkiter_8h_source.html">brkiter.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a729dbe9a6437070d9fb056c6c7589563"></a><!-- doxytag: member="BreakIterator::adoptText" ref="a729dbe9a6437070d9fb056c6c7589563" args="(CharacterIterator *it)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BreakIterator::adoptText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCharacterIterator.html">CharacterIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>it</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the text over which this operates. </p>
<p>The text boundary is reset to the start. Note that setText(UText *) provides similar functionality to this function, and is more efficient. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>The <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> used to change the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000010">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a002e744aad6039dd379f63225052f0b1">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="aa17a81d41fa791049a10c37594dad88f"></a><!-- doxytag: member="BreakIterator::clone" ref="aa17a81d41fa791049a10c37594dad88f" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a>* BreakIterator::clone </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a polymorphic copy of this object. </p>
<p>This is an abstract method which subclasses implement. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000004">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a805badacaa522dee2ec8c3e09ab5659f">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a6ea0e9828c9ef650086f4d3a17ce5c61"></a><!-- doxytag: member="BreakIterator::createBufferClone" ref="a6ea0e9828c9ef650086f4d3a17ce5c61" args="(void *stackBuffer, int32_t &amp;BufferSize, UErrorCode &amp;status)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a>* BreakIterator::createBufferClone </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone, since 'new' is not used to create it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stackBuffer</em>&nbsp;</td><td>user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferSize</em>&nbsp;</td><td>reference to size of allocated space. If BufferSize == 0, a sufficient size for use in cloning will be returned ('pre-flighting') If BufferSize is not enough for a stack-based safe clone, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_ERROR, is used if any allocations were necessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the new clone</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000028">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a3e120994761da087377fb1e6b5dccf18">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="ae2cac7b85aa5407a98d4849bb38cdcc3"></a><!-- doxytag: member="BreakIterator::createCharacterInstance" ref="ae2cac7b85aa5407a98d4849bb38cdcc3" args="(const Locale &amp;where, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classBreakIterator.html">BreakIterator</a>* BreakIterator::createCharacterInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for character-breaks using specified locale Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing character breaks. </p>
<p>Character breaks are boundaries of combining character sequences. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>the locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for character-breaks. The UErrorCode&amp; status parameter is used to return status information to the user. To check whether the construction succeeded or not, you should check the value of <a class="el" href="utypes_8h.html#a527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS(err)</a>. If you wish more detailed information, you can check for informational error results which still indicate success. U_USING_FALLBACK_WARNING indicates that a fall back locale was used. For example, 'de_CH' was requested, but nothing was found there, so 'de' was used. U_USING_DEFAULT_WARNING indicates that the default locale data was used; neither the requested locale nor any of its fall back locales could be found. The caller owns the returned object and is responsible for deleting it. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000022">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a83ed35d09a8ab8b18ace13e073cf8434"></a><!-- doxytag: member="BreakIterator::createLineInstance" ref="a83ed35d09a8ab8b18ace13e073cf8434" args="(const Locale &amp;where, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classBreakIterator.html">BreakIterator</a>* BreakIterator::createLineInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for line-breaks using specified locale. </p>
<p>Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing line breaks. Line breaks are logically possible line breaks, actual line breaks are usually determined based on display width. LineBreak is useful for word wrapping text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>the locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for line-breaks. The UErrorCode&amp; status parameter is used to return status information to the user. To check whether the construction succeeded or not, you should check the value of <a class="el" href="utypes_8h.html#a527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS(err)</a>. If you wish more detailed information, you can check for informational error results which still indicate success. U_USING_FALLBACK_WARNING indicates that a fall back locale was used. For example, 'de_CH' was requested, but nothing was found there, so 'de' was used. U_USING_DEFAULT_WARNING indicates that the default locale data was used; neither the requested locale nor any of its fall back locales could be found. The caller owns the returned object and is responsible for deleting it. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000021">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa8dde1f41bd781071e3c61b77020a279"></a><!-- doxytag: member="BreakIterator::createSentenceInstance" ref="aa8dde1f41bd781071e3c61b77020a279" args="(const Locale &amp;where, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classBreakIterator.html">BreakIterator</a>* BreakIterator::createSentenceInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for sentence-breaks using specified locale Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing sentence breaks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>the locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for sentence-breaks. The UErrorCode&amp; status parameter is used to return status information to the user. To check whether the construction succeeded or not, you should check the value of <a class="el" href="utypes_8h.html#a527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS(err)</a>. If you wish more detailed information, you can check for informational error results which still indicate success. U_USING_FALLBACK_WARNING indicates that a fall back locale was used. For example, 'de_CH' was requested, but nothing was found there, so 'de' was used. U_USING_DEFAULT_WARNING indicates that the default locale data was used; neither the requested locale nor any of its fall back locales could be found. The caller owns the returned object and is responsible for deleting it. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000023">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac4472928a37903bc7144e7cb9b52cf85"></a><!-- doxytag: member="BreakIterator::createTitleInstance" ref="ac4472928a37903bc7144e7cb9b52cf85" args="(const Locale &amp;where, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classBreakIterator.html">BreakIterator</a>* BreakIterator::createTitleInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for title-casing breaks using the specified locale Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing title breaks. </p>
<p>The iterator returned locates title boundaries as described for Unicode 3.2 only. For Unicode 4.0 and above title boundary iteration, please use Word Boundary iterator.<a class="el" href="classBreakIterator.html#afc0385b348d5156de7cc45f34ba660fa">createWordInstance</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>the locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for title-breaks. The UErrorCode&amp; status parameter is used to return status information to the user. To check whether the construction succeeded or not, you should check the value of <a class="el" href="utypes_8h.html#a527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS(err)</a>. If you wish more detailed information, you can check for informational error results which still indicate success. U_USING_FALLBACK_WARNING indicates that a fall back locale was used. For example, 'de_CH' was requested, but nothing was found there, so 'de' was used. U_USING_DEFAULT_WARNING indicates that the default locale data was used; neither the requested locale nor any of its fall back locales could be found. The caller owns the returned object and is responsible for deleting it. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000024">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="afc0385b348d5156de7cc45f34ba660fa"></a><!-- doxytag: member="BreakIterator::createWordInstance" ref="afc0385b348d5156de7cc45f34ba660fa" args="(const Locale &amp;where, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classBreakIterator.html">BreakIterator</a>* BreakIterator::createWordInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for word-breaks using the given locale. </p>
<p>Returns an instance of a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> implementing word breaks. WordBreak is useful for word selection (ex. double click) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>the locale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>the error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> for word-breaks. The UErrorCode&amp; status parameter is used to return status information to the user. To check whether the construction succeeded or not, you should check the value of <a class="el" href="utypes_8h.html#a527f2c69e6b2e3b2c53ad8a99fb36711" title="Does the error code indicate success?">U_SUCCESS(err)</a>. If you wish more detailed information, you can check for informational error results which still indicate success. U_USING_FALLBACK_WARNING indicates that a fall back locale was used. For example, 'de_CH' was requested, but nothing was found there, so 'de' was used. U_USING_DEFAULT_WARNING indicates that the default locale data was used; neither the requested locale nor any of its fall back locales could be found. The caller owns the returned object and is responsible for deleting it. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000020">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a36835a8123d823f333af822d9c7cb8a6"></a><!-- doxytag: member="BreakIterator::current" ref="a36835a8123d823f333af822d9c7cb8a6" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::current </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return character index of the current interator position within the text. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The boundary most recently returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000015">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#ac7083ccc926c0b72c08ea105a01321c8">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="ae09bd26e3559e18e8e46699075f477e4"></a><!-- doxytag: member="BreakIterator::first" ref="ae09bd26e3559e18e8e46699075f477e4" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::first </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the index of the first character in the text being scanned. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000011">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a45707d96406f1b0027ce65c79ac36c67">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a57f98a77f67b2ca34c26ee2e77d76e09"></a><!-- doxytag: member="BreakIterator::following" ref="a57f98a77f67b2ca34c26ee2e77d76e09" args="(int32_t offset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::following </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the first boundary following the specified offset. </p>
<p>The value returned is always greater than the offset or the value <a class="el" href="classBreakIterator.html#a08bd7354c8ac72497a46bbe4d3f4a3feae32f847673a92726e06dfce66fea909c" title="DONE is returned by previous() and next() after all valid boundaries have been returned...">BreakIterator.DONE</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset to begin scanning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first boundary after the specified offset. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000016">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a0407bc1809b35c7af19cfa0539067841">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a3cdd392e1a0b5683f9932f471c016cca"></a><!-- doxytag: member="BreakIterator::getAvailableLocales" ref="a3cdd392e1a0b5683f9932f471c016cca" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classStringEnumeration.html">StringEnumeration</a>* BreakIterator::getAvailableLocales </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classStringEnumeration.html" title="Base class for &#39;pure&#39; C++ implementations of uenum api.">StringEnumeration</a> over the locales available at the time of the call, including registered locales. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classStringEnumeration.html" title="Base class for &#39;pure&#39; C++ implementations of uenum api.">StringEnumeration</a> over the locales available at the time of the call </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000032">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a4df68870381a0f18b32df66f4b3e3b84"></a><!-- doxytag: member="BreakIterator::getAvailableLocales" ref="a4df68870381a0f18b32df66f4b3e3b84" args="(int32_t &amp;count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classLocale.html">Locale</a>* BreakIterator::getAvailableLocales </td>
          <td>(</td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>count</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the set of Locales for which TextBoundaries are installed. </p>
<p><b>Note:</b> this will not return locales added through the register call. To see the registered locales too, use the getAvailableLocales function that returns a <a class="el" href="classStringEnumeration.html" title="Base class for &#39;pure&#39; C++ implementations of uenum api.">StringEnumeration</a> object  </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>the output parameter of number of elements in the locale list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>available locales </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000025">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0f3ae6a2de27880e9037452591c428b7"></a><!-- doxytag: member="BreakIterator::getDisplayName" ref="a0f3ae6a2de27880e9037452591c428b7" args="(const Locale &amp;objectLocale, UnicodeString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classUnicodeString.html">UnicodeString</a>&amp; BreakIterator::getDisplayName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>objectLocale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get name of the object for the desired <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a>, in the langauge of the default locale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>objectLocale</em>&nbsp;</td><td>must be from getMatchingLocales </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the fill-in parameter of the return value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>user-displayable name </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000027">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a226fa492661a3c5168711dfd76b3db17"></a><!-- doxytag: member="BreakIterator::getDisplayName" ref="a226fa492661a3c5168711dfd76b3db17" args="(const Locale &amp;objectLocale, const Locale &amp;displayLocale, UnicodeString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classUnicodeString.html">UnicodeString</a>&amp; BreakIterator::getDisplayName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>objectLocale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>displayLocale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get name of the object for the desired <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a>, in the desired langauge. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>objectLocale</em>&nbsp;</td><td>must be from getAvailableLocales. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>displayLocale</em>&nbsp;</td><td>specifies the desired locale for output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the fill-in parameter of the return value Uses best match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>user-displayable name </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000026">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aeaf98baae1d91e224ef8ccced5d2266c"></a><!-- doxytag: member="BreakIterator::getDynamicClassID" ref="aeaf98baae1d91e224ef8ccced5d2266c" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> BreakIterator::getDynamicClassID </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a polymorphic class ID for this object. </p>
<p>Different subclasses will return distinct unequal values. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000005">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classUObject.html#a9b1acc95efd89cb86ec31f2dc947a262">UObject</a>.</p>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#ac601c2347870413f79995d843687a470">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a4be3c06bc51b35a5f5fbc75f7f0a47c9"></a><!-- doxytag: member="BreakIterator::getLocale" ref="a4be3c06bc51b35a5f5fbc75f7f0a47c9" args="(ULocDataLocaleType type, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocale.html">Locale</a> BreakIterator::getLocale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the locale for this break iterator. </p>
<p>Two flavors are available: valid and actual locale. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000033">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a class="anchor" id="ab934df15f2b12f8f1cbf7053abf8192a"></a><!-- doxytag: member="BreakIterator::getLocaleID" ref="ab934df15f2b12f8f1cbf7053abf8192a" args="(ULocDataLocaleType type, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* BreakIterator::getLocaleID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the locale for this break iterator object. </p>
<p>You can choose between valid and actual locale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of the locale we're looking for (valid or actual) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>error code for the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the locale </dd></dl>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000012">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="ab12b76622eaa6df7d0df48778f5de1aa"></a><!-- doxytag: member="BreakIterator::getText" ref="ab12b76622eaa6df7d0df48778f5de1aa" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCharacterIterator.html">CharacterIterator</a>&amp; BreakIterator::getText </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over the text being analyzed. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000006">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a21542dea2f8d1d12629484f38292301d">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a724d55795f3edb7748e6d6dffd80d926"></a><!-- doxytag: member="BreakIterator::getUText" ref="a724d55795f3edb7748e6d6dffd80d926" args="(UText *fillIn, UErrorCode &amp;status) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* BreakIterator::getUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>fillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed. </p>
<p>The returned <a class="el" href="structUText.html" title="UText struct.">UText</a> is a shallow clone of the <a class="el" href="structUText.html" title="UText struct.">UText</a> used internally by the break iterator implementation. It can safely be used to access the text without impacting any break iterator operations, but the underlying text itself must not be altered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fillIn</em>&nbsp;</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> to be filled in. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be allocated to hold the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current <a class="el" href="structUText.html" title="UText struct.">UText</a> for this break iterator. If an input <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000007">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#aafe5882170adf4e756d077db58cce0a4">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a9ac740557f08c879cceffdbb4a15fe7b"></a><!-- doxytag: member="BreakIterator::isBoundary" ref="a9ac740557f08c879cceffdbb4a15fe7b" args="(int32_t offset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> BreakIterator::isBoundary </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the specfied position is a boundary position. </p>
<p>As a side effect, the current position of the iterator is set to the first boundary position at or following the specified offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000018">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#ad23e9f31feed57dee61b1d45fcb3dbfc">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="afd5e718cd3b674c792f65ab8fd0da3d0"></a><!-- doxytag: member="BreakIterator::isBufferClone" ref="afd5e718cd3b674c792f65ab8fd0da3d0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> BreakIterator::isBufferClone </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether the <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> was created in user memory by <a class="el" href="classBreakIterator.html#a6ea0e9828c9ef650086f4d3a17ce5c61" title="Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone...">createBufferClone()</a>, and thus should not be deleted. </p>
<p>Such objects must be closed by an explicit call to the destructor (not delete). </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000029">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="brkiter_8h_source.html#l00546">546</a> of file <a class="el" href="brkiter_8h_source.html">brkiter.h</a>.</p>

<p>References <a class="el" href="brkiter_8h_source.html#l00529">fBufferClone</a>.</p>

</div>
</div>
<a class="anchor" id="ab21a3083a947dd4b4f3653a0a51080c2"></a><!-- doxytag: member="BreakIterator::last" ref="ab21a3083a947dd4b4f3653a0a51080c2" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::last </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the index immediately BEYOND the last character in the text being scanned. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000012">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#ab57d12a60328d31fbc859591d9fd1272">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="abc5223195e31b93657dffa305592bcd7"></a><!-- doxytag: member="BreakIterator::next" ref="abc5223195e31b93657dffa305592bcd7" args="(int32_t n)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the nth boundary from the current boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>which boundary to return. A value of 0 does nothing. Negative values move to previous boundaries and positive values move to later boundaries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the nth boundary from the current position, or DONE if there are fewer than |n| boundaries in the specfied direction. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000019">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a0fbb590a8a0f62627afe40ce4b4f5730">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a68f3b6be789195b55204a6d86d58a8ad"></a><!-- doxytag: member="BreakIterator::next" ref="a68f3b6be789195b55204a6d86d58a8ad" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the boundary following the current boundary. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character index of the next text boundary or DONE if all boundaries have been returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000014">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a16fe1b082e7e67d9f0dbc3c277c642d7">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a188fb5d54bae55e4f9ea9730e44919a5"></a><!-- doxytag: member="BreakIterator::operator!=" ref="a188fb5d54bae55e4f9ea9730e44919a5" args="(const BreakIterator &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> BreakIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the complement of the result of operator==. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> to be compared for inequality </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the complement of the result of operator== </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000003">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="brkiter_8h_source.html#l00129">129</a> of file <a class="el" href="brkiter_8h_source.html">brkiter.h</a>.</p>

<p>References <a class="el" href="stringpiece_8h.html#a7652049cbac0bfeae2cd2aa4514a3352">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="adef035120a8805b350ae7ec789b43093"></a><!-- doxytag: member="BreakIterator::operator==" ref="adef035120a8805b350ae7ec789b43093" args="(const BreakIterator &amp;) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> BreakIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if another object is semantically equal to this one. </p>
<p>The other object should be an instance of the same subclass of <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>. Objects of different subclasses are considered unequal. </p>
<p>Return true if this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> is at the same position in the same text, and is the same class and type (word, line, etc.) of <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>, as the argument. Text is considered the same if it contains the same characters, it need not be the same object, and styles are not considered. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000002">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9230e330fd08bad1b6c278d322ef2385"></a><!-- doxytag: member="BreakIterator::preceding" ref="a9230e330fd08bad1b6c278d322ef2385" args="(int32_t offset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::preceding </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the first boundary preceding the specified offset. </p>
<p>The value returned is always smaller than the offset or the value <a class="el" href="classBreakIterator.html#a08bd7354c8ac72497a46bbe4d3f4a3feae32f847673a92726e06dfce66fea909c" title="DONE is returned by previous() and next() after all valid boundaries have been returned...">BreakIterator.DONE</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset to begin scanning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first boundary before the specified offset. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000017">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#af63093f20c0ab16c597d104573ed65f1">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="ac4f27d685b8c1bacbad7e27a6af141f2"></a><!-- doxytag: member="BreakIterator::previous" ref="ac4f27d685b8c1bacbad7e27a6af141f2" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t BreakIterator::previous </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the boundary preceding the current boundary. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character index of the previous text boundary or DONE if all boundaries have been returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000013">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a9aad4e7020f9a0b7b7627ee8ce0c2e9c">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a25f88e97609e60d6efd832869e3a8f20"></a><!-- doxytag: member="BreakIterator::registerInstance" ref="a25f88e97609e60d6efd832869e3a8f20" args="(BreakIterator *toAdopt, const Locale &amp;locale, UBreakIteratorType kind, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a> BreakIterator::registerInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>toAdopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocale.html">Locale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a new break iterator of the indicated kind, to use in the given locale. </p>
<p>The break iterator will be adopted. Clones of the iterator will be returned if a request for a break iterator of the given kind matches or falls back to this locale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toAdopt</em>&nbsp;</td><td>the <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> instance to be adopted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locale</em>&nbsp;</td><td>the <a class="el" href="classLocale.html" title="A Locale object represents a specific geographical, political, or cultural region...">Locale</a> for which this instance is to be registered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>the type of iterator for which this instance is to be registered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>the in/out status code, no special meanings are assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a registry key that can be used to unregister this instance </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000030">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a74d79d97bbc2265753486704111d29eb"></a><!-- doxytag: member="BreakIterator::setText" ref="a74d79d97bbc2265753486704111d29eb" args="(UText *text, UErrorCode &amp;status)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p>The iterator position is reset to the start.</p>
<p>This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a>. This means that the caller is free to immediately close or otherwise reuse the Utext that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> used to change the text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000009">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#aeb3cf0fe922a95d24978a3014c8f79b2">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="ac50a6618fe83b9b96a7a9213c5da3f21"></a><!-- doxytag: member="BreakIterator::setText" ref="ac50a6618fe83b9b96a7a9213c5da3f21" args="(const UnicodeString &amp;text)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the text over which this operates. </p>
<p>The text boundary is reset to the start. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a> used to change the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000008">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classRuleBasedBreakIterator.html#a3c43a81c024eb388aa807557ec1218fd">RuleBasedBreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a4c010d2a3f111fd49801eabe28375096"></a><!-- doxytag: member="BreakIterator::unregister" ref="a4c010d2a3f111fd49801eabe28375096" args="(URegistryKey key, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> BreakIterator::unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregister a previously-registered <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> using the key returned from the register call. </p>
<p>Key becomes invalid after a successful call and should not be used again. The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> corresponding to the key will be deleted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the registry key returned by a previous call to registerInstance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>the in/out status code, no special meanings are assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the iterator for the key was successfully unregistered </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000031">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a9fa7a1741b71fa9b2228455b0dad3c6a"></a><!-- doxytag: member="BreakIterator::fBufferClone" ref="a9fa7a1741b71fa9b2228455b0dad3c6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> <a class="el" href="classBreakIterator.html#a9fa7a1741b71fa9b2228455b0dad3c6a">BreakIterator::fBufferClone</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000014">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="brkiter_8h_source.html#l00529">529</a> of file <a class="el" href="brkiter_8h_source.html">brkiter.h</a>.</p>

<p>Referenced by <a class="el" href="brkiter_8h_source.html#l00546">isBufferClone()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="brkiter_8h_source.html">brkiter.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Jul 26 12:56:57 2011 for ICU 4.8.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
