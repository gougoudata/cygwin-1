<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ICU 4.8.1: RuleBasedBreakIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RuleBasedBreakIterator Class Reference</h1><!-- doxytag: class="RuleBasedBreakIterator" --><!-- doxytag: inherits="BreakIterator" -->
<p>A subclass of <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose behavior is specified using a list of rules.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rbbi_8h_source.html">rbbi.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RuleBasedBreakIterator:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRuleBasedBreakIterator.gif" usemap="#RuleBasedBreakIterator_map" alt=""/>
  <map id="RuleBasedBreakIterator_map" name="RuleBasedBreakIterator_map">
<area href="classBreakIterator.html" alt="BreakIterator" shape="rect" coords="0,112,145,136"/>
<area href="classUObject.html" alt="UObject" shape="rect" coords="0,56,145,80"/>
<area href="classUMemory.html" alt="UMemory" shape="rect" coords="0,0,145,24"/>
</map>
 </div>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ac29e42ef56e0756152c830a23bd5adfb">RuleBasedBreakIterator</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#ac29e42ef56e0756152c830a23bd5adfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ab601ffba9b8c11489d506a726027db32">RuleBasedBreakIterator</a> (const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#ab601ffba9b8c11489d506a726027db32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a93f3f8807dc8bc2fcbb287a59c665003">RuleBasedBreakIterator</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;rules, <a class="el" href="structUParseError.html">UParseError</a> &amp;parseError, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string.  <a href="#a93f3f8807dc8bc2fcbb287a59c665003"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a14410c3cd486a28941980a5577dfa7ac">RuleBasedBreakIterator</a> (const uint8_t *compiledRules, uint32_t ruleLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contruct a <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of precompiled binary rules.  <a href="#a14410c3cd486a28941980a5577dfa7ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a1ab0da227d0a45942c29f2a5df3639cb">RuleBasedBreakIterator</a> (<a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *image, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor uses the udata interface to create a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose internal tables live in a memory-mapped file.  <a href="#a1ab0da227d0a45942c29f2a5df3639cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#af97d5993340441b4470508d5063e7662">~RuleBasedBreakIterator</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#af97d5993340441b4470508d5063e7662"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ad6f0b26c45901e817d693008bf03078c">operator=</a> (const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#ad6f0b26c45901e817d693008bf03078c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#af1e72eda19a90fd2a729bddd824345d7">operator==</a> (const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;that) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#af1e72eda19a90fd2a729bddd824345d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a830c4be152a82f2a80e6059c00ad3451">operator!=</a> (const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;that) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not-equal operator.  <a href="#a830c4be152a82f2a80e6059c00ad3451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a805badacaa522dee2ec8c3e09ab5659f">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a newly-constructed <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one.  <a href="#a805badacaa522dee2ec8c3e09ab5659f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a01daa6b1966339e69d7e4e805f193491">hashCode</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a hash code for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>.  <a href="#a01daa6b1966339e69d7e4e805f193491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a813110eca17a45c2563c623a1ed9d5f1">getRules</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the description used to create this iterator.  <a href="#a813110eca17a45c2563c623a1ed9d5f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCharacterIterator.html">CharacterIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a21542dea2f8d1d12629484f38292301d">getText</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#aafe5882170adf4e756d077db58cce0a4">getUText</a> (<a class="el" href="structUText.html">UText</a> *fillIn, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed.  <a href="#aafe5882170adf4e756d077db58cce0a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a002e744aad6039dd379f63225052f0b1">adoptText</a> (<a class="el" href="classCharacterIterator.html">CharacterIterator</a> *newText)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="#a002e744aad6039dd379f63225052f0b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a3c43a81c024eb388aa807557ec1218fd">setText</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;newText)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="#a3c43a81c024eb388aa807557ec1218fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#aeb3cf0fe922a95d24978a3014c8f79b2">setText</a> (<a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="#aeb3cf0fe922a95d24978a3014c8f79b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a45707d96406f1b0027ce65c79ac36c67">first</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current iteration position to the beginning of the text.  <a href="#a45707d96406f1b0027ce65c79ac36c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ab57d12a60328d31fbc859591d9fd1272">last</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current iteration position to the end of the text.  <a href="#ab57d12a60328d31fbc859591d9fd1272"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a0fbb590a8a0f62627afe40ce4b4f5730">next</a> (int32_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the iterator either forward or backward the specified number of steps.  <a href="#a0fbb590a8a0f62627afe40ce4b4f5730"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a16fe1b082e7e67d9f0dbc3c277c642d7">next</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the iterator to the next boundary position.  <a href="#a16fe1b082e7e67d9f0dbc3c277c642d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a9aad4e7020f9a0b7b7627ee8ce0c2e9c">previous</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the iterator backwards, to the last boundary preceding this one.  <a href="#a9aad4e7020f9a0b7b7627ee8ce0c2e9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a0407bc1809b35c7af19cfa0539067841">following</a> (int32_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the iterator to refer to the first boundary position following the specified position.  <a href="#a0407bc1809b35c7af19cfa0539067841"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#af63093f20c0ab16c597d104573ed65f1">preceding</a> (int32_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the iterator to refer to the last boundary position before the specified position.  <a href="#af63093f20c0ab16c597d104573ed65f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ad23e9f31feed57dee61b1d45fcb3dbfc">isBoundary</a> (int32_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the specfied position is a boundary position.  <a href="#ad23e9f31feed57dee61b1d45fcb3dbfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ac7083ccc926c0b72c08ea105a01321c8">current</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current iteration position.  <a href="#ac7083ccc926c0b72c08ea105a01321c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a827e0fe5c71af0c2608304cf54e6400f">getRuleStatus</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status tag from the break rule that determined the most recently returned break position.  <a href="#a827e0fe5c71af0c2608304cf54e6400f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a924d98d0bc7aea9568034c5257542d0c">getRuleStatusVec</a> (int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the status (tag) values from the break rule(s) that determined the most recently returned break position.  <a href="#a924d98d0bc7aea9568034c5257542d0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ac601c2347870413f79995d843687a470">getDynamicClassID</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a unique class ID POLYMORPHICALLY.  <a href="#ac601c2347870413f79995d843687a470"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a3e120994761da087377fb1e6b5dccf18">createBufferClone</a> (void *stackBuffer, int32_t &amp;BufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone, since 'new' is not used to create it.  <a href="#a3e120994761da087377fb1e6b5dccf18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a1852625b37eccd5b78a8c6993e49b309">getBinaryRules</a> (uint32_t &amp;length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future.  <a href="#a1852625b37eccd5b78a8c6993e49b309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#adec544981344804a4abb5fd3b3826d7d">setBreakType</a> (int32_t type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the type of the break iterator.  <a href="#adec544981344804a4abb5fd3b3826d7d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#adc73faf663185bdd27441bd42f97a68a">getStaticClassID</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the class ID for this class.  <a href="#adc73faf663185bdd27441bd42f97a68a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a9c2fe7d0ff5c34db34f68ffd1013d970">EDontAdopt</a> { <b>kDontAdopt</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constant to be used in the constructor RuleBasedBreakIterator(RBBIDataHeader*, EDontAdopt, UErrorCode &amp;); which does not adopt the memory indicated by the RBBIDataHeader* parameter. </p>
 <a href="classRuleBasedBreakIterator.html#a9c2fe7d0ff5c34db34f68ffd1013d970">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#aa57ab1ae99efe23f07a73ddf4389027c">RuleBasedBreakIterator</a> (RBBIDataHeader *data, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from a flattened set of RBBI data in malloced memory.  <a href="#aa57ab1ae99efe23f07a73ddf4389027c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a283a483beab67abaf35a36ac9a462ad2">RuleBasedBreakIterator</a> (const RBBIDataHeader *data, enum <a class="el" href="classRuleBasedBreakIterator.html#a9c2fe7d0ff5c34db34f68ffd1013d970">EDontAdopt</a> dontAdopt, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from a flattened set of RBBI data in memory which need not be malloced (e.g.  <a href="#a283a483beab67abaf35a36ac9a462ad2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a5052a806f483ca004e8197a27b7d0ce4">reset</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps caches and performs other actions associated with a complete change in text or iteration position.  <a href="#a5052a806f483ca004e8197a27b7d0ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#adbb69236c763c8b7abdac190964c3d1a">init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common initialization function, used by constructors and bufferClone.  <a href="#adbb69236c763c8b7abdac190964c3d1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a7a4dd96ffe78373ff59af253d95d4d2c">checkDictionary</a> (int32_t startPos, int32_t endPos, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> reverse)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the function that actually implements dictionary-based breaking.  <a href="#a7a4dd96ffe78373ff59af253d95d4d2c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a419b7e787fe701da59edf938ec338348">fText</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structUText.html" title="UText struct.">UText</a> through which this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> accesses the text.  <a href="#a419b7e787fe701da59edf938ec338348"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCharacterIterator.html">CharacterIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ae31cd176a5f569eeaad260232078e1c4">fCharIter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A character iterator that refers to the same text as the <a class="el" href="structUText.html" title="UText struct.">UText</a>, above.  <a href="#ae31cd176a5f569eeaad260232078e1c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStringCharacterIterator.html">StringCharacterIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ab167d8622058e5c0d417dd43ef83edda">fSCharIter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When the input text is provided by a <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a>, this will point to a characterIterator that wraps that data.  <a href="#ab167d8622058e5c0d417dd43ef83edda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad276784df08fcac79d039533a1341cdb"></a><!-- doxytag: member="RuleBasedBreakIterator::fDCharIter" ref="ad276784df08fcac79d039533a1341cdb" args="" -->
<a class="el" href="classUCharCharacterIterator.html">UCharCharacterIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ad276784df08fcac79d039533a1341cdb">fDCharIter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When the input text is provided by a <a class="el" href="structUText.html" title="UText struct.">UText</a>, this dummy <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over an empty string will be returned from <a class="el" href="classBreakIterator.html#ab12b76622eaa6df7d0df48778f5de1aa" title="Return a CharacterIterator over the text being analyzed.">getText()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RBBIDataWrapper *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a9e4c4ce2df8bd5ec86eb24029f536fc1">fData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rule data for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> instance.  <a href="#a9e4c4ce2df8bd5ec86eb24029f536fc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a0334069f3c4a9384836be7e76f8553a3">fLastRuleStatusIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of the Rule {tag} values for the most recent match.  <a href="#a0334069f3c4a9384836be7e76f8553a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a724ee27f3375cb4a18a0268ddddc4e78">fLastStatusIndexValid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule tag value valid flag.  <a href="#a724ee27f3375cb4a18a0268ddddc4e78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a7491e4622823085f822618797ac62643">fDictionaryCharCount</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counter for the number of characters encountered with the "dictionary" flag set.  <a href="#a7491e4622823085f822618797ac62643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a56b061a55c91c2f45263213b4188e19d">fCachedBreakPositions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When a range of characters is divided up using the dictionary, the break positions that are discovered are stored here, preventing us from having to use either the dictionary or the state table again until the iterator leaves this range of text.  <a href="#a56b061a55c91c2f45263213b4188e19d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#ae592ba2301f6064f2f50d70196517886">fNumCachedBreakPositions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of elements in fCachedBreakPositions.  <a href="#ae592ba2301f6064f2f50d70196517886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a65ae2b4eadd5389543d7b69d2c965c9f">fPositionInCache</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if fCachedBreakPositions is not null, this indicates which item in the cache the current iteration position refers to  <a href="#a65ae2b4eadd5389543d7b69d2c965c9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UStack *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#af7beaa3fd16091bd2dec10e67ccec22f">fLanguageBreakEngines</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If present, UStack of LanguageBreakEngine objects that might handle dictionary characters.  <a href="#af7beaa3fd16091bd2dec10e67ccec22f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UnhandledEngine *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a6f39d4df45fbf35c61ac58df2746f1e9">fUnhandledBreakEngine</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If present, the special LanguageBreakEngine used for handling characters that are in the dictionary set, but not handled by any LangugageBreakEngine.  <a href="#a6f39d4df45fbf35c61ac58df2746f1e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#af2304ecb86e7e4e50c3aab9f4b0c1aef">fBreakType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the break iterator, or -1 if it has not been set.  <a href="#af2304ecb86e7e4e50c3aab9f4b0c1aef"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17ce03f12f5fa8688859b25e2bf60938"></a><!-- doxytag: member="RuleBasedBreakIterator::RBBIRuleBuilder" ref="a17ce03f12f5fa8688859b25e2bf60938" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>RBBIRuleBuilder</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBasedBreakIterator.html#a5fbb7407696454879cf016b20a0380f0">BreakIterator</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A subclass of <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose behavior is specified using a list of rules. </p>
<p>Instances of this class are most commonly created by the factory methods of <a class="el" href="classBreakIterator.html#afc0385b348d5156de7cc45f34ba660fa" title="Create BreakIterator for word-breaks using the given locale.">BreakIterator::createWordInstance()</a>, <a class="el" href="classBreakIterator.html#a83ed35d09a8ab8b18ace13e073cf8434" title="Create BreakIterator for line-breaks using specified locale.">BreakIterator::createLineInstance()</a>, etc., and then used via the abstract API in class <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a></p>
<p>See the ICU User Guide for information on Break Iterator Rules.</p>
<p>This class is not intended to be subclassed. (Class DictionaryBasedBreakIterator is a subclass, but that relationship is effectively internal to the ICU implementation. The subclassing interface to RulesBasedBreakIterator is not part of the ICU API, and may not remain stable. </p>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00065">65</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a9c2fe7d0ff5c34db34f68ffd1013d970"></a><!-- doxytag: member="RuleBasedBreakIterator::EDontAdopt" ref="a9c2fe7d0ff5c34db34f68ffd1013d970" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRuleBasedBreakIterator.html#a9c2fe7d0ff5c34db34f68ffd1013d970">RuleBasedBreakIterator::EDontAdopt</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant to be used in the constructor RuleBasedBreakIterator(RBBIDataHeader*, EDontAdopt, UErrorCode &amp;); which does not adopt the memory indicated by the RBBIDataHeader* parameter. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000074">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00181">181</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa57ab1ae99efe23f07a73ddf4389027c"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="aa57ab1ae99efe23f07a73ddf4389027c" args="(RBBIDataHeader *data, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">RBBIDataHeader *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor from a flattened set of RBBI data in malloced memory. </p>
<p>RulesBasedBreakIterators built from a custom set of rules are created via this constructor; the rules are compiled into memory, then the break iterator is constructed here.</p>
<p>The break iterator adopts the memory, and will free it when done. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000075">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="a283a483beab67abaf35a36ac9a462ad2"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="a283a483beab67abaf35a36ac9a462ad2" args="(const RBBIDataHeader *data, enum EDontAdopt dontAdopt, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const RBBIDataHeader *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="classRuleBasedBreakIterator.html#a9c2fe7d0ff5c34db34f68ffd1013d970">EDontAdopt</a>&nbsp;</td>
          <td class="paramname"> <em>dontAdopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor from a flattened set of RBBI data in memory which need not be malloced (e.g. </p>
<p>it may be a memory-mapped file, etc.).</p>
<p>This version does not adopt the memory, and does not free it when done. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000076">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="ac29e42ef56e0756152c830a23bd5adfb"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="ac29e42ef56e0756152c830a23bd5adfb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty shell of an iterator, with no rules or text to iterate over. Object can subsequently be assigned to. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000288">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="ab601ffba9b8c11489d506a726027db32"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="ab601ffba9b8c11489d506a726027db32" args="(const RuleBasedBreakIterator &amp;that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Will produce a break iterator with the same behavior, and which iterates over the same text, as the one passed in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> passed to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000289">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a93f3f8807dc8bc2fcbb287a59c665003"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="a93f3f8807dc8bc2fcbb287a59c665003" args="(const UnicodeString &amp;rules, UParseError &amp;parseError, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parseError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rules</em>&nbsp;</td><td>The break rules to be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parseError</em>&nbsp;</td><td>In the event of a syntax error in the rules, provides the location within the rules of the problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000290">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a14410c3cd486a28941980a5577dfa7ac"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="a14410c3cd486a28941980a5577dfa7ac" args="(const uint8_t *compiledRules, uint32_t ruleLength, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>compiledRules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>ruleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Contruct a <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of precompiled binary rules. </p>
<p>Binary rules are obtained from RulesBasedBreakIterator::getBinaryRules(). Construction of a break iterator in this way is substantially faster than constuction from source rules.</p>
<p>Ownership of the storage containing the compiled rules remains with the caller of this function. The compiled rules must not be modified or deleted during the life of the break iterator.</p>
<p>The compiled rules are not compatible across different major versions of ICU. The compiled rules are comaptible only between machines with the same byte ordering (little or big endian) and the same base character set family (ASCII or EBCDIC).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRuleBasedBreakIterator.html#a1852625b37eccd5b78a8c6993e49b309" title="Return the binary form of compiled break rules, which can then be used to create...">getBinaryRules</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>compiledRules</em>&nbsp;</td><td>A pointer to the compiled break rules to be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ruleLength</em>&nbsp;</td><td>The length of the compiled break rules, in bytes. This corresponds to the length value produced by <a class="el" href="classRuleBasedBreakIterator.html#a1852625b37eccd5b78a8c6993e49b309" title="Return the binary form of compiled break rules, which can then be used to create...">getBinaryRules()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Information on any errors encountered, including invalid binary rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000138">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab0da227d0a45942c29f2a5df3639cb"></a><!-- doxytag: member="RuleBasedBreakIterator::RuleBasedBreakIterator" ref="a1ab0da227d0a45942c29f2a5df3639cb" args="(UDataMemory *image, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This constructor uses the udata interface to create a <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> whose internal tables live in a memory-mapped file. </p>
<p>"image" is an ICU UDataMemory handle for the pre-compiled break iterator tables. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>handle to the memory image for the break iterator data. Ownership of the UDataMemory handle passes to the Break Iterator, which will be responsible for closing it when it is no longer needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="udata_8h.html#a3d908d77900b182403a375793ad35a86" title="Convenience function.">udata_open</a> </dd>
<dd>
<a class="el" href="classRuleBasedBreakIterator.html#a1852625b37eccd5b78a8c6993e49b309" title="Return the binary form of compiled break rules, which can then be used to create...">getBinaryRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000291">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a class="anchor" id="af97d5993340441b4470508d5063e7662"></a><!-- doxytag: member="RuleBasedBreakIterator::~RuleBasedBreakIterator" ref="af97d5993340441b4470508d5063e7662" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RuleBasedBreakIterator::~RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000292">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a002e744aad6039dd379f63225052f0b1"></a><!-- doxytag: member="RuleBasedBreakIterator::adoptText" ref="a002e744aad6039dd379f63225052f0b1" args="(CharacterIterator *newText)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::adoptText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCharacterIterator.html">CharacterIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>newText</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p>This function resets the current iteration position to the beginning of the text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newText</em>&nbsp;</td><td>An iterator over the text to analyze. The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> takes ownership of the character iterator. The caller MUST NOT delete it! </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000301">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a729dbe9a6437070d9fb056c6c7589563">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a7a4dd96ffe78373ff59af253d95d4d2c"></a><!-- doxytag: member="RuleBasedBreakIterator::checkDictionary" ref="a7a4dd96ffe78373ff59af253d95d4d2c" args="(int32_t startPos, int32_t endPos, UBool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t RuleBasedBreakIterator::checkDictionary </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the function that actually implements dictionary-based breaking. </p>
<p>Covering at least the range from startPos to endPos, it checks for dictionary characters, and if it finds them determines the appropriate object to deal with them. It may cache found breaks in fCachedBreakPositions as it goes. It may well also look at text outside the range startPos to endPos. If going forward, endPos is the normal Unicode break result, and if goind in reverse, startPos is the normal Unicode break result </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startPos</em>&nbsp;</td><td>The start position of a range of text </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endPos</em>&nbsp;</td><td>The end position of a range of text </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>The call is for the reverse direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000083">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="a805badacaa522dee2ec8c3e09ab5659f"></a><!-- doxytag: member="RuleBasedBreakIterator::clone" ref="a805badacaa522dee2ec8c3e09ab5659f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a>* RuleBasedBreakIterator::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a newly-constructed <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one. </p>
<p>Differs from the copy constructor in that it is polymorphic, and will correctly clone (copy) a derived class. <a class="el" href="classBreakIterator.html#aa17a81d41fa791049a10c37594dad88f" title="Return a polymorphic copy of this object.">clone()</a> is thread safe. Multiple threads may simultaeneously clone the same source break iterator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly-constructed <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000296">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#aa17a81d41fa791049a10c37594dad88f">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a3e120994761da087377fb1e6b5dccf18"></a><!-- doxytag: member="RuleBasedBreakIterator::createBufferClone" ref="a3e120994761da087377fb1e6b5dccf18" args="(void *stackBuffer, int32_t &amp;BufferSize, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBreakIterator.html">BreakIterator</a>* RuleBasedBreakIterator::createBufferClone </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone, since 'new' is not used to create it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stackBuffer</em>&nbsp;</td><td>user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferSize</em>&nbsp;</td><td>reference to size of allocated space. If BufferSize == 0, a sufficient size for use in cloning will be returned ('pre-flighting') If BufferSize is not enough for a stack-based safe clone, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_ERROR, is used if any allocations were necessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the new clone</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000028">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a6ea0e9828c9ef650086f4d3a17ce5c61">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="ac7083ccc926c0b72c08ea105a01321c8"></a><!-- doxytag: member="RuleBasedBreakIterator::current" ref="ac7083ccc926c0b72c08ea105a01321c8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::current </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current iteration position. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current iteration position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000312">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a36835a8123d823f333af822d9c7cb8a6">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a45707d96406f1b0027ce65c79ac36c67"></a><!-- doxytag: member="RuleBasedBreakIterator::first" ref="a45707d96406f1b0027ce65c79ac36c67" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::first </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the current iteration position to the beginning of the text. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The offset of the beginning of the text. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000304">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#ae09bd26e3559e18e8e46699075f477e4">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a0407bc1809b35c7af19cfa0539067841"></a><!-- doxytag: member="RuleBasedBreakIterator::following" ref="a0407bc1809b35c7af19cfa0539067841" args="(int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::following </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the iterator to refer to the first boundary position following the specified position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position from which to begin searching for a break position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The position of the first break after the current position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000309">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a57f98a77f67b2ca34c26ee2e77d76e09">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a1852625b37eccd5b78a8c6993e49b309"></a><!-- doxytag: member="RuleBasedBreakIterator::getBinaryRules" ref="a1852625b37eccd5b78a8c6993e49b309" args="(uint32_t &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const uint8_t* RuleBasedBreakIterator::getBinaryRules </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future. </p>
<p>Creating a break iterator from pre-compiled rules is much faster than building one from the source form of the break rules.</p>
<p>The binary data can only be used with the same version of ICU and on the same platform type (processor endian-ness)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Returns the length of the binary data. (Out paramter.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the binary (compiled) rule data. The storage belongs to the RulesBasedBreakIterator object, not the caller, and must not be modified or deleted. </dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000139">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.8 </dd></dl>

</div>
</div>
<a class="anchor" id="ac601c2347870413f79995d843687a470"></a><!-- doxytag: member="RuleBasedBreakIterator::getDynamicClassID" ref="ac601c2347870413f79995d843687a470" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> RuleBasedBreakIterator::getDynamicClassID </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a unique class ID POLYMORPHICALLY. </p>
<p>Pure virtual override. This method is to implement a simple version of RTTI, since not all C++ compilers support genuine RTTI. Polymorphic <a class="el" href="classRuleBasedBreakIterator.html#af1e72eda19a90fd2a729bddd824345d7" title="Equality operator.">operator==()</a> and <a class="el" href="classBreakIterator.html#aa17a81d41fa791049a10c37594dad88f" title="Return a polymorphic copy of this object.">clone()</a> methods call this method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The class ID for this object. All objects of a given class have the same class ID. Objects of other classes have different class IDs. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000315">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#aeaf98baae1d91e224ef8ccced5d2266c">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a813110eca17a45c2563c623a1ed9d5f1"></a><!-- doxytag: member="RuleBasedBreakIterator::getRules" ref="a813110eca17a45c2563c623a1ed9d5f1" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classUnicodeString.html">UnicodeString</a>&amp; RuleBasedBreakIterator::getRules </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the description used to create this iterator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the description used to create this iterator </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000298">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a827e0fe5c71af0c2608304cf54e6400f"></a><!-- doxytag: member="RuleBasedBreakIterator::getRuleStatus" ref="a827e0fe5c71af0c2608304cf54e6400f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::getRuleStatus </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status tag from the break rule that determined the most recently returned break position. </p>
<p>For break rules that do not specify a status, a default value of 0 is returned. If more than one break rule would cause a boundary to be located at some position in the text, the numerically largest of the applicable status values is returned. </p>
<p>Of the standard types of ICU break iterators, only word break and line break provide status values. The values are defined in the header file <a class="el" href="ubrk_8h.html" title="C API: BreakIterator.">ubrk.h</a>. For Word breaks, the status allows distinguishing between words that contain alphabetic letters, "words" that appear to be numbers, punctuation and spaces, words containing ideographic characters, and more. For Line Break, the status distinguishes between hard (mandatory) breaks and soft (potential) break positions. </p>
<p><code><a class="el" href="classRuleBasedBreakIterator.html#a827e0fe5c71af0c2608304cf54e6400f" title="Return the status tag from the break rule that determined the most recently returned...">getRuleStatus()</a></code> can be called after obtaining a boundary position from <code><a class="el" href="classRuleBasedBreakIterator.html#a16fe1b082e7e67d9f0dbc3c277c642d7" title="Advances the iterator to the next boundary position.">next()</a></code>, <code><a class="el" href="classRuleBasedBreakIterator.html#a9aad4e7020f9a0b7b7627ee8ce0c2e9c" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a></code>, or any other break iterator functions that returns a boundary position. </p>
<p>When creating custom break rules, one is free to define whatever status values may be convenient for the application. </p>
<p>Note: this function is not thread safe. It should not have been declared const, and the const remains only for compatibility reasons. (The function is logically const, but not bit-wise const). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the status from the break rule that determined the most recently returned break position.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9" title="Enum constants for the word break tags returned by getRuleStatus().">UWordBreak</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000313">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a924d98d0bc7aea9568034c5257542d0c"></a><!-- doxytag: member="RuleBasedBreakIterator::getRuleStatusVec" ref="a924d98d0bc7aea9568034c5257542d0c" args="(int32_t *fillInVec, int32_t capacity, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::getRuleStatusVec </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the status (tag) values from the break rule(s) that determined the most recently returned break position. </p>
<p>The returned status value(s) are stored into an array provided by the caller. The values are stored in sorted (ascending) order. If the capacity of the output array is insufficient to hold the data, the output will be truncated to the available length, and a U_BUFFER_OVERFLOW_ERROR will be signaled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fillInVec</em>&nbsp;</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>capacity</em>&nbsp;</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attemtping to store any values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of rule status values from rules that determined the most recent boundary returned by the break iterator. In the event of a U_BUFFER_OVERFLOW_ERROR, the return value is the total number of status values that were available, not the reduced number that were actually returned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRuleBasedBreakIterator.html#a827e0fe5c71af0c2608304cf54e6400f" title="Return the status tag from the break rule that determined the most recently returned...">getRuleStatus</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000314">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adc73faf663185bdd27441bd42f97a68a"></a><!-- doxytag: member="RuleBasedBreakIterator::getStaticClassID" ref="adc73faf663185bdd27441bd42f97a68a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> RuleBasedBreakIterator::getStaticClassID </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the class ID for this class. </p>
<p>This is useful only for comparing to a return value from <a class="el" href="classRuleBasedBreakIterator.html#ac601c2347870413f79995d843687a470" title="Returns a unique class ID POLYMORPHICALLY.">getDynamicClassID()</a>. For example:</p>
<p>Base* polymorphic_pointer = createPolymorphicObject(); if (polymorphic_pointer-&gt;<a class="el" href="classRuleBasedBreakIterator.html#ac601c2347870413f79995d843687a470" title="Returns a unique class ID POLYMORPHICALLY.">getDynamicClassID()</a> == Derived::getStaticClassID()) ...</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The class ID for all objects of this class. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000316">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a21542dea2f8d1d12629484f38292301d"></a><!-- doxytag: member="RuleBasedBreakIterator::getText" ref="a21542dea2f8d1d12629484f38292301d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCharacterIterator.html">CharacterIterator</a>&amp; RuleBasedBreakIterator::getText </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over the text being analyzed. The returned character iterator is owned by the break iterator, and must not be deleted by the caller. Repeated calls to this function may return the same <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a>.  </p>
<p>The returned character iterator must not be used concurrently with the break iterator. If concurrent operation is needed, clone the returned character iterator first and operate on the clone.  </p>
<p>When the break iterator is operating on text supplied via a <a class="el" href="structUText.html" title="UText struct.">UText</a>, this function will fail. Lacking any way to signal failures, it returns an <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> containing no text. The function <a class="el" href="classRuleBasedBreakIterator.html#aafe5882170adf4e756d077db58cce0a4" title="Get a UText for the text being analyzed.">getUText()</a> provides similar functionality, is reliable, and is more efficient. </p>
<p>TODO: deprecate this function?</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator over the text being analyzed. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000299">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#ab12b76622eaa6df7d0df48778f5de1aa">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="aafe5882170adf4e756d077db58cce0a4"></a><!-- doxytag: member="RuleBasedBreakIterator::getUText" ref="aafe5882170adf4e756d077db58cce0a4" args="(UText *fillIn, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RuleBasedBreakIterator::getUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>fillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed. </p>
<p>The returned <a class="el" href="structUText.html" title="UText struct.">UText</a> is a shallow clone of the <a class="el" href="structUText.html" title="UText struct.">UText</a> used internally by the break iterator implementation. It can safely be used to access the text without impacting any break iterator operations, but the underlying text itself must not be altered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fillIn</em>&nbsp;</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> to be filled in. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be allocated to hold the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current <a class="el" href="structUText.html" title="UText struct.">UText</a> for this break iterator. If an input <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000300">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a724d55795f3edb7748e6d6dffd80d926">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a01daa6b1966339e69d7e4e805f193491"></a><!-- doxytag: member="RuleBasedBreakIterator::hashCode" ref="a01daa6b1966339e69d7e4e805f193491" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::hashCode </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a hash code for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A hash code </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000297">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adbb69236c763c8b7abdac190964c3d1a"></a><!-- doxytag: member="RuleBasedBreakIterator::init" ref="adbb69236c763c8b7abdac190964c3d1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RuleBasedBreakIterator::init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Common initialization function, used by constructors and bufferClone. </p>
<p>(Also used by <a class="el" href="classRuleBasedBreakIterator.html#a3e120994761da087377fb1e6b5dccf18" title="Thread safe client-buffer-based cloning operation Do NOT call delete on a safeclone...">DictionaryBasedBreakIterator::createBufferClone()</a>.) </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000080">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="ad23e9f31feed57dee61b1d45fcb3dbfc"></a><!-- doxytag: member="RuleBasedBreakIterator::isBoundary" ref="ad23e9f31feed57dee61b1d45fcb3dbfc" args="(int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RuleBasedBreakIterator::isBoundary </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the specfied position is a boundary position. </p>
<p>As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000311">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a9ac740557f08c879cceffdbb4a15fe7b">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="ab57d12a60328d31fbc859591d9fd1272"></a><!-- doxytag: member="RuleBasedBreakIterator::last" ref="ab57d12a60328d31fbc859591d9fd1272" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::last </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the current iteration position to the end of the text. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The text's past-the-end offset. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000305">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#ab21a3083a947dd4b4f3653a0a51080c2">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a16fe1b082e7e67d9f0dbc3c277c642d7"></a><!-- doxytag: member="RuleBasedBreakIterator::next" ref="a16fe1b082e7e67d9f0dbc3c277c642d7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Advances the iterator to the next boundary position. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The position of the first boundary after this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000307">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a68f3b6be789195b55204a6d86d58a8ad">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a0fbb590a8a0f62627afe40ce4b4f5730"></a><!-- doxytag: member="RuleBasedBreakIterator::next" ref="a0fbb590a8a0f62627afe40ce4b4f5730" args="(int32_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Advances the iterator either forward or backward the specified number of steps. </p>
<p>Negative values move backward, and positive values move forward. This is equivalent to repeatedly calling <a class="el" href="classRuleBasedBreakIterator.html#a16fe1b082e7e67d9f0dbc3c277c642d7" title="Advances the iterator to the next boundary position.">next()</a> or <a class="el" href="classRuleBasedBreakIterator.html#a9aad4e7020f9a0b7b7627ee8ce0c2e9c" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number of steps to move. The sign indicates the direction (negative is backwards, and positive is forwards). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character offset of the boundary position n boundaries away from the current one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000306">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#abc5223195e31b93657dffa305592bcd7">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a830c4be152a82f2a80e6059c00ad3451"></a><!-- doxytag: member="RuleBasedBreakIterator::operator!=" ref="a830c4be152a82f2a80e6059c00ad3451" args="(const BreakIterator &amp;that) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RuleBasedBreakIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Not-equal operator. </p>
<p>If operator== returns TRUE, this returns FALSE, and vice versa. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> to be compared for inequality </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if both BreakIterators are not same. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000295">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00746">746</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

<p>References <a class="el" href="classRuleBasedBreakIterator.html#af1e72eda19a90fd2a729bddd824345d7">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6f0b26c45901e817d693008bf03078c"></a><!-- doxytag: member="RuleBasedBreakIterator::operator=" ref="ad6f0b26c45901e817d693008bf03078c" args="(const RuleBasedBreakIterator &amp;that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a>&amp; RuleBasedBreakIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<p>Sets this iterator to have the same behavior, and iterate over the same text, as the one passed in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The RuleBasedBreakItertor passed in </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created <a class="el" href="classRuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000293">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classBreakIterator.html">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="af1e72eda19a90fd2a729bddd824345d7"></a><!-- doxytag: member="RuleBasedBreakIterator::operator==" ref="af1e72eda19a90fd2a729bddd824345d7" args="(const BreakIterator &amp;that) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RuleBasedBreakIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBreakIterator.html">BreakIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality operator. </p>
<p>Returns TRUE if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>that</em>&nbsp;</td><td>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> to be compared for equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000294">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Referenced by <a class="el" href="rbbi_8h_source.html#l00746">operator!=()</a>.</p>

</div>
</div>
<a class="anchor" id="af63093f20c0ab16c597d104573ed65f1"></a><!-- doxytag: member="RuleBasedBreakIterator::preceding" ref="af63093f20c0ab16c597d104573ed65f1" args="(int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::preceding </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the iterator to refer to the last boundary position before the specified position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position to begin searching for a break from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The position of the last boundary before the starting position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000310">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a9230e330fd08bad1b6c278d322ef2385">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a9aad4e7020f9a0b7b7627ee8ce0c2e9c"></a><!-- doxytag: member="RuleBasedBreakIterator::previous" ref="a9aad4e7020f9a0b7b7627ee8ce0c2e9c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RuleBasedBreakIterator::previous </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the iterator backwards, to the last boundary preceding this one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The position of the last boundary position preceding this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000308">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#ac4f27d685b8c1bacbad7e27a6af141f2">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a5052a806f483ca004e8197a27b7d0ce4"></a><!-- doxytag: member="RuleBasedBreakIterator::reset" ref="a5052a806f483ca004e8197a27b7d0ce4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::reset </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dumps caches and performs other actions associated with a complete change in text or iteration position. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000078">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="adec544981344804a4abb5fd3b3826d7d"></a><!-- doxytag: member="RuleBasedBreakIterator::setBreakType" ref="adec544981344804a4abb5fd3b3826d7d" args="(int32_t type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::setBreakType </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the type of the break iterator. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000079">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb3cf0fe922a95d24978a3014c8f79b2"></a><!-- doxytag: member="RuleBasedBreakIterator::setText" ref="aeb3cf0fe922a95d24978a3014c8f79b2" args="(UText *text, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p>The iterator position is reset to the start.</p>
<p>This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a>. This means that the caller is free to immediately close or otherwise reuse the Utext that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> used to change the text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000303">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#a74d79d97bbc2265753486704111d29eb">BreakIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a3c43a81c024eb388aa807557ec1218fd"></a><!-- doxytag: member="RuleBasedBreakIterator::setText" ref="a3c43a81c024eb388aa807557ec1218fd" args="(const UnicodeString &amp;newText)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newText</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p>This function resets the current iteration position to the beginning of the text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newText</em>&nbsp;</td><td>The text to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000302">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classBreakIterator.html#ac50a6618fe83b9b96a7a9213c5da3f21">BreakIterator</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a5fbb7407696454879cf016b20a0380f0"></a><!-- doxytag: member="RuleBasedBreakIterator::BreakIterator" ref="a5fbb7407696454879cf016b20a0380f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBreakIterator.html">BreakIterator</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000077">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00210">210</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="af2304ecb86e7e4e50c3aab9f4b0c1aef"></a><!-- doxytag: member="RuleBasedBreakIterator::fBreakType" ref="af2304ecb86e7e4e50c3aab9f4b0c1aef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#af2304ecb86e7e4e50c3aab9f4b0c1aef">RuleBasedBreakIterator::fBreakType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of the break iterator, or -1 if it has not been set. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000073">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00166">166</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a56b061a55c91c2f45263213b4188e19d"></a><!-- doxytag: member="RuleBasedBreakIterator::fCachedBreakPositions" ref="a56b061a55c91c2f45263213b4188e19d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t* <a class="el" href="classRuleBasedBreakIterator.html#a56b061a55c91c2f45263213b4188e19d">RuleBasedBreakIterator::fCachedBreakPositions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When a range of characters is divided up using the dictionary, the break positions that are discovered are stored here, preventing us from having to use either the dictionary or the state table again until the iterator leaves this range of text. </p>
<p>Has the most impact for line breaking. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000068">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00128">128</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae31cd176a5f569eeaad260232078e1c4"></a><!-- doxytag: member="RuleBasedBreakIterator::fCharIter" ref="ae31cd176a5f569eeaad260232078e1c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCharacterIterator.html">CharacterIterator</a>* <a class="el" href="classRuleBasedBreakIterator.html#ae31cd176a5f569eeaad260232078e1c4">RuleBasedBreakIterator::fCharIter</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A character iterator that refers to the same text as the <a class="el" href="structUText.html" title="UText struct.">UText</a>, above. </p>
<p>Only included for compatibility with old API, which was based on CharacterIterators. Value may be adopted from outside, or one of fSCharIter or fDCharIter, below. </p>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00079">79</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e4c4ce2df8bd5ec86eb24029f536fc1"></a><!-- doxytag: member="RuleBasedBreakIterator::fData" ref="a9e4c4ce2df8bd5ec86eb24029f536fc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RBBIDataWrapper* <a class="el" href="classRuleBasedBreakIterator.html#a9e4c4ce2df8bd5ec86eb24029f536fc1">RuleBasedBreakIterator::fData</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rule data for this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> instance. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000064">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00099">99</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7491e4622823085f822618797ac62643"></a><!-- doxytag: member="RuleBasedBreakIterator::fDictionaryCharCount" ref="a7491e4622823085f822618797ac62643" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classRuleBasedBreakIterator.html#a7491e4622823085f822618797ac62643">RuleBasedBreakIterator::fDictionaryCharCount</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Counter for the number of characters encountered with the "dictionary" flag set. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000067">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00119">119</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="af7beaa3fd16091bd2dec10e67ccec22f"></a><!-- doxytag: member="RuleBasedBreakIterator::fLanguageBreakEngines" ref="af7beaa3fd16091bd2dec10e67ccec22f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UStack* <a class="el" href="classRuleBasedBreakIterator.html#af7beaa3fd16091bd2dec10e67ccec22f">RuleBasedBreakIterator::fLanguageBreakEngines</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If present, UStack of LanguageBreakEngine objects that might handle dictionary characters. </p>
<p>Searched from top to bottom to find an object to handle a given character. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000071">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00150">150</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0334069f3c4a9384836be7e76f8553a3"></a><!-- doxytag: member="RuleBasedBreakIterator::fLastRuleStatusIndex" ref="a0334069f3c4a9384836be7e76f8553a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#a0334069f3c4a9384836be7e76f8553a3">RuleBasedBreakIterator::fLastRuleStatusIndex</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of the Rule {tag} values for the most recent match. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000065">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00104">104</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a724ee27f3375cb4a18a0268ddddc4e78"></a><!-- doxytag: member="RuleBasedBreakIterator::fLastStatusIndexValid" ref="a724ee27f3375cb4a18a0268ddddc4e78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> <a class="el" href="classRuleBasedBreakIterator.html#a724ee27f3375cb4a18a0268ddddc4e78">RuleBasedBreakIterator::fLastStatusIndexValid</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rule tag value valid flag. </p>
<p>Some iterator operations don't intrinsically set the correct tag value. This flag lets us lazily compute the value if we are ever asked for it. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000066">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00112">112</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae592ba2301f6064f2f50d70196517886"></a><!-- doxytag: member="RuleBasedBreakIterator::fNumCachedBreakPositions" ref="ae592ba2301f6064f2f50d70196517886" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#ae592ba2301f6064f2f50d70196517886">RuleBasedBreakIterator::fNumCachedBreakPositions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of elements in fCachedBreakPositions. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000069">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00134">134</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a65ae2b4eadd5389543d7b69d2c965c9f"></a><!-- doxytag: member="RuleBasedBreakIterator::fPositionInCache" ref="a65ae2b4eadd5389543d7b69d2c965c9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classRuleBasedBreakIterator.html#a65ae2b4eadd5389543d7b69d2c965c9f">RuleBasedBreakIterator::fPositionInCache</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>if fCachedBreakPositions is not null, this indicates which item in the cache the current iteration position refers to </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000070">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00141">141</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab167d8622058e5c0d417dd43ef83edda"></a><!-- doxytag: member="RuleBasedBreakIterator::fSCharIter" ref="ab167d8622058e5c0d417dd43ef83edda" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStringCharacterIterator.html">StringCharacterIterator</a>* <a class="el" href="classRuleBasedBreakIterator.html#ab167d8622058e5c0d417dd43ef83edda">RuleBasedBreakIterator::fSCharIter</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When the input text is provided by a <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a>, this will point to a characterIterator that wraps that data. </p>
<p>Needed only for the implementation of <a class="el" href="classBreakIterator.html#ab12b76622eaa6df7d0df48778f5de1aa" title="Return a CharacterIterator over the text being analyzed.">getText()</a>, a backwards compatibility issue. </p>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00086">86</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a419b7e787fe701da59edf938ec338348"></a><!-- doxytag: member="RuleBasedBreakIterator::fText" ref="a419b7e787fe701da59edf938ec338348" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUText.html">UText</a>* <a class="el" href="classRuleBasedBreakIterator.html#a419b7e787fe701da59edf938ec338348">RuleBasedBreakIterator::fText</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="structUText.html" title="UText struct.">UText</a> through which this <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> accesses the text. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000063">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00072">72</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f39d4df45fbf35c61ac58df2746f1e9"></a><!-- doxytag: member="RuleBasedBreakIterator::fUnhandledBreakEngine" ref="a6f39d4df45fbf35c61ac58df2746f1e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnhandledEngine* <a class="el" href="classRuleBasedBreakIterator.html#a6f39d4df45fbf35c61ac58df2746f1e9">RuleBasedBreakIterator::fUnhandledBreakEngine</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If present, the special LanguageBreakEngine used for handling characters that are in the dictionary set, but not handled by any LangugageBreakEngine. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000072">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p>Definition at line <a class="el" href="rbbi_8h_source.html#l00159">159</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rbbi_8h_source.html">rbbi.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Jul 26 12:57:02 2011 for ICU 4.8.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
