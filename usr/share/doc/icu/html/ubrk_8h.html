<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ICU 4.8.1: ubrk.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ubrk.h File Reference</h1>
<p>C API: <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="utypes_8h_source.html">unicode/utypes.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="uloc_8h_source.html">unicode/uloc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="utext_8h_source.html">unicode/utext.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="localpointer_8h_source.html">unicode/localpointer.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="parseerr_8h_source.html">unicode/parseerr.h</a>&quot;</code><br/>

<p><a href="ubrk_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a7c31c1e5091fb47ab85db522c7536252">UBRK_DONE</a>&nbsp;&nbsp;&nbsp;((int32_t) -1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value indicating all text boundaries have been returned.  <a href="#a7c31c1e5091fb47ab85db522c7536252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ab17dc88e0028fd85c622889eea22a6fa">U_BRK_SAFECLONE_BUFFERSIZE</a>&nbsp;&nbsp;&nbsp;512</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A recommended size (in bytes) for the memory buffer to be passed to ubrk_saveClone().  <a href="#ab17dc88e0028fd85c622889eea22a6fa"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A text-break iterator.  <a href="#adb85bb46d5f93c87098e11deab50bef4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> { <br/>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba446d025be7ca2f64dfac303b0a55c0b3">UBRK_CHARACTER</a> =  0, 
<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba17772e8ee70d3de4064c71417c574f36">UBRK_WORD</a> =  1, 
<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba73e81a0d478daeb2c6de8a63cac1070c">UBRK_LINE</a> =  2, 
<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588bab1b31cbd0fb0b298b87cb67da729ba62">UBRK_SENTENCE</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba3d79f0b0db32243e6b85b0b5036f9831">UBRK_TITLE</a> =  4, 
<b>UBRK_COUNT</b> =  5
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The possible types of text boundaries. </p>
 <a href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a> { <br/>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a8229f94661c6289a6497018ef341801a">UBRK_WORD_NONE</a> =  0, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a54839e74f8aa4ffd4ea7b9d86f3de050">UBRK_WORD_NONE_LIMIT</a> =  100, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a3ec03137beddd2ce1d611cc7798b6e74">UBRK_WORD_NUMBER</a> =  100, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a82e563b42b89e0a49c097d40a54c8621">UBRK_WORD_NUMBER_LIMIT</a> =  200, 
<br/>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a945eb6dd49881b36d4e2c9f592d97197">UBRK_WORD_LETTER</a> =  200, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a66ad49e358ce8a4fba6d6161ec678dd6">UBRK_WORD_LETTER_LIMIT</a> =  300, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a69f55c4740ce6f96ad9b61d859de201f">UBRK_WORD_KANA</a> =  300, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a7d507a35a3813629c11340a3f0f10fec">UBRK_WORD_KANA_LIMIT</a> =  400, 
<br/>
&nbsp;&nbsp;<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a295f3da24ba9978b5787c1494079c8de">UBRK_WORD_IDEO</a> =  400, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a8097221024f5c65d58951ad488d57474">UBRK_WORD_IDEO_LIMIT</a> =  500
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enum constants for the word break tags returned by getRuleStatus(). </p>
 <a href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a> { <a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccda6a91dd50489f1fbc5c8c32c29fcc3fee">UBRK_LINE_SOFT</a> =  0, 
<a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccdaef314dd1a053a6f2ab57c06f3a3d5f1f">UBRK_LINE_SOFT_LIMIT</a> =  100, 
<a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccdad02d1bfcd98382e53c9e83db37fba492">UBRK_LINE_HARD</a> =  100, 
<a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccdae767435243d44e5a22c1db90dd3a8f6e">UBRK_LINE_HARD_LIMIT</a> =  200
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enum constants for the line break tags returned by getRuleStatus(). </p>
 <a href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a> { <a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71addbcb13addb315fc0814a6fb1284c339">UBRK_SENTENCE_TERM</a> =  0, 
<a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71a650703353df53947eb3b996e3e5239f7">UBRK_SENTENCE_TERM_LIMIT</a> =  100, 
<a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71aca695be696e0e48676c109de60bcbbdf">UBRK_SENTENCE_SEP</a> =  100, 
<a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71af573420e1d53a811d6c5c4a07a4f5c8e">UBRK_SENTENCE_SEP_LIMIT</a> =  200
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enum constants for the sentence break tags returned by getRuleStatus(). </p>
 <a href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4e5fd80d818fb4ec23330d8935b2754d">ubrk_open</a> (<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> type, const char *locale, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *text, int32_t textLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new UBreakIterator for locating text boundaries for a specified locale.  <a href="#a4e5fd80d818fb4ec23330d8935b2754d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a11826cb21213916c2d91579b673d8949">ubrk_openRules</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *rules, int32_t rulesLength, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *text, int32_t textLength, <a class="el" href="structUParseError.html">UParseError</a> *parseErr, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new UBreakIterator for locating text boundaries using specified breaking rules.  <a href="#a11826cb21213916c2d91579b673d8949"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a6901f59d9c74bc8e16b9994cb1be7679">ubrk_safeClone</a> (const <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, void *stackBuffer, int32_t *pBufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread safe cloning operation.  <a href="#a6901f59d9c74bc8e16b9994cb1be7679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a5e398fb0fe194683a000b3989c041fda">ubrk_close</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a UBreakIterator.  <a href="#a5e398fb0fe194683a000b3989c041fda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a8c8a6679a8ce36ba5d035b99748c8339">ubrk_setText</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *text, int32_t textLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an existing iterator to point to a new piece of text.  <a href="#a8c8a6679a8ce36ba5d035b99748c8339"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ac91bfeb92a3e489e3188f02597f4c9c7">ubrk_setUText</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, <a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an existing iterator to point to a new piece of text.  <a href="#ac91bfeb92a3e489e3188f02597f4c9c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4f8b67527c5c9d9205a3446506ffeefc">ubrk_current</a> (const <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the most recently-returned text boundary.  <a href="#a4f8b67527c5c9d9205a3446506ffeefc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a17158fccedcf72481eaca61fffab4ce6">ubrk_next</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary following the current text boundary.  <a href="#a17158fccedcf72481eaca61fffab4ce6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a318c950f25ee89a66c989feced3a41f0">ubrk_previous</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary preceding the current text boundary.  <a href="#a318c950f25ee89a66c989feced3a41f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a2ae638e98af0830b66ff058b48e7dbcd">ubrk_first</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the index of the first character in the text being scanned.  <a href="#a2ae638e98af0830b66ff058b48e7dbcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a24ffb5cee86ffe1ee8aa0d53093b352f">ubrk_last</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the index immediately <em>beyond</em> the last character in the text being scanned.  <a href="#a24ffb5cee86ffe1ee8aa0d53093b352f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#accaaccc55135961f45541bcbab580f9d">ubrk_preceding</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary preceding the specified offset.  <a href="#accaaccc55135961f45541bcbab580f9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4724e6d07ea2f27b99a1bba60e4ef76c">ubrk_following</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the text boundary following the specified offset.  <a href="#a4724e6d07ea2f27b99a1bba60e4ef76c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a12fc845896682221749f03e7dc21e3e0">ubrk_getAvailable</a> (int32_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a locale for which text breaking information is available.  <a href="#a12fc845896682221749f03e7dc21e3e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a8b587f3b0df1b680f4ca3f1d1f151f7e">ubrk_countAvailable</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine how many locales have text breaking information available.  <a href="#a8b587f3b0df1b680f4ca3f1d1f151f7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a701db54fd2c91c07490cb02ebdd54fa6">ubrk_isBoundary</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the specfied position is a boundary position.  <a href="#a701db54fd2c91c07490cb02ebdd54fa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4314a5dd63efde9b372ded64b6f0c732">ubrk_getRuleStatus</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status from the break rule that determined the most recently returned break position.  <a href="#a4314a5dd63efde9b372ded64b6f0c732"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#acf355cf304090ca6efb10c4318bde45e">ubrk_getRuleStatusVec</a> (<a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the statuses from the break rules that determined the most recently returned break position.  <a href="#acf355cf304090ca6efb10c4318bde45e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ad95a44383cba60e20188025ab18c09fe">ubrk_getLocaleByType</a> (const <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, <a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the locale of the break iterator.  <a href="#ad95a44383cba60e20188025ab18c09fe"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>C API: <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a>. </p>
<h2><a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> C API </h2>
<p>The <a class="el" href="classBreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries...">BreakIterator</a> C API defines methods for finding the location of boundaries in text. Pointer to a UBreakIterator maintain a current position and scan over text returning the index of characters where boundaries occur. </p>
<p>Line boundary analysis determines where a text string can be broken when line-wrapping. The mechanism correctly handles punctuation and hyphenated words. </p>
<p>Sentence boundary analysis allows selection with correct interpretation of periods within numbers and abbreviations, and trailing punctuation marks such as quotation marks and parentheses. </p>
<p>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides. </p>
<p>Character boundary analysis identifies the boundaries of "Extended Grapheme Clusters", which are groupings of codepoints that should be treated as character-like units for many text operations. Please see Unicode Standard Annex #29, Unicode Text Segmentation, <a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a> for additional information on grapheme clusters and guidelines on their use. </p>
<p>Title boundary analysis locates all positions, typically starts of words, that should be set to Title Case when title casing the text. </p>
<p>The text boundary positions are found according to the rules described in Unicode Standard Annex #29, Text Boundaries, and Unicode Standard Annex #14, Line Breaking Properties. These are available at <a href="http://www.unicode.org/reports/tr14/">http://www.unicode.org/reports/tr14/</a> and <a href="http://www.unicode.org/reports/tr29/.">http://www.unicode.org/reports/tr29/.</a> </p>
<p>In addition to the plain C API defined in this header file, an object oriented C++ API with equivalent functionality is defined in the file <a class="el" href="brkiter_8h.html" title="C++ API: Break Iterator.">brkiter.h</a>. </p>
<p>Code snippets illustrating the use of the Break Iterator APIs are available in the ICU User Guide, <a href="http://icu-project.org/userguide/boundaryAnalysis.html">http://icu-project.org/userguide/boundaryAnalysis.html</a> and in the sample program icu/source/samples/break/break.cpp </p>

<p>Definition in file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab17dc88e0028fd85c622889eea22a6fa"></a><!-- doxytag: member="ubrk.h::U_BRK_SAFECLONE_BUFFERSIZE" ref="ab17dc88e0028fd85c622889eea22a6fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_BRK_SAFECLONE_BUFFERSIZE&nbsp;&nbsp;&nbsp;512</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A recommended size (in bytes) for the memory buffer to be passed to ubrk_saveClone(). </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000500">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ubrk_8h_source.html#l00270">270</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c31c1e5091fb47ab85db522c7536252"></a><!-- doxytag: member="ubrk.h::UBRK_DONE" ref="a7c31c1e5091fb47ab85db522c7536252" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBRK_DONE&nbsp;&nbsp;&nbsp;((int32_t) -1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value indicating all text boundaries have been returned. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000493">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ubrk_8h_source.html#l00114">114</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="adb85bb46d5f93c87098e11deab50bef4"></a><!-- doxytag: member="ubrk.h::UBreakIterator" ref="adb85bb46d5f93c87098e11deab50bef4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A text-break iterator. </p>
<p>For usage in C programs. Opaque type representing an ICU Break iterator object. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000491">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Definition at line <a class="el" href="ubrk_8h_source.html#l00026">26</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a026dec40289da8261d787daf3baa588b"></a><!-- doxytag: member="ubrk.h::UBreakIteratorType" ref="a026dec40289da8261d787daf3baa588b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The possible types of text boundaries. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000492">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a026dec40289da8261d787daf3baa588ba446d025be7ca2f64dfac303b0a55c0b3"></a><!-- doxytag: member="UBRK_CHARACTER" ref="a026dec40289da8261d787daf3baa588ba446d025be7ca2f64dfac303b0a55c0b3" args="" -->UBRK_CHARACTER</em>&nbsp;</td><td>
<p>Character breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000517">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a026dec40289da8261d787daf3baa588ba17772e8ee70d3de4064c71417c574f36"></a><!-- doxytag: member="UBRK_WORD" ref="a026dec40289da8261d787daf3baa588ba17772e8ee70d3de4064c71417c574f36" args="" -->UBRK_WORD</em>&nbsp;</td><td>
<p>Word breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000518">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a026dec40289da8261d787daf3baa588ba73e81a0d478daeb2c6de8a63cac1070c"></a><!-- doxytag: member="UBRK_LINE" ref="a026dec40289da8261d787daf3baa588ba73e81a0d478daeb2c6de8a63cac1070c" args="" -->UBRK_LINE</em>&nbsp;</td><td>
<p>Line breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000519">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a026dec40289da8261d787daf3baa588bab1b31cbd0fb0b298b87cb67da729ba62"></a><!-- doxytag: member="UBRK_SENTENCE" ref="a026dec40289da8261d787daf3baa588bab1b31cbd0fb0b298b87cb67da729ba62" args="" -->UBRK_SENTENCE</em>&nbsp;</td><td>
<p>Sentence breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000520">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a026dec40289da8261d787daf3baa588ba3d79f0b0db32243e6b85b0b5036f9831"></a><!-- doxytag: member="UBRK_TITLE" ref="a026dec40289da8261d787daf3baa588ba3d79f0b0db32243e6b85b0b5036f9831" args="" -->UBRK_TITLE</em>&nbsp;</td><td>
<p>Title Case breaks The iterator created using this type locates title boundaries as described for Unicode 3.2 only. </p>
<p>For Unicode 4.0 and above title boundary iteration, please use Word Boundary iterator.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>ICU 2.8 Use the word break iterator for titlecasing for Unicode 4 and later. </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h_source.html#l00087">87</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8de005c411b5e5306850f4246d1d7ccd"></a><!-- doxytag: member="ubrk.h::ULineBreakTag" ref="a8de005c411b5e5306850f4246d1d7ccd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enum constants for the line break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000495">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8de005c411b5e5306850f4246d1d7ccda6a91dd50489f1fbc5c8c32c29fcc3fee"></a><!-- doxytag: member="UBRK_LINE_SOFT" ref="a8de005c411b5e5306850f4246d1d7ccda6a91dd50489f1fbc5c8c32c29fcc3fee" args="" -->UBRK_LINE_SOFT</em>&nbsp;</td><td>
<p>Tag value for soft line breaks, positions at which a line break is acceptable but not required. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8de005c411b5e5306850f4246d1d7ccdaef314dd1a053a6f2ab57c06f3a3d5f1f"></a><!-- doxytag: member="UBRK_LINE_SOFT_LIMIT" ref="a8de005c411b5e5306850f4246d1d7ccdaef314dd1a053a6f2ab57c06f3a3d5f1f" args="" -->UBRK_LINE_SOFT_LIMIT</em>&nbsp;</td><td>
<p>Upper bound for soft line breaks. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8de005c411b5e5306850f4246d1d7ccdad02d1bfcd98382e53c9e83db37fba492"></a><!-- doxytag: member="UBRK_LINE_HARD" ref="a8de005c411b5e5306850f4246d1d7ccdad02d1bfcd98382e53c9e83db37fba492" args="" -->UBRK_LINE_HARD</em>&nbsp;</td><td>
<p>Tag value for a hard, or mandatory line break. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8de005c411b5e5306850f4246d1d7ccdae767435243d44e5a22c1db90dd3a8f6e"></a><!-- doxytag: member="UBRK_LINE_HARD_LIMIT" ref="a8de005c411b5e5306850f4246d1d7ccdae767435243d44e5a22c1db90dd3a8f6e" args="" -->UBRK_LINE_HARD_LIMIT</em>&nbsp;</td><td>
<p>Upper bound for hard line breaks. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h_source.html#l00158">158</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad03d8e27f121bcf11eaed0a288786a71"></a><!-- doxytag: member="ubrk.h::USentenceBreakTag" ref="ad03d8e27f121bcf11eaed0a288786a71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enum constants for the sentence break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of sentence, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000496">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad03d8e27f121bcf11eaed0a288786a71addbcb13addb315fc0814a6fb1284c339"></a><!-- doxytag: member="UBRK_SENTENCE_TERM" ref="ad03d8e27f121bcf11eaed0a288786a71addbcb13addb315fc0814a6fb1284c339" args="" -->UBRK_SENTENCE_TERM</em>&nbsp;</td><td>
<p>Tag value for for sentences ending with a sentence terminator ('. </p>
<p>', '?', '!', etc.) character, possibly followed by a hard separator (CR, LF, PS, etc.) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad03d8e27f121bcf11eaed0a288786a71a650703353df53947eb3b996e3e5239f7"></a><!-- doxytag: member="UBRK_SENTENCE_TERM_LIMIT" ref="ad03d8e27f121bcf11eaed0a288786a71a650703353df53947eb3b996e3e5239f7" args="" -->UBRK_SENTENCE_TERM_LIMIT</em>&nbsp;</td><td>
<p>Upper bound for tags for sentences ended by sentence terminators. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad03d8e27f121bcf11eaed0a288786a71aca695be696e0e48676c109de60bcbbdf"></a><!-- doxytag: member="UBRK_SENTENCE_SEP" ref="ad03d8e27f121bcf11eaed0a288786a71aca695be696e0e48676c109de60bcbbdf" args="" -->UBRK_SENTENCE_SEP</em>&nbsp;</td><td>
<p>Tag value for for sentences that do not contain an ending sentence terminator ('. </p>
<p>', '?', '!', etc.) character, but are ended only by a hard separator (CR, LF, PS, etc.) or end of input. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad03d8e27f121bcf11eaed0a288786a71af573420e1d53a811d6c5c4a07a4f5c8e"></a><!-- doxytag: member="UBRK_SENTENCE_SEP_LIMIT" ref="ad03d8e27f121bcf11eaed0a288786a71af573420e1d53a811d6c5c4a07a4f5c8e" args="" -->UBRK_SENTENCE_SEP_LIMIT</em>&nbsp;</td><td>
<p>Upper bound for tags for sentences ended by a separator. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h_source.html#l00180">180</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9"></a><!-- doxytag: member="ubrk.h::UWordBreak" ref="af9836cc79482f82ac12eefb1f70b14b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enum constants for the word break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000494">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a8229f94661c6289a6497018ef341801a"></a><!-- doxytag: member="UBRK_WORD_NONE" ref="af9836cc79482f82ac12eefb1f70b14b9a8229f94661c6289a6497018ef341801a" args="" -->UBRK_WORD_NONE</em>&nbsp;</td><td>
<p>Tag value for "words" that do not fit into any of other categories. </p>
<p>Includes spaces and most punctuation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a54839e74f8aa4ffd4ea7b9d86f3de050"></a><!-- doxytag: member="UBRK_WORD_NONE_LIMIT" ref="af9836cc79482f82ac12eefb1f70b14b9a54839e74f8aa4ffd4ea7b9d86f3de050" args="" -->UBRK_WORD_NONE_LIMIT</em>&nbsp;</td><td>
<p>Upper bound for tags for uncategorized words. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a3ec03137beddd2ce1d611cc7798b6e74"></a><!-- doxytag: member="UBRK_WORD_NUMBER" ref="af9836cc79482f82ac12eefb1f70b14b9a3ec03137beddd2ce1d611cc7798b6e74" args="" -->UBRK_WORD_NUMBER</em>&nbsp;</td><td>
<p>Tag value for words that appear to be numbers, lower limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a82e563b42b89e0a49c097d40a54c8621"></a><!-- doxytag: member="UBRK_WORD_NUMBER_LIMIT" ref="af9836cc79482f82ac12eefb1f70b14b9a82e563b42b89e0a49c097d40a54c8621" args="" -->UBRK_WORD_NUMBER_LIMIT</em>&nbsp;</td><td>
<p>Tag value for words that appear to be numbers, upper limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a945eb6dd49881b36d4e2c9f592d97197"></a><!-- doxytag: member="UBRK_WORD_LETTER" ref="af9836cc79482f82ac12eefb1f70b14b9a945eb6dd49881b36d4e2c9f592d97197" args="" -->UBRK_WORD_LETTER</em>&nbsp;</td><td>
<p>Tag value for words that contain letters, excluding hiragana, katakana or ideographic characters, lower limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a66ad49e358ce8a4fba6d6161ec678dd6"></a><!-- doxytag: member="UBRK_WORD_LETTER_LIMIT" ref="af9836cc79482f82ac12eefb1f70b14b9a66ad49e358ce8a4fba6d6161ec678dd6" args="" -->UBRK_WORD_LETTER_LIMIT</em>&nbsp;</td><td>
<p>Tag value for words containing letters, upper limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a69f55c4740ce6f96ad9b61d859de201f"></a><!-- doxytag: member="UBRK_WORD_KANA" ref="af9836cc79482f82ac12eefb1f70b14b9a69f55c4740ce6f96ad9b61d859de201f" args="" -->UBRK_WORD_KANA</em>&nbsp;</td><td>
<p>Tag value for words containing kana characters, lower limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a7d507a35a3813629c11340a3f0f10fec"></a><!-- doxytag: member="UBRK_WORD_KANA_LIMIT" ref="af9836cc79482f82ac12eefb1f70b14b9a7d507a35a3813629c11340a3f0f10fec" args="" -->UBRK_WORD_KANA_LIMIT</em>&nbsp;</td><td>
<p>Tag value for words containing kana characters, upper limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a295f3da24ba9978b5787c1494079c8de"></a><!-- doxytag: member="UBRK_WORD_IDEO" ref="af9836cc79482f82ac12eefb1f70b14b9a295f3da24ba9978b5787c1494079c8de" args="" -->UBRK_WORD_IDEO</em>&nbsp;</td><td>
<p>Tag value for words containing ideographic characters, lower limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af9836cc79482f82ac12eefb1f70b14b9a8097221024f5c65d58951ad488d57474"></a><!-- doxytag: member="UBRK_WORD_IDEO_LIMIT" ref="af9836cc79482f82ac12eefb1f70b14b9a8097221024f5c65d58951ad488d57474" args="" -->UBRK_WORD_IDEO_LIMIT</em>&nbsp;</td><td>
<p>Tag value for words containing ideographic characters, upper limit. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ubrk_8h_source.html#l00125">125</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5e398fb0fe194683a000b3989c041fda"></a><!-- doxytag: member="ubrk.h::ubrk_close" ref="a5e398fb0fe194683a000b3989c041fda" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a UBreakIterator. </p>
<p>Once closed, a UBreakIterator may no longer be used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000501">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8b587f3b0df1b680f4ca3f1d1f151f7e"></a><!-- doxytag: member="ubrk.h::ubrk_countAvailable" ref="a8b587f3b0df1b680f4ca3f1d1f151f7e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_countAvailable </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine how many locales have text breaking information available. </p>
<p>This function is most useful as determining the loop ending condition for calls to <a class="el" href="ubrk_8h.html#a12fc845896682221749f03e7dc21e3e0">ubrk_getAvailable</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of locales for which text breaking information is available. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a12fc845896682221749f03e7dc21e3e0" title="Get a locale for which text breaking information is available.">ubrk_getAvailable</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000512">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4f8b67527c5c9d9205a3446506ffeefc"></a><!-- doxytag: member="ubrk.h::ubrk_current" ref="a4f8b67527c5c9d9205a3446506ffeefc" args="(const UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_current </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the most recently-returned text boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character index most recently returned by <a class="el" href="ubrk_8h.html#a17158fccedcf72481eaca61fffab4ce6">ubrk_next</a>, <a class="el" href="ubrk_8h.html#a318c950f25ee89a66c989feced3a41f0">ubrk_previous</a>, <a class="el" href="ubrk_8h.html#a2ae638e98af0830b66ff058b48e7dbcd">ubrk_first</a>, or <a class="el" href="ubrk_8h.html#a24ffb5cee86ffe1ee8aa0d53093b352f">ubrk_last</a>. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000504">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2ae638e98af0830b66ff058b48e7dbcd"></a><!-- doxytag: member="ubrk.h::ubrk_first" ref="a2ae638e98af0830b66ff058b48e7dbcd" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the index of the first character in the text being scanned. </p>
<p>This is not always the same as index 0 of the text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character index of the first character in the text being scanned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a24ffb5cee86ffe1ee8aa0d53093b352f" title="Determine the index immediately beyond the last character in the text being scanned...">ubrk_last</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000507">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4724e6d07ea2f27b99a1bba60e4ef76c"></a><!-- doxytag: member="ubrk.h::ubrk_following" ref="a4724e6d07ea2f27b99a1bba60e4ef76c" args="(UBreakIterator *bi, int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_following </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the text boundary following the specified offset. </p>
<p>The value returned is always greater than offset, or UBRK_DONE. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset to begin scanning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The text boundary following offset, or UBRK_DONE. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#accaaccc55135961f45541bcbab580f9d" title="Determine the text boundary preceding the specified offset.">ubrk_preceding</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000510">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a12fc845896682221749f03e7dc21e3e0"></a><!-- doxytag: member="ubrk.h::ubrk_getAvailable" ref="a12fc845896682221749f03e7dc21e3e0" args="(int32_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ubrk_getAvailable </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a locale for which text breaking information is available. </p>
<p>A UBreakIterator in a locale returned by this function will perform the correct text breaking for the locale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the desired locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A locale for which number text breaking information is available, or 0 if none. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a8b587f3b0df1b680f4ca3f1d1f151f7e" title="Determine how many locales have text breaking information available.">ubrk_countAvailable</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000511">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad95a44383cba60e20188025ab18c09fe"></a><!-- doxytag: member="ubrk.h::ubrk_getLocaleByType" ref="ad95a44383cba60e20188025ab18c09fe" args="(const UBreakIterator *bi, ULocDataLocaleType type, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ubrk_getLocaleByType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the locale of the break iterator. </p>
<p>You can choose between the valid and the actual locale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>break iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>locale type (valid or actual) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>locale string </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000516">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a4314a5dd63efde9b372ded64b6f0c732"></a><!-- doxytag: member="ubrk.h::ubrk_getRuleStatus" ref="a4314a5dd63efde9b372ded64b6f0c732" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_getRuleStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status from the break rule that determined the most recently returned break position. </p>
<p>The values appear in the rule source within brackets, {123}, for example. For rules that do not specify a status, a default value of 0 is returned. </p>
<p>For word break iterators, the possible values are defined in enum UWordBreak. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000514">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="acf355cf304090ca6efb10c4318bde45e"></a><!-- doxytag: member="ubrk.h::ubrk_getRuleStatusVec" ref="acf355cf304090ca6efb10c4318bde45e" args="(UBreakIterator *bi, int32_t *fillInVec, int32_t capacity, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_getRuleStatusVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the statuses from the break rules that determined the most recently returned break position. </p>
<p>The values appear in the rule source within brackets, {123}, for example. The default status value for rules that do not explicitly provide one is zero. </p>
<p>For word break iterators, the possible values are defined in enum UWordBreak. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fillInVec</em>&nbsp;</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>capacity</em>&nbsp;</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attemtping to store any values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>receives error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of rule status values from rules that determined the most recent boundary returned by the break iterator. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000515">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a701db54fd2c91c07490cb02ebdd54fa6"></a><!-- doxytag: member="ubrk.h::ubrk_isBoundary" ref="a701db54fd2c91c07490cb02ebdd54fa6" args="(UBreakIterator *bi, int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> ubrk_isBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the specfied position is a boundary position. </p>
<p>As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000513">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a24ffb5cee86ffe1ee8aa0d53093b352f"></a><!-- doxytag: member="ubrk.h::ubrk_last" ref="a24ffb5cee86ffe1ee8aa0d53093b352f" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the index immediately <em>beyond</em> the last character in the text being scanned. </p>
<p>This is not the same as the last character. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character offset immediately <em>beyond</em> the last character in the text being scanned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a2ae638e98af0830b66ff058b48e7dbcd" title="Determine the index of the first character in the text being scanned.">ubrk_first</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000508">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a17158fccedcf72481eaca61fffab4ce6"></a><!-- doxytag: member="ubrk.h::ubrk_next" ref="a17158fccedcf72481eaca61fffab4ce6" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the text boundary following the current text boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character index of the next text boundary, or UBRK_DONE if all text boundaries have been returned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a318c950f25ee89a66c989feced3a41f0" title="Determine the text boundary preceding the current text boundary.">ubrk_previous</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000505">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4e5fd80d818fb4ec23330d8935b2754d"></a><!-- doxytag: member="ubrk.h::ubrk_open" ref="a4e5fd80d818fb4ec23330d8935b2754d" args="(UBreakIteratorType type, const char *locale, const UChar *text, int32_t textLength, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>* ubrk_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a new UBreakIterator for locating text boundaries for a specified locale. </p>
<p>A UBreakIterator may be used for detecting character, line, word, and sentence breaks in text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of UBreakIterator to open: one of UBRK_CHARACTER, UBRK_WORD, UBRK_LINE, UBRK_SENTENCE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locale</em>&nbsp;</td><td>The locale specifying the text-breaking conventions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be iterated over. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textLength</em>&nbsp;</td><td>The number of characters in text, or -1 if null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A UBreakIterator for the specified locale. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a11826cb21213916c2d91579b673d8949" title="Open a new UBreakIterator for locating text boundaries using specified breaking rules...">ubrk_openRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000497">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a11826cb21213916c2d91579b673d8949"></a><!-- doxytag: member="ubrk.h::ubrk_openRules" ref="a11826cb21213916c2d91579b673d8949" args="(const UChar *rules, int32_t rulesLength, const UChar *text, int32_t textLength, UParseError *parseErr, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>* ubrk_openRules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>rulesLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> *&nbsp;</td>
          <td class="paramname"> <em>parseErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a new UBreakIterator for locating text boundaries using specified breaking rules. </p>
<p>The rule syntax is ... (TBD) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rules</em>&nbsp;</td><td>A set of rules specifying the text breaking conventions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rulesLength</em>&nbsp;</td><td>The number of characters in rules, or -1 if null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be iterated over. May be null, in which case <a class="el" href="ubrk_8h.html#a8c8a6679a8ce36ba5d035b99748c8339" title="Sets an existing iterator to point to a new piece of text.">ubrk_setText()</a> is used to specify the text to be iterated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textLength</em>&nbsp;</td><td>The number of characters in text, or -1 if null-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parseErr</em>&nbsp;</td><td>Receives position and context information for any syntax errors detected while parsing the rules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A UBreakIterator for the specified rules. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a4e5fd80d818fb4ec23330d8935b2754d" title="Open a new UBreakIterator for locating text boundaries for a specified locale.">ubrk_open</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000498">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="accaaccc55135961f45541bcbab580f9d"></a><!-- doxytag: member="ubrk.h::ubrk_preceding" ref="accaaccc55135961f45541bcbab580f9d" args="(UBreakIterator *bi, int32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_preceding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the text boundary preceding the specified offset. </p>
<p>The value returned is always smaller than offset, or UBRK_DONE. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset to begin scanning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The text boundary preceding offset, or UBRK_DONE. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a4724e6d07ea2f27b99a1bba60e4ef76c" title="Determine the text boundary following the specified offset.">ubrk_following</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000509">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a318c950f25ee89a66c989feced3a41f0"></a><!-- doxytag: member="ubrk.h::ubrk_previous" ref="a318c950f25ee89a66c989feced3a41f0" args="(UBreakIterator *bi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_previous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the text boundary preceding the current text boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character index of the preceding text boundary, or UBRK_DONE if all text boundaries have been returned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ubrk_8h.html#a17158fccedcf72481eaca61fffab4ce6" title="Determine the text boundary following the current text boundary.">ubrk_next</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000506">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6901f59d9c74bc8e16b9994cb1be7679"></a><!-- doxytag: member="ubrk.h::ubrk_safeClone" ref="a6901f59d9c74bc8e16b9994cb1be7679" args="(const UBreakIterator *bi, void *stackBuffer, int32_t *pBufferSize, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>* ubrk_safeClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>pBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread safe cloning operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>iterator to be cloned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stackBuffer</em>&nbsp;</td><td>user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. Clients can use the U_BRK_SAFECLONE_BUFFERSIZE. This will probably be enough to avoid memory allocations. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBufferSize</em>&nbsp;</td><td>pointer to size of allocated space. If *pBufferSize == 0, a sufficient size for use in cloning will be returned ('pre-flighting') If *pBufferSize is not enough for a stack-based safe clone, new memory will be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_ERROR, is used if any allocations were necessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the new clone </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000499">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8c8a6679a8ce36ba5d035b99748c8339"></a><!-- doxytag: member="ubrk.h::ubrk_setText" ref="a8c8a6679a8ce36ba5d035b99748c8339" args="(UBreakIterator *bi, const UChar *text, int32_t textLength, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_setText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an existing iterator to point to a new piece of text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The iterator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>textLength</em>&nbsp;</td><td>The length of the text </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000502">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac91bfeb92a3e489e3188f02597f4c9c7"></a><!-- doxytag: member="ubrk.h::ubrk_setUText" ref="ac91bfeb92a3e489e3188f02597f4c9c7" args="(UBreakIterator *bi, UText *text, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_setUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustring_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an existing iterator to point to a new piece of text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bi</em>&nbsp;</td><td>The iterator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The text to be set. This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a>. This means that the caller is free to immediately close or otherwise reuse the <a class="el" href="structUText.html" title="UText struct.">UText</a> that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000503">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Jul 26 12:56:49 2011 for ICU 4.8.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
