<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ICU 4.8.1: RegexMatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RegexMatcher Class Reference</h1><!-- doxytag: class="RegexMatcher" --><!-- doxytag: inherits="UObject" -->
<p>class <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> bundles together a regular expression pattern and input text to which the expression can be applied.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="regex_8h_source.html">regex.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RegexMatcher:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRegexMatcher.gif" usemap="#RegexMatcher_map" alt=""/>
  <map id="RegexMatcher_map" name="RegexMatcher_map">
<area href="classUObject.html" alt="UObject" shape="rect" coords="0,56,94,80"/>
<area href="classUMemory.html" alt="UMemory" shape="rect" coords="0,0,94,24"/>
</map>
 </div>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a6d8082b5a33770e99ecbd73313bf7a50">RegexMatcher</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;regexp, uint32_t flags, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression.  <a href="#a6d8082b5a33770e99ecbd73313bf7a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a75ef00fe0f6f5004f055c67d49a905cb">RegexMatcher</a> (<a class="el" href="structUText.html">UText</a> *regexp, uint32_t flags, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression.  <a href="#a75ef00fe0f6f5004f055c67d49a905cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a47a4616e88fe34d85b440aa0fe6922b9">RegexMatcher</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;regexp, const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;input, uint32_t flags, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression.  <a href="#a47a4616e88fe34d85b440aa0fe6922b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#af7588a2667611b7086b2fed6f7758ff2">RegexMatcher</a> (<a class="el" href="structUText.html">UText</a> *regexp, <a class="el" href="structUText.html">UText</a> *input, uint32_t flags, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression.  <a href="#af7588a2667611b7086b2fed6f7758ff2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a0e08da6f535d3379399265768bd5adb4">~RegexMatcher</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a0e08da6f535d3379399265768bd5adb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a3c83ab49b979b5c610819fee1fe8463f">matches</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to match the entire input region against the pattern.  <a href="#a3c83ab49b979b5c610819fee1fe8463f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a0073eae367c3a72bc1dbe40b04becdcb">matches</a> (int64_t startIndex, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the matcher, then attempts to match the input beginning at the specified startIndex, and extending to the end of the input.  <a href="#a0073eae367c3a72bc1dbe40b04becdcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ab04a667874c99f69ca9816240d934908">lookingAt</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to match the input string, starting from the beginning of the region, against the pattern.  <a href="#ab04a667874c99f69ca9816240d934908"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a75c7ca9b7f32341de5b576c7a08214f4">lookingAt</a> (int64_t startIndex, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to match the input string, starting from the specified index, against the pattern.  <a href="#a75c7ca9b7f32341de5b576c7a08214f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02">find</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the next pattern match in the input string.  <a href="#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#aa52b3ecfbb5cd58e9fcce3588d296f82">find</a> (int64_t start, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> and then attempts to find the next substring of the input string that matches the pattern, starting at the specified index.  <a href="#aa52b3ecfbb5cd58e9fcce3588d296f82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a8d98f84b7446c78408fc36366ccfdafb">group</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a string containing the text matched by the previous match.  <a href="#a8d98f84b7446c78408fc36366ccfdafb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a01c6fc5b7b8f94e977454b61bd3e5d86">group</a> (int32_t groupNum, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a string containing the text captured by the given group during the previous match operation.  <a href="#a01c6fc5b7b8f94e977454b61bd3e5d86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ae08fe8369c2986b16c772055497d184c">groupCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of capturing groups in this matcher's pattern.  <a href="#ae08fe8369c2986b16c772055497d184c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#abdb105391cfc2997354b0b0b7c384326">group</a> (<a class="el" href="structUText.html">UText</a> *dest, int64_t &amp;group_len, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a shallow clone of the entire live input string with the <a class="el" href="structUText.html" title="UText struct.">UText</a> current native index set to the beginning of the requested group.  <a href="#abdb105391cfc2997354b0b0b7c384326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a92b218c8cb8c5692e657530b20173eea">group</a> (int32_t groupNum, <a class="el" href="structUText.html">UText</a> *dest, int64_t &amp;group_len, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a shallow clone of the entire live input string with the <a class="el" href="structUText.html" title="UText struct.">UText</a> current native index set to the beginning of the requested group.  <a href="#a92b218c8cb8c5692e657530b20173eea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a1ba2de816176ae692de9fe3c7f335892">group</a> (int32_t groupNum, <a class="el" href="structUText.html">UText</a> *dest, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a string containing the text captured by the given group during the previous match operation.  <a href="#a1ba2de816176ae692de9fe3c7f335892"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ace59b3327cb3d476016d57b0bd76611c">start</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the start of the text matched during the previous match operation.  <a href="#ace59b3327cb3d476016d57b0bd76611c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a477a2c4729c9f78eff96e53f48e9c215">start64</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the start of the text matched during the previous match operation.  <a href="#a477a2c4729c9f78eff96e53f48e9c215"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ab526773d931447d8c990896e02375216">start</a> (int32_t group, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the start of the text matched by the specified capture group during the previous match operation.  <a href="#ab526773d931447d8c990896e02375216"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#abf1aec7feda15ffeffc70582e98f9311">start64</a> (int32_t group, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the start of the text matched by the specified capture group during the previous match operation.  <a href="#abf1aec7feda15ffeffc70582e98f9311"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a80cd2dcc802b61b046d83a6b48935dc4">end</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the first character following the text matched during the previous match operation.  <a href="#a80cd2dcc802b61b046d83a6b48935dc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a7e06b5b80ae872f11b3d3c237bd3d08d">end64</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the first character following the text matched during the previous match operation.  <a href="#a7e06b5b80ae872f11b3d3c237bd3d08d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a4a5240f42531547c10ae55537049f149">end</a> (int32_t group, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the character following the text matched by the specified capture group during the previous match operation.  <a href="#a4a5240f42531547c10ae55537049f149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a49d12181ae2aa940b039ba6f0634cbc2">end64</a> (int32_t group, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index in the input string of the character following the text matched by the specified capture group during the previous match operation.  <a href="#a49d12181ae2aa940b039ba6f0634cbc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a0564fa9029cf90afd6008e1c2863ff47">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets this matcher.  <a href="#a0564fa9029cf90afd6008e1c2863ff47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#acd2a4ba2d7fd366a8010159aaf9e4c86">reset</a> (int64_t index, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets this matcher, and set the current input position.  <a href="#acd2a4ba2d7fd366a8010159aaf9e4c86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#aafc5e4f9cb857068d0d6be4ef67ca8d0">reset</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;input)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets this matcher with a new input string.  <a href="#aafc5e4f9cb857068d0d6be4ef67ca8d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a1371b482a8e27f4a5398a9b6daf093b3">reset</a> (<a class="el" href="structUText.html">UText</a> *input)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets this matcher with a new input string.  <a href="#a1371b482a8e27f4a5398a9b6daf093b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a9b42112355418492da8302c3f3e2c61f">refreshInputText</a> (<a class="el" href="structUText.html">UText</a> *input, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the subject text string upon which the regular expression is looking for matches without changing any other aspect of the matching state.  <a href="#a9b42112355418492da8302c3f3e2c61f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#acfed242304a8cf781966fb812d312574">input</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the input string being matched.  <a href="#acfed242304a8cf781966fb812d312574"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a28bb7415a21aa4b9ec436e171f51fbdc">inputText</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the input string being matched.  <a href="#a28bb7415a21aa4b9ec436e171f51fbdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ad1d73b5633f5e89cbadbddee8f2397b0">getInput</a> (<a class="el" href="structUText.html">UText</a> *dest, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the input string being matched, either by copying it into the provided <a class="el" href="structUText.html" title="UText struct.">UText</a> parameter or by returning a shallow clone of the live input.  <a href="#ad1d73b5633f5e89cbadbddee8f2397b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a92526d42ab81529a26f016516e0d734b">region</a> (int64_t start, int64_t limit, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the limits of this matcher's region.  <a href="#a92526d42ab81529a26f016516e0d734b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a981a81b82753c236dfd8360af289bf29">region</a> (int64_t regionStart, int64_t regionLimit, int64_t startIndex, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identical to region(start, limit, status) but also allows a start position without resetting the region state.  <a href="#a981a81b82753c236dfd8360af289bf29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ae37cccdee76c94b20d0b6bc289ac3c39">regionStart</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the start index of this matcher's region.  <a href="#ae37cccdee76c94b20d0b6bc289ac3c39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a4004f5ab6c7d5341784abe40e4c318f9">regionStart64</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the start index of this matcher's region.  <a href="#a4004f5ab6c7d5341784abe40e4c318f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a5c91aff80b7a8bf549263341b818f8cc">regionEnd</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the end (limit) index (exclusive) of this matcher's region.  <a href="#a5c91aff80b7a8bf549263341b818f8cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a1fda6ddcd54c5f2c0769eddd95ec3d90">regionEnd64</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the end (limit) index (exclusive) of this matcher's region.  <a href="#a1fda6ddcd54c5f2c0769eddd95ec3d90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a1213ec0995f84d56540260e7bbe30490">hasTransparentBounds</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the transparency of region bounds for this matcher.  <a href="#a1213ec0995f84d56540260e7bbe30490"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#acf0c77059fa4880ad467b064d886f138">useTransparentBounds</a> (<a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the transparency of region bounds for this matcher.  <a href="#acf0c77059fa4880ad467b064d886f138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a21e4914b4d1c9612614ebd7b39d34772">hasAnchoringBounds</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this matcher is using anchoring bounds.  <a href="#a21e4914b4d1c9612614ebd7b39d34772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a3bc3a77ca9f4457fe9d350f9aaa71f8d">useAnchoringBounds</a> (<a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether this matcher is using Anchoring Bounds for its region.  <a href="#a3bc3a77ca9f4457fe9d350f9aaa71f8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a843196953b0461c5a7a1387e29fc24ae">hitEnd</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return TRUE if the most recent matching operation touched the end of the text being processed.  <a href="#a843196953b0461c5a7a1387e29fc24ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a2ac192ead8bd207bf70796d333c4cf54">requireEnd</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return TRUE the most recent match succeeded and additional input could cause it to fail.  <a href="#a2ac192ead8bd207bf70796d333c4cf54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRegexPattern.html">RegexPattern</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ade2b83133a537eeb404ca72be909eeff">pattern</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the pattern that is interpreted by this matcher.  <a href="#ade2b83133a537eeb404ca72be909eeff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#afbac43b65b5fbf9ee488266617b0d3b2">replaceAll</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;replacement, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces every substring of the input that matches the pattern with the given replacement string.  <a href="#afbac43b65b5fbf9ee488266617b0d3b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a9774eae99c6241ba4fac61494bbc1b07">replaceAll</a> (<a class="el" href="structUText.html">UText</a> *replacement, <a class="el" href="structUText.html">UText</a> *dest, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces every substring of the input that matches the pattern with the given replacement string.  <a href="#a9774eae99c6241ba4fac61494bbc1b07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#aff123653d65c8722c5526a360515f06d">replaceFirst</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;replacement, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces the first substring of the input that matches the pattern with the replacement string.  <a href="#aff123653d65c8722c5526a360515f06d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a0183728f68b20ace3eb63d017409f2e1">replaceFirst</a> (<a class="el" href="structUText.html">UText</a> *replacement, <a class="el" href="structUText.html">UText</a> *dest, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces the first substring of the input that matches the pattern with the replacement string.  <a href="#a0183728f68b20ace3eb63d017409f2e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a72aaaa7b77e35313ec18a76a32fe0b2d">appendReplacement</a> (<a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;dest, const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;replacement, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a replace operation intended to be used as part of an incremental find-and-replace.  <a href="#a72aaaa7b77e35313ec18a76a32fe0b2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a1d78a1f47ed28e10cbd1bfc2ac5ecd9a">appendReplacement</a> (<a class="el" href="structUText.html">UText</a> *dest, <a class="el" href="structUText.html">UText</a> *replacement, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a replace operation intended to be used as part of an incremental find-and-replace.  <a href="#a1d78a1f47ed28e10cbd1bfc2ac5ecd9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a1342deb93a5e5280c997deaa140ebe32">appendTail</a> (<a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;dest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As the final step in a find-and-replace operation, append the remainder of the input string, starting at the position following the last <a class="el" href="classRegexMatcher.html#a72aaaa7b77e35313ec18a76a32fe0b2d" title="Implements a replace operation intended to be used as part of an incremental find-and-replace...">appendReplacement()</a>, to the destination string.  <a href="#a1342deb93a5e5280c997deaa140ebe32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a9e0a90be3596878b27cc10c2afe9985f">appendTail</a> (<a class="el" href="structUText.html">UText</a> *dest, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As the final step in a find-and-replace operation, append the remainder of the input string, starting at the position following the last <a class="el" href="classRegexMatcher.html#a72aaaa7b77e35313ec18a76a32fe0b2d" title="Implements a replace operation intended to be used as part of an incremental find-and-replace...">appendReplacement()</a>, to the destination string.  <a href="#a9e0a90be3596878b27cc10c2afe9985f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ad3a2b85b74c0345bf6f94a7c568d5191">split</a> (const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;input, <a class="el" href="classUnicodeString.html">UnicodeString</a> dest[], int32_t destCapacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a string into fields.  <a href="#ad3a2b85b74c0345bf6f94a7c568d5191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a83ce65ea32680908683841abcb6108da">split</a> (<a class="el" href="structUText.html">UText</a> *input, <a class="el" href="structUText.html">UText</a> *dest[], int32_t destCapacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a string into fields.  <a href="#a83ce65ea32680908683841abcb6108da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a7330514556bfe1982d13c20778bde909">setTimeLimit</a> (int32_t limit, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a processing time limit for match operations with this Matcher.  <a href="#a7330514556bfe1982d13c20778bde909"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a04d2f34cf72e83106fc35829f44e1c2d">getTimeLimit</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time limit, if any, for match operations made with this Matcher.  <a href="#a04d2f34cf72e83106fc35829f44e1c2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ada12ae9b2fef6369395a28bfb99d6d25">setStackLimit</a> (int32_t limit, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the amount of heap storage available for use by the match backtracking stack.  <a href="#ada12ae9b2fef6369395a28bfb99d6d25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a3f121880706e677b662b45a02a915bab">getStackLimit</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the heap storage available for use by the back tracking stack.  <a href="#a3f121880706e677b662b45a02a915bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#af5d1c93c37ecc29bb88830d1b57049bd">setMatchCallback</a> (<a class="el" href="uregex_8h.html#a0a86299b51ab447fdefa00f6763b44bb">URegexMatchCallback</a> *callback, const void *context, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback function for use with this Matcher.  <a href="#af5d1c93c37ecc29bb88830d1b57049bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#af2365136ca67ad0e3d044be6098722c4">getMatchCallback</a> (<a class="el" href="uregex_8h.html#a0a86299b51ab447fdefa00f6763b44bb">URegexMatchCallback</a> *&amp;callback, const void *&amp;context, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the callback function for this URegularExpression.  <a href="#af2365136ca67ad0e3d044be6098722c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a7f1682437e1c243bc27bd6967105b755">setFindProgressCallback</a> (<a class="el" href="uregex_8h.html#a05a1a31454add644cd2f023b7e4366c3">URegexFindProgressCallback</a> *callback, const void *context, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a progress callback function for use with find operations on this Matcher.  <a href="#a7f1682437e1c243bc27bd6967105b755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#aadb4248db1e7bee3da89d1374d4387f7">getFindProgressCallback</a> (<a class="el" href="uregex_8h.html#a05a1a31454add644cd2f023b7e4366c3">URegexFindProgressCallback</a> *&amp;callback, const void *&amp;context, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the find progress callback function for this URegularExpression.  <a href="#aadb4248db1e7bee3da89d1374d4387f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a9ba9152845cd7fd210e0334bd948a11f">setTrace</a> (<a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setTrace Debug function, enable/disable tracing of the matching engine.  <a href="#a9ba9152845cd7fd210e0334bd948a11f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#ae4dc17624d459e971b521578b872290c">getDynamicClassID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ICU "poor man's RTTI", returns a UClassID for the actual class.  <a href="#ae4dc17624d459e971b521578b872290c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a7adb10b9248d7b89170e0f80a4f26a65">resetPreserveRegion</a> ()</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a925eadd2d94457014581c270d1e8dc64">getStaticClassID</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ICU "poor man's RTTI", returns a UClassID for this class.  <a href="#a925eadd2d94457014581c270d1e8dc64"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6599d2ee7a324de7b810427abcdf1894"></a><!-- doxytag: member="RegexMatcher::RegexPattern" ref="a6599d2ee7a324de7b810427abcdf1894" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegexMatcher.html#a6599d2ee7a324de7b810427abcdf1894">RegexPattern</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c2144b0e5f518674dffbf166bb18bc3"></a><!-- doxytag: member="RegexMatcher::RegexCImpl" ref="a1c2144b0e5f518674dffbf166bb18bc3" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>RegexCImpl</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>class <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> bundles together a regular expression pattern and input text to which the expression can be applied. </p>
<p>It includes methods for testing for matches, and for find and replace operations.</p>
<p>Class <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> is not intended to be subclassed.</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003328">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

<p>Definition at line <a class="el" href="regex_8h_source.html#l00644">644</a> of file <a class="el" href="regex_8h_source.html">regex.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6d8082b5a33770e99ecbd73313bf7a50"></a><!-- doxytag: member="RegexMatcher::RegexMatcher" ref="a6d8082b5a33770e99ecbd73313bf7a50" args="(const UnicodeString &amp;regexp, uint32_t flags, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RegexMatcher::RegexMatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression. </p>
<p>This is a convenience method that avoids the need to explicitly create a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object. Note that if several RegexMatchers need to be created for the same expression, it will be more efficient to separately create and cache a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object, and use its matcher() method to create the <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> objects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>regexp</em>&nbsp;</td><td>The Regular Expression to be compiled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Regular expression options, such as case insensitive matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="uregex_8h.html#a874989dfec4cbeb6baf4d1a51cb529aea909d2ed2c61e34cb62dc13e29f6923ec" title="Enable case insensitive matching.">UREGEX_CASE_INSENSITIVE</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Any errors are reported by setting this UErrorCode variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003347">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a75ef00fe0f6f5004f055c67d49a905cb"></a><!-- doxytag: member="RegexMatcher::RegexMatcher" ref="a75ef00fe0f6f5004f055c67d49a905cb" args="(UText *regexp, uint32_t flags, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RegexMatcher::RegexMatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression. </p>
<p>This is a convenience method that avoids the need to explicitly create a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object. Note that if several RegexMatchers need to be created for the same expression, it will be more efficient to separately create and cache a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object, and use its matcher() method to create the <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> objects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>regexp</em>&nbsp;</td><td>The regular expression to be compiled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Regular expression options, such as case insensitive matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="uregex_8h.html#a874989dfec4cbeb6baf4d1a51cb529aea909d2ed2c61e34cb62dc13e29f6923ec" title="Enable case insensitive matching.">UREGEX_CASE_INSENSITIVE</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Any errors are reported by setting this UErrorCode variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000319">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a47a4616e88fe34d85b440aa0fe6922b9"></a><!-- doxytag: member="RegexMatcher::RegexMatcher" ref="a47a4616e88fe34d85b440aa0fe6922b9" args="(const UnicodeString &amp;regexp, const UnicodeString &amp;input, uint32_t flags, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RegexMatcher::RegexMatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression. </p>
<p>This is a convenience method that avoids the need to explicitly create a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object. Note that if several RegexMatchers need to be created for the same expression, it will be more efficient to separately create and cache a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object, and use its matcher() method to create the <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> objects. </p>
<p>The matcher will retain a reference to the supplied input string, and all regexp pattern matching operations happen directly on the original string. It is critical that the string not be altered or deleted before use by the regular expression operations is complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>regexp</em>&nbsp;</td><td>The Regular Expression to be compiled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The string to match. The matcher retains a reference to the caller's string; mo copy is made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Regular expression options, such as case insensitive matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="uregex_8h.html#a874989dfec4cbeb6baf4d1a51cb529aea909d2ed2c61e34cb62dc13e29f6923ec" title="Enable case insensitive matching.">UREGEX_CASE_INSENSITIVE</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Any errors are reported by setting this UErrorCode variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003348">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af7588a2667611b7086b2fed6f7758ff2"></a><!-- doxytag: member="RegexMatcher::RegexMatcher" ref="af7588a2667611b7086b2fed6f7758ff2" args="(UText *regexp, UText *input, uint32_t flags, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RegexMatcher::RegexMatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for a regular expression. </p>
<p>This is a convenience method that avoids the need to explicitly create a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object. Note that if several RegexMatchers need to be created for the same expression, it will be more efficient to separately create and cache a <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> object, and use its matcher() method to create the <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> objects. </p>
<p>The matcher will make a shallow clone of the supplied input text, and all regexp pattern matching operations happen on this clone. While read-only operations on the supplied text are permitted, it is critical that the underlying string not be altered or deleted before use by the regular expression operations is complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>regexp</em>&nbsp;</td><td>The Regular Expression to be compiled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The string to match. The matcher retains a shallow clone of the text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Regular expression options, such as case insensitive matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="uregex_8h.html#a874989dfec4cbeb6baf4d1a51cb529aea909d2ed2c61e34cb62dc13e29f6923ec" title="Enable case insensitive matching.">UREGEX_CASE_INSENSITIVE</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Any errors are reported by setting this UErrorCode variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000320">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a0e08da6f535d3379399265768bd5adb4"></a><!-- doxytag: member="RegexMatcher::~RegexMatcher" ref="a0e08da6f535d3379399265768bd5adb4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RegexMatcher::~RegexMatcher </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003349">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1d78a1f47ed28e10cbd1bfc2ac5ecd9a"></a><!-- doxytag: member="RegexMatcher::appendReplacement" ref="a1d78a1f47ed28e10cbd1bfc2ac5ecd9a" args="(UText *dest, UText *replacement, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::appendReplacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements a replace operation intended to be used as part of an incremental find-and-replace. </p>
<p>The input string, starting from the end of the previous replacement and ending at the start of the current match, is appended to the destination string. Then the replacement string is appended to the output string, including handling any substitutions of captured text.</p>
<p>For simple, prepackaged, non-incremental find-and-replace operations, see <a class="el" href="classRegexMatcher.html#aff123653d65c8722c5526a360515f06d" title="Replaces the first substring of the input that matches the pattern with the replacement...">replaceFirst()</a> or <a class="el" href="classRegexMatcher.html#afbac43b65b5fbf9ee488266617b0d3b2" title="Replaces every substring of the input that matches the pattern with the given replacement...">replaceAll()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A mutable <a class="el" href="structUText.html" title="UText struct.">UText</a> to which the results of the find-and-replace are appended. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> that provides the text to be substituted for the input text that matched the regexp pattern. The replacement text may contain references to captured text from the input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR if the replacement text specifies a capture group that does not exist in the pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a></dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000336">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a72aaaa7b77e35313ec18a76a32fe0b2d"></a><!-- doxytag: member="RegexMatcher::appendReplacement" ref="a72aaaa7b77e35313ec18a76a32fe0b2d" args="(UnicodeString &amp;dest, const UnicodeString &amp;replacement, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::appendReplacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements a replace operation intended to be used as part of an incremental find-and-replace. </p>
<p>The input string, starting from the end of the previous replacement and ending at the start of the current match, is appended to the destination string. Then the replacement string is appended to the output string, including handling any substitutions of captured text.</p>
<p>For simple, prepackaged, non-incremental find-and-replace operations, see <a class="el" href="classRegexMatcher.html#aff123653d65c8722c5526a360515f06d" title="Replaces the first substring of the input that matches the pattern with the replacement...">replaceFirst()</a> or <a class="el" href="classRegexMatcher.html#afbac43b65b5fbf9ee488266617b0d3b2" title="Replaces every substring of the input that matches the pattern with the given replacement...">replaceAll()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a> to which the results of the find-and-replace are appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>A <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a> that provides the text to be substituted for the input text that matched the regexp pattern. The replacement text may contain references to captured text from the input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR if the replacement text specifies a capture group that does not exist in the pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003379">Stable:</a></b></dt><dd>ICU 2.4</dd></dl>

</div>
</div>
<a class="anchor" id="a9e0a90be3596878b27cc10c2afe9985f"></a><!-- doxytag: member="RegexMatcher::appendTail" ref="a9e0a90be3596878b27cc10c2afe9985f" args="(UText *dest, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::appendTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As the final step in a find-and-replace operation, append the remainder of the input string, starting at the position following the last <a class="el" href="classRegexMatcher.html#a72aaaa7b77e35313ec18a76a32fe0b2d" title="Implements a replace operation intended to be used as part of an incremental find-and-replace...">appendReplacement()</a>, to the destination string. </p>
<p><code><a class="el" href="classRegexMatcher.html#a1342deb93a5e5280c997deaa140ebe32" title="As the final step in a find-and-replace operation, append the remainder of the input...">appendTail()</a></code> is intended to be invoked after one or more invocations of the <code><a class="el" href="classRegexMatcher.html#a72aaaa7b77e35313ec18a76a32fe0b2d" title="Implements a replace operation intended to be used as part of an incremental find-and-replace...">RegexMatcher::appendReplacement()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A mutable <a class="el" href="structUText.html" title="UText struct.">UText</a> to which the results of the find-and-replace are appended. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>error cod </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the destination string.</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000337">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a1342deb93a5e5280c997deaa140ebe32"></a><!-- doxytag: member="RegexMatcher::appendTail" ref="a1342deb93a5e5280c997deaa140ebe32" args="(UnicodeString &amp;dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a>&amp; RegexMatcher::appendTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As the final step in a find-and-replace operation, append the remainder of the input string, starting at the position following the last <a class="el" href="classRegexMatcher.html#a72aaaa7b77e35313ec18a76a32fe0b2d" title="Implements a replace operation intended to be used as part of an incremental find-and-replace...">appendReplacement()</a>, to the destination string. </p>
<p><code><a class="el" href="classRegexMatcher.html#a1342deb93a5e5280c997deaa140ebe32" title="As the final step in a find-and-replace operation, append the remainder of the input...">appendTail()</a></code> is intended to be invoked after one or more invocations of the <code><a class="el" href="classRegexMatcher.html#a72aaaa7b77e35313ec18a76a32fe0b2d" title="Implements a replace operation intended to be used as part of an incremental find-and-replace...">RegexMatcher::appendReplacement()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a> to which the results of the find-and-replace are appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the destination string. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003380">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a4a5240f42531547c10ae55537049f149"></a><!-- doxytag: member="RegexMatcher::end" ref="a4a5240f42531547c10ae55537049f149" args="(int32_t group, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::end </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the character following the text matched by the specified capture group during the previous match operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>the capture group number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed and U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the first character following the text captured by the specified group during the previous match operation. Return -1 if the capture group exists in the pattern but was not part of the match. The index value returned is a native index, corresponding to code units for the underlying encoding type, for example, a byte index for UTF8. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003362">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a80cd2dcc802b61b046d83a6b48935dc4"></a><!-- doxytag: member="RegexMatcher::end" ref="a80cd2dcc802b61b046d83a6b48935dc4" args="(UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the first character following the text matched during the previous match operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the last character matched, plus one. The index value returned is a native index, corresponding to code units for the underlying encoding type, for example, a byte index for UTF-8. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003361">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a49d12181ae2aa940b039ba6f0634cbc2"></a><!-- doxytag: member="RegexMatcher::end64" ref="a49d12181ae2aa940b039ba6f0634cbc2" args="(int32_t group, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t RegexMatcher::end64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the character following the text matched by the specified capture group during the previous match operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>the capture group number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed and U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the first character following the text captured by the specified group during the previous match operation. Return -1 if the capture group exists in the pattern but was not part of the match. The index value returned is a native index, corresponding to code units for the underlying encoding type, for example, a byte index for UTF8. </dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000326">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a7e06b5b80ae872f11b3d3c237bd3d08d"></a><!-- doxytag: member="RegexMatcher::end64" ref="a7e06b5b80ae872f11b3d3c237bd3d08d" args="(UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t RegexMatcher::end64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the first character following the text matched during the previous match operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the last character matched, plus one. The index value returned is a native index, corresponding to code units for the underlying encoding type, for example, a byte index for UTF-8. </dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000325">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aa52b3ecfbb5cd58e9fcce3588d296f82"></a><!-- doxytag: member="RegexMatcher::find" ref="aa52b3ecfbb5cd58e9fcce3588d296f82" args="(int64_t start, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::find </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> and then attempts to find the next substring of the input string that matches the pattern, starting at the specified index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The (native) index in the input string to begin the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if a match is found. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003355">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a0c7ef0d32a9dc7eb57d0d31d0a8fdb02"></a><!-- doxytag: member="RegexMatcher::find" ref="a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::find </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the next pattern match in the input string. </p>
<p>The find begins searching the input at the location following the end of the previous match, or at the start of the string if there is no previous match. If a match is found, <code><a class="el" href="classRegexMatcher.html#ace59b3327cb3d476016d57b0bd76611c" title="Returns the index in the input string of the start of the text matched during the...">start()</a>, <a class="el" href="classRegexMatcher.html#a80cd2dcc802b61b046d83a6b48935dc4" title="Returns the index in the input string of the first character following the text matched...">end()</a></code> and <code><a class="el" href="classRegexMatcher.html#a8d98f84b7446c78408fc36366ccfdafb" title="Returns a string containing the text matched by the previous match.">group()</a></code> will provide more information regarding the match. </p>
<p>Note that if the input string is changed by the application, use find(startPos, status) instead of <a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" title="Find the next pattern match in the input string.">find()</a>, because the saved starting position may not be valid with the altered input string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if a match is found. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003354">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="ae4dc17624d459e971b521578b872290c"></a><!-- doxytag: member="RegexMatcher::getDynamicClassID" ref="ae4dc17624d459e971b521578b872290c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> RegexMatcher::getDynamicClassID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ICU "poor man's RTTI", returns a UClassID for the actual class. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003389">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Implements <a class="el" href="classUObject.html#a9b1acc95efd89cb86ec31f2dc947a262">UObject</a>.</p>

</div>
</div>
<a class="anchor" id="aadb4248db1e7bee3da89d1374d4387f7"></a><!-- doxytag: member="RegexMatcher::getFindProgressCallback" ref="aadb4248db1e7bee3da89d1374d4387f7" args="(URegexFindProgressCallback *&amp;callback, const void *&amp;context, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RegexMatcher::getFindProgressCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uregex_8h.html#a05a1a31454add644cd2f023b7e4366c3">URegexFindProgressCallback</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the find progress callback function for this URegularExpression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Out parameter, receives a pointer to the user-supplied callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>Out parameter, receives the user context pointer that was set when <a class="el" href="uregex_8h.html#a9082576d5bbc1f16758b15f899d43e88" title="Set the find progress callback function for this URegularExpression.">uregex_setFindProgressCallback()</a> was called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000340">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ad1d73b5633f5e89cbadbddee8f2397b0"></a><!-- doxytag: member="RegexMatcher::getInput" ref="ad1d73b5633f5e89cbadbddee8f2397b0" args="(UText *dest, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::getInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the input string being matched, either by copying it into the provided <a class="el" href="structUText.html" title="UText struct.">UText</a> parameter or by returning a shallow clone of the live input. </p>
<p>Note that copying the entire input may cause significant performance and memory issues. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> into which the input should be copied, or NULL to create a new <a class="el" href="structUText.html" title="UText struct.">UText</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dest if non-NULL, a shallow copy of the input text otherwise</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000330">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af2365136ca67ad0e3d044be6098722c4"></a><!-- doxytag: member="RegexMatcher::getMatchCallback" ref="af2365136ca67ad0e3d044be6098722c4" args="(URegexMatchCallback *&amp;callback, const void *&amp;context, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RegexMatcher::getMatchCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uregex_8h.html#a0a86299b51ab447fdefa00f6763b44bb">URegexMatchCallback</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the callback function for this URegularExpression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Out parameter, receives a pointer to the user-supplied callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>Out parameter, receives the user context pointer that was set when <a class="el" href="uregex_8h.html#a8e1cae7b8de77df89081cb1ea36cf14b" title="Set a callback function for this URegularExpression.">uregex_setMatchCallback()</a> was called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003387">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a3f121880706e677b662b45a02a915bab"></a><!-- doxytag: member="RegexMatcher::getStackLimit" ref="a3f121880706e677b662b45a02a915bab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::getStackLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of the heap storage available for use by the back tracking stack. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum backtracking stack size, in bytes, or zero if the stack size is unlimited. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003385">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a925eadd2d94457014581c270d1e8dc64"></a><!-- doxytag: member="RegexMatcher::getStaticClassID" ref="a925eadd2d94457014581c270d1e8dc64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="utypes_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> RegexMatcher::getStaticClassID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ICU "poor man's RTTI", returns a UClassID for this class. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003388">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a04d2f34cf72e83106fc35829f44e1c2d"></a><!-- doxytag: member="RegexMatcher::getTimeLimit" ref="a04d2f34cf72e83106fc35829f44e1c2d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::getTimeLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the time limit, if any, for match operations made with this Matcher. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum allowed time for a match, in units of processing steps. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003383">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1ba2de816176ae692de9fe3c7f335892"></a><!-- doxytag: member="RegexMatcher::group" ref="a1ba2de816176ae692de9fe3c7f335892" args="(int32_t groupNum, UText *dest, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::group </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>groupNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string containing the text captured by the given group during the previous match operation. </p>
<p>Group(0) is the entire match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>groupNum</em>&nbsp;</td><td>the capture group number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A mutable <a class="el" href="structUText.html" title="UText struct.">UText</a> in which the matching text is placed. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created (which may not be mutable). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the matched input text. If a pre-allocated <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be used and returned.</dd></dl>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000399">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. ICU 4.4 technology preview </dd></dl>

</div>
</div>
<a class="anchor" id="a92b218c8cb8c5692e657530b20173eea"></a><!-- doxytag: member="RegexMatcher::group" ref="a92b218c8cb8c5692e657530b20173eea" args="(int32_t groupNum, UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::group </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>groupNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&nbsp;</td>
          <td class="paramname"> <em>group_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a shallow clone of the entire live input string with the <a class="el" href="structUText.html" title="UText struct.">UText</a> current native index set to the beginning of the requested group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>groupNum</em>&nbsp;</td><td>The capture group number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> into which the input should be cloned, or NULL to create a new <a class="el" href="structUText.html" title="UText struct.">UText</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group_len</em>&nbsp;</td><td>A reference to receive the length of the desired capture group </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed and U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dest if non-NULL, a shallow copy of the input text otherwise</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000322">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="abdb105391cfc2997354b0b0b7c384326"></a><!-- doxytag: member="RegexMatcher::group" ref="abdb105391cfc2997354b0b0b7c384326" args="(UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&nbsp;</td>
          <td class="paramname"> <em>group_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a shallow clone of the entire live input string with the <a class="el" href="structUText.html" title="UText struct.">UText</a> current native index set to the beginning of the requested group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> into which the input should be cloned, or NULL to create a new <a class="el" href="structUText.html" title="UText struct.">UText</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group_len</em>&nbsp;</td><td>A reference to receive the length of the desired capture group </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed and U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dest if non-NULL, a shallow copy of the input text otherwise</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000321">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a01c6fc5b7b8f94e977454b61bd3e5d86"></a><!-- doxytag: member="RegexMatcher::group" ref="a01c6fc5b7b8f94e977454b61bd3e5d86" args="(int32_t groupNum, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a> RegexMatcher::group </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>groupNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string containing the text captured by the given group during the previous match operation. </p>
<p>Group(0) is the entire match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>groupNum</em>&nbsp;</td><td>the capture group number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed and U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the captured text </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003357">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a8d98f84b7446c78408fc36366ccfdafb"></a><!-- doxytag: member="RegexMatcher::group" ref="a8d98f84b7446c78408fc36366ccfdafb" args="(UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a> RegexMatcher::group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string containing the text matched by the previous match. </p>
<p>If the pattern can match an empty string, an empty string may be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing the matched input text. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003356">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="ae08fe8369c2986b16c772055497d184c"></a><!-- doxytag: member="RegexMatcher::groupCount" ref="ae08fe8369c2986b16c772055497d184c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::groupCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of capturing groups in this matcher's pattern. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of capture groups </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003358">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a21e4914b4d1c9612614ebd7b39d34772"></a><!-- doxytag: member="RegexMatcher::hasAnchoringBounds" ref="a21e4914b4d1c9612614ebd7b39d34772" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::hasAnchoringBounds </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this matcher is using anchoring bounds. </p>
<p>By default, matchers use anchoring region bounds.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if this matcher is using anchoring bounds. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003372">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1213ec0995f84d56540260e7bbe30490"></a><!-- doxytag: member="RegexMatcher::hasTransparentBounds" ref="a1213ec0995f84d56540260e7bbe30490" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::hasTransparentBounds </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries the transparency of region bounds for this matcher. </p>
<p>See useTransparentBounds for a description of transparent and opaque bounds. By default, a matcher uses opaque region boundaries.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if this matcher is using opaque bounds, false if it is not. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003370">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a843196953b0461c5a7a1387e29fc24ae"></a><!-- doxytag: member="RegexMatcher::hitEnd" ref="a843196953b0461c5a7a1387e29fc24ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::hitEnd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return TRUE if the most recent matching operation touched the end of the text being processed. </p>
<p>In this case, additional input text could change the results of that match.</p>
<p><a class="el" href="classRegexMatcher.html#a843196953b0461c5a7a1387e29fc24ae" title="Return TRUE if the most recent matching operation touched the end of the text being...">hitEnd()</a> is defined for both successful and unsuccessful matches. In either case <a class="el" href="classRegexMatcher.html#a843196953b0461c5a7a1387e29fc24ae" title="Return TRUE if the most recent matching operation touched the end of the text being...">hitEnd()</a> will return TRUE if if the end of the text was reached at any point during the matching process.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the most recent match hit the end of input </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003374">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="acfed242304a8cf781966fb812d312574"></a><!-- doxytag: member="RegexMatcher::input" ref="acfed242304a8cf781966fb812d312574" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classUnicodeString.html">UnicodeString</a>&amp; RegexMatcher::input </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the input string being matched. </p>
<p>Ownership of the string belongs to the matcher; it should not be altered or deleted. This method will work even if the input was originally supplied as a <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the input string </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003366">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a28bb7415a21aa4b9ec436e171f51fbdc"></a><!-- doxytag: member="RegexMatcher::inputText" ref="a28bb7415a21aa4b9ec436e171f51fbdc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::inputText </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the input string being matched. </p>
<p>This is the live input text; it should not be altered or deleted. This method will work even if the input was originally supplied as a <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the input text</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000329">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a75c7ca9b7f32341de5b576c7a08214f4"></a><!-- doxytag: member="RegexMatcher::lookingAt" ref="a75c7ca9b7f32341de5b576c7a08214f4" args="(int64_t startIndex, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::lookingAt </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to match the input string, starting from the specified index, against the pattern. </p>
<p>The match may be of any length, and is not required to extend to the end of the input string. Contrast with match().</p>
<p>If the match succeeds then more information can be obtained via the <code><a class="el" href="classRegexMatcher.html#ace59b3327cb3d476016d57b0bd76611c" title="Returns the index in the input string of the start of the text matched during the...">start()</a></code>, <code><a class="el" href="classRegexMatcher.html#a80cd2dcc802b61b046d83a6b48935dc4" title="Returns the index in the input string of the first character following the text matched...">end()</a></code>, and <code><a class="el" href="classRegexMatcher.html#a8d98f84b7446c78408fc36366ccfdafb" title="Returns a string containing the text matched by the previous match.">group()</a></code> functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startIndex</em>&nbsp;</td><td>The input string (native) index at which to begin matching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if there is a match. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003353">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a class="anchor" id="ab04a667874c99f69ca9816240d934908"></a><!-- doxytag: member="RegexMatcher::lookingAt" ref="ab04a667874c99f69ca9816240d934908" args="(UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::lookingAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to match the input string, starting from the beginning of the region, against the pattern. </p>
<p>Like the <a class="el" href="classRegexMatcher.html#a3c83ab49b979b5c610819fee1fe8463f" title="Attempts to match the entire input region against the pattern.">matches()</a> method, this function always starts at the beginning of the input region; unlike that function, it does not require that the entire region be matched.</p>
<p>If the match succeeds then more information can be obtained via the <code><a class="el" href="classRegexMatcher.html#ace59b3327cb3d476016d57b0bd76611c" title="Returns the index in the input string of the start of the text matched during the...">start()</a></code>, <code><a class="el" href="classRegexMatcher.html#a80cd2dcc802b61b046d83a6b48935dc4" title="Returns the index in the input string of the first character following the text matched...">end()</a></code>, and <code><a class="el" href="classRegexMatcher.html#a8d98f84b7446c78408fc36366ccfdafb" title="Returns a string containing the text matched by the previous match.">group()</a></code> functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if there is a match at the start of the input string. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003352">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a0073eae367c3a72bc1dbe40b04becdcb"></a><!-- doxytag: member="RegexMatcher::matches" ref="a0073eae367c3a72bc1dbe40b04becdcb" args="(int64_t startIndex, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::matches </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the matcher, then attempts to match the input beginning at the specified startIndex, and extending to the end of the input. </p>
<p>The input region is reset to include the entire input string. A successful match must extend to the end of the input. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startIndex</em>&nbsp;</td><td>The input string (native) index at which to begin matching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if there is a match </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003351">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a3c83ab49b979b5c610819fee1fe8463f"></a><!-- doxytag: member="RegexMatcher::matches" ref="a3c83ab49b979b5c610819fee1fe8463f" args="(UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::matches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to match the entire input region against the pattern. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if there is a match </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003350">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="ade2b83133a537eeb404ca72be909eeff"></a><!-- doxytag: member="RegexMatcher::pattern" ref="ade2b83133a537eeb404ca72be909eeff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classRegexPattern.html">RegexPattern</a>&amp; RegexMatcher::pattern </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the pattern that is interpreted by this matcher. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classRegexPattern.html" title="Class RegexPattern represents a compiled regular expression.">RegexPattern</a> for this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003376">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a9b42112355418492da8302c3f3e2c61f"></a><!-- doxytag: member="RegexMatcher::refreshInputText" ref="a9b42112355418492da8302c3f3e2c61f" args="(UText *input, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::refreshInputText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the subject text string upon which the regular expression is looking for matches without changing any other aspect of the matching state. </p>
<p>The new and previous text strings must have the same content.</p>
<p>This function is intended for use in environments where ICU is operating on strings that may move around in memory. It provides a mechanism for notifying ICU that the string has been relocated, and providing a new <a class="el" href="structUText.html" title="UText struct.">UText</a> to access the string in its new position.</p>
<p>Note that the regular expression implementation never copies the underlying text of a string being matched, but always operates directly on the original text provided by the user. Refreshing simply drops the references to the old text and replaces them with references to the new.</p>
<p>Caution: this function is normally used only by very specialized, system-level code. One example use case is with garbage collection that moves the text in memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The new (moved) text string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>Receives errors detected by this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000328">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a981a81b82753c236dfd8360af289bf29"></a><!-- doxytag: member="RegexMatcher::region" ref="a981a81b82753c236dfd8360af289bf29" args="(int64_t regionStart, int64_t regionLimit, int64_t startIndex, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::region </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>regionLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identical to region(start, limit, status) but also allows a start position without resetting the region state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>regionStart</em>&nbsp;</td><td>The region start </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regionLimit</em>&nbsp;</td><td>the limit of the region </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startIndex</em>&nbsp;</td><td>The (native) index within the region bounds at which to begin searches. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. If startIndex is not within the specified region bounds, U_INDEX_OUTOFBOUNDS_ERROR is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000331">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a92526d42ab81529a26f016516e0d734b"></a><!-- doxytag: member="RegexMatcher::region" ref="a92526d42ab81529a26f016516e0d734b" args="(int64_t start, int64_t limit, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::region </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the limits of this matcher's region. </p>
<p>The region is the part of the input string that will be searched to find a match. Invoking this method resets the matcher, and then sets the region to start at the index specified by the start parameter and end at the index specified by the end parameter.</p>
<p>Depending on the transparency and anchoring being used (see useTransparentBounds and useAnchoringBounds), certain constructs such as anchors may behave differently at or around the boundaries of the region</p>
<p>The function will fail if start is greater than limit, or if either index is less than zero or greater than the length of the string being matched.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The (native) index to begin searches at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The index to end searches at (exclusive). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003367">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a5c91aff80b7a8bf549263341b818f8cc"></a><!-- doxytag: member="RegexMatcher::regionEnd" ref="a5c91aff80b7a8bf549263341b818f8cc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::regionEnd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reports the end (limit) index (exclusive) of this matcher's region. </p>
<p>The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ending point (native) of this matcher's region. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003369">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fda6ddcd54c5f2c0769eddd95ec3d90"></a><!-- doxytag: member="RegexMatcher::regionEnd64" ref="a1fda6ddcd54c5f2c0769eddd95ec3d90" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t RegexMatcher::regionEnd64 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reports the end (limit) index (exclusive) of this matcher's region. </p>
<p>The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The ending point (native) of this matcher's region. </dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000333">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ae37cccdee76c94b20d0b6bc289ac3c39"></a><!-- doxytag: member="RegexMatcher::regionStart" ref="ae37cccdee76c94b20d0b6bc289ac3c39" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::regionStart </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reports the start index of this matcher's region. </p>
<p>The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The starting (native) index of this matcher's region. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003368">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4004f5ab6c7d5341784abe40e4c318f9"></a><!-- doxytag: member="RegexMatcher::regionStart64" ref="a4004f5ab6c7d5341784abe40e4c318f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t RegexMatcher::regionStart64 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reports the start index of this matcher's region. </p>
<p>The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The starting (native) index of this matcher's region. </dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000332">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a9774eae99c6241ba4fac61494bbc1b07"></a><!-- doxytag: member="RegexMatcher::replaceAll" ref="a9774eae99c6241ba4fac61494bbc1b07" args="(UText *replacement, UText *dest, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::replaceAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces every substring of the input that matches the pattern with the given replacement string. </p>
<p>This is a convenience function that provides a complete find-and-replace-all operation.</p>
<p>This method first resets this matcher. It then scans the input string looking for matches of the pattern. Input that is not part of any match is left unchanged; each match is replaced in the result by the replacement string. The replacement string may contain references to capture groups.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>a string containing the replacement text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>a mutable <a class="el" href="structUText.html" title="UText struct.">UText</a> in which the results are placed. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created (which may not be mutable). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing the results of the find and replace. If a pre-allocated <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be used and returned.</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000334">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="afbac43b65b5fbf9ee488266617b0d3b2"></a><!-- doxytag: member="RegexMatcher::replaceAll" ref="afbac43b65b5fbf9ee488266617b0d3b2" args="(const UnicodeString &amp;replacement, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a> RegexMatcher::replaceAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces every substring of the input that matches the pattern with the given replacement string. </p>
<p>This is a convenience function that provides a complete find-and-replace-all operation.</p>
<p>This method first resets this matcher. It then scans the input string looking for matches of the pattern. Input that is not part of any match is left unchanged; each match is replaced in the result by the replacement string. The replacement string may contain references to capture groups.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>a string containing the replacement text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing the results of the find and replace. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003377">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a0183728f68b20ace3eb63d017409f2e1"></a><!-- doxytag: member="RegexMatcher::replaceFirst" ref="a0183728f68b20ace3eb63d017409f2e1" args="(UText *replacement, UText *dest, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* RegexMatcher::replaceFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the first substring of the input that matches the pattern with the replacement string. </p>
<p>This is a convenience function that provides a complete find-and-replace operation.</p>
<p>This function first resets this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a>. It then scans the input string looking for a match of the pattern. Input that is not part of the match is appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured groups.</p>
<p>The state of the matcher (the position at which a subsequent <a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" title="Find the next pattern match in the input string.">find()</a> would begin) after completing a <a class="el" href="classRegexMatcher.html#aff123653d65c8722c5526a360515f06d" title="Replaces the first substring of the input that matches the pattern with the replacement...">replaceFirst()</a> is not specified. The <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> should be reset before doing additional <a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" title="Find the next pattern match in the input string.">find()</a> operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>a string containing the replacement text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>a mutable <a class="el" href="structUText.html" title="UText struct.">UText</a> in which the results are placed. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created (which may not be mutable). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing the results of the find and replace. If a pre-allocated <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be used and returned.</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000335">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aff123653d65c8722c5526a360515f06d"></a><!-- doxytag: member="RegexMatcher::replaceFirst" ref="aff123653d65c8722c5526a360515f06d" args="(const UnicodeString &amp;replacement, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classUnicodeString.html">UnicodeString</a> RegexMatcher::replaceFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the first substring of the input that matches the pattern with the replacement string. </p>
<p>This is a convenience function that provides a complete find-and-replace operation.</p>
<p>This function first resets this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a>. It then scans the input string looking for a match of the pattern. Input that is not part of the match is appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured groups.</p>
<p>The state of the matcher (the position at which a subsequent <a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" title="Find the next pattern match in the input string.">find()</a> would begin) after completing a <a class="el" href="classRegexMatcher.html#aff123653d65c8722c5526a360515f06d" title="Replaces the first substring of the input that matches the pattern with the replacement...">replaceFirst()</a> is not specified. The <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> should be reset before doing additional <a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" title="Find the next pattern match in the input string.">find()</a> operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacement</em>&nbsp;</td><td>a string containing the replacement text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing the results of the find and replace. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003378">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a2ac192ead8bd207bf70796d333c4cf54"></a><!-- doxytag: member="RegexMatcher::requireEnd" ref="a2ac192ead8bd207bf70796d333c4cf54" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> RegexMatcher::requireEnd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return TRUE the most recent match succeeded and additional input could cause it to fail. </p>
<p>If this method returns false and a match was found, then more input might change the match but the match won't be lost. If a match was not found, then requireEnd has no meaning.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if more input could cause the most recent match to no longer match. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003375">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1371b482a8e27f4a5398a9b6daf093b3"></a><!-- doxytag: member="RegexMatcher::reset" ref="a1371b482a8e27f4a5398a9b6daf093b3" args="(UText *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets this matcher with a new input string. </p>
<p>This allows instances of <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> to be reused, which is more efficient than creating a new <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for each input string to be processed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The new string on which subsequent pattern matches will operate. The matcher makes a shallow clone of the given text; ownership of the original string remains with the caller. Because no deep copy of the text is made, it is essential that the caller not modify the string until after regexp operations on it are done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a>.</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000327">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aafc5e4f9cb857068d0d6be4ef67ca8d0"></a><!-- doxytag: member="RegexMatcher::reset" ref="aafc5e4f9cb857068d0d6be4ef67ca8d0" args="(const UnicodeString &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets this matcher with a new input string. </p>
<p>This allows instances of <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> to be reused, which is more efficient than creating a new <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a> for each input string to be processed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The new string on which subsequent pattern matches will operate. The matcher retains a reference to the callers string, and operates directly on that. Ownership of the string remains with the caller. Because no copy of the string is made, it is essential that the caller not delete the string until after regexp operations on it are done. Note that while a reset on the matcher with an input string that is then modified across/during matcher operations may be supported currently for <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a>, this was not originally intended behavior, and support for this is not guaranteed in upcoming versions of ICU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a>. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003365">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="acd2a4ba2d7fd366a8010159aaf9e4c86"></a><!-- doxytag: member="RegexMatcher::reset" ref="acd2a4ba2d7fd366a8010159aaf9e4c86" args="(int64_t index, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::reset </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets this matcher, and set the current input position. </p>
<p>The effect is to remove any memory of previous matches, and to cause subsequent <a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" title="Find the next pattern match in the input string.">find()</a> operations to begin at the specified (native) position in the input string. </p>
<p>The matcher's region is reset to its default, which is the entire input string. </p>
<p>An alternative to this function is to set a match region beginning at the desired index.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a>. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003364">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a0564fa9029cf90afd6008e1c2863ff47"></a><!-- doxytag: member="RegexMatcher::reset" ref="a0564fa9029cf90afd6008e1c2863ff47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets this matcher. </p>
<p>The effect is to remove any memory of previous matches, and to cause subsequent <a class="el" href="classRegexMatcher.html#a0c7ef0d32a9dc7eb57d0d31d0a8fdb02" title="Find the next pattern match in the input string.">find()</a> operations to begin at the beginning of the input string.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>this <a class="el" href="classRegexMatcher.html" title="class RegexMatcher bundles together a regular expression pattern and input text to...">RegexMatcher</a>. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003363">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a7adb10b9248d7b89170e0f80a4f26a65"></a><!-- doxytag: member="RegexMatcher::resetPreserveRegion" ref="a7adb10b9248d7b89170e0f80a4f26a65" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RegexMatcher::resetPreserveRegion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000402">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f1682437e1c243bc27bd6967105b755"></a><!-- doxytag: member="RegexMatcher::setFindProgressCallback" ref="a7f1682437e1c243bc27bd6967105b755" args="(URegexFindProgressCallback *callback, const void *context, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RegexMatcher::setFindProgressCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uregex_8h.html#a05a1a31454add644cd2f023b7e4366c3">URegexFindProgressCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a progress callback function for use with find operations on this Matcher. </p>
<p>During find operations, the callback will be invoked after each return from a match attempt, giving the application the opportunity to terminate a long-running find operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A pointer to the user-supplied callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>User context pointer. The value supplied at the time the callback function is set will be saved and passed to the callback each time that it is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000339">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af5d1c93c37ecc29bb88830d1b57049bd"></a><!-- doxytag: member="RegexMatcher::setMatchCallback" ref="af5d1c93c37ecc29bb88830d1b57049bd" args="(URegexMatchCallback *callback, const void *context, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RegexMatcher::setMatchCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uregex_8h.html#a0a86299b51ab447fdefa00f6763b44bb">URegexMatchCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a callback function for use with this Matcher. </p>
<p>During matching operations the function will be called periodically, giving the application the opportunity to terminate a long-running match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A pointer to the user-supplied callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>User context pointer. The value supplied at the time the callback function is set will be saved and passed to the callback each time that it is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003386">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ada12ae9b2fef6369395a28bfb99d6d25"></a><!-- doxytag: member="RegexMatcher::setStackLimit" ref="ada12ae9b2fef6369395a28bfb99d6d25" args="(int32_t limit, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RegexMatcher::setStackLimit </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the amount of heap storage available for use by the match backtracking stack. </p>
<p>The matcher is also reset, discarding any results from previous matches. </p>
<p>ICU uses a backtracking regular expression engine, with the backtrack stack maintained on the heap. This function sets the limit to the amount of memory that can be used for this purpose. A backtracking stack overflow will result in an error from the match operation that caused it. </p>
<p>A limit is desirable because a malicious or poorly designed pattern can use excessive memory, potentially crashing the process. A limit is enabled by default. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The maximum size, in bytes, of the matching backtrack stack. A value of zero means no limit. The limit must be greater or equal to zero.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003384">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a7330514556bfe1982d13c20778bde909"></a><!-- doxytag: member="RegexMatcher::setTimeLimit" ref="a7330514556bfe1982d13c20778bde909" args="(int32_t limit, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RegexMatcher::setTimeLimit </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a processing time limit for match operations with this Matcher. </p>
<p>Some patterns, when matching certain strings, can run in exponential time. For practical purposes, the match operation may appear to be in an infinite loop. When a limit is set a match operation will fail with an error if the limit is exceeded. </p>
<p>The units of the limit are steps of the match engine. Correspondence with actual processor time will depend on the speed of the processor and the details of the specific pattern, but will typically be on the order of milliseconds. </p>
<p>By default, the matching time is not limited. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The limit value, or 0 for no limit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003382">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9ba9152845cd7fd210e0334bd948a11f"></a><!-- doxytag: member="RegexMatcher::setTrace" ref="a9ba9152845cd7fd210e0334bd948a11f" args="(UBool state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RegexMatcher::setTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>setTrace Debug function, enable/disable tracing of the matching engine. </p>
<p>For internal ICU development use only. DO NO USE!!!! </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000401">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a class="anchor" id="a83ce65ea32680908683841abcb6108da"></a><!-- doxytag: member="RegexMatcher::split" ref="a83ce65ea32680908683841abcb6108da" args="(UText *input, UText *dest[], int32_t destCapacity, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a string into fields. </p>
<p>Somewhat like <a class="el" href="classRegexMatcher.html#ad3a2b85b74c0345bf6f94a7c568d5191" title="Split a string into fields.">split()</a> from Perl. The pattern matches identify delimiters that separate the input into fields. The input data between the matches becomes the fields themselves.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The string to be split into fields. The field delimiters match the pattern (in the "this" object). This matcher will be reset to this input string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>An array of mutable <a class="el" href="structUText.html" title="UText struct.">UText</a> structs to receive the results of the split. If a field is NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> is allocated to contain the results for that field. This new <a class="el" href="structUText.html" title="UText struct.">UText</a> is not guaranteed to be mutable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The number of elements in the destination array. If the number of fields found is less than destCapacity, the extra strings in the destination array are not altered. If the number of destination strings is less than the number of fields, the trailing part of the input string, including any field delimiters, is placed in the last destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of fields into which the input string was split.</dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000338">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ad3a2b85b74c0345bf6f94a7c568d5191"></a><!-- doxytag: member="RegexMatcher::split" ref="ad3a2b85b74c0345bf6f94a7c568d5191" args="(const UnicodeString &amp;input, UnicodeString dest[], int32_t destCapacity, UErrorCode &amp;status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUnicodeString.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnicodeString.html">UnicodeString</a>&nbsp;</td>
          <td class="paramname"> <em>dest</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a string into fields. </p>
<p>Somewhat like <a class="el" href="classRegexMatcher.html#ad3a2b85b74c0345bf6f94a7c568d5191" title="Split a string into fields.">split()</a> from Perl. The pattern matches identify delimiters that separate the input into fields. The input data between the matches becomes the fields themselves.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The string to be split into fields. The field delimiters match the pattern (in the "this" object). This matcher will be reset to this input string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>An array of UnicodeStrings to receive the results of the split. This is an array of actual <a class="el" href="classUnicodeString.html" title="UnicodeString is a string class that stores Unicode characters directly and provides...">UnicodeString</a> objects, not an array of pointers to strings. Local (stack based) arrays can work well here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The number of elements in the destination array. If the number of fields found is less than destCapacity, the extra strings in the destination array are not altered. If the number of destination strings is less than the number of fields, the trailing part of the input string, including any field delimiters, is placed in the last destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of fields into which the input string was split. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003381">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ab526773d931447d8c990896e02375216"></a><!-- doxytag: member="RegexMatcher::start" ref="ab526773d931447d8c990896e02375216" args="(int32_t group, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::start </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the start of the text matched by the specified capture group during the previous match operation. </p>
<p>Return -1 if the capture group exists in the pattern, but was not part of the last match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>the capture group number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the (native) start position of substring matched by the specified group. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003360">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="ace59b3327cb3d476016d57b0bd76611c"></a><!-- doxytag: member="RegexMatcher::start" ref="ace59b3327cb3d476016d57b0bd76611c" args="(UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t RegexMatcher::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the start of the text matched during the previous match operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The (native) position in the input string of the start of the last match. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003359">Stable:</a></b></dt><dd>ICU 2.4 </dd></dl>

</div>
</div>
<a class="anchor" id="abf1aec7feda15ffeffc70582e98f9311"></a><!-- doxytag: member="RegexMatcher::start64" ref="abf1aec7feda15ffeffc70582e98f9311" args="(int32_t group, UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t RegexMatcher::start64 </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the start of the text matched by the specified capture group during the previous match operation. </p>
<p>Return -1 if the capture group exists in the pattern, but was not part of the last match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>the capture group number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A reference to a UErrorCode to receive any errors. Possible errors are U_REGEX_INVALID_STATE if no match has been attempted or the last match failed, and U_INDEX_OUTOFBOUNDS_ERROR for a bad capture group number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the (native) start position of substring matched by the specified group. </dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000324">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a477a2c4729c9f78eff96e53f48e9c215"></a><!-- doxytag: member="RegexMatcher::start64" ref="a477a2c4729c9f78eff96e53f48e9c215" args="(UErrorCode &amp;status) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t RegexMatcher::start64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>status</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index in the input string of the start of the text matched during the previous match operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a reference to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The (native) position in the input string of the start of the last match. </dd></dl>
<dl class="draft"><dt><b><a class="el" href="draft.html#_draft000323">Draft:</a></b></dt><dd>This API may be changed in the future versions and was introduced in ICU 4.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc3a77ca9f4457fe9d350f9aaa71f8d"></a><!-- doxytag: member="RegexMatcher::useAnchoringBounds" ref="a3bc3a77ca9f4457fe9d350f9aaa71f8d" args="(UBool b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::useAnchoringBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether this matcher is using Anchoring Bounds for its region. </p>
<p>With anchoring bounds, pattern anchors such as ^ and $ will match at the start and end of the region. Without Anchoring Bounds, anchors will only match at the positions they would in the complete text.</p>
<p>Anchoring Bounds are the default for regions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>TRUE if to enable anchoring bounds; FALSE to disable them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This Matcher </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003373">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="acf0c77059fa4880ad467b064d886f138"></a><!-- doxytag: member="RegexMatcher::useTransparentBounds" ref="acf0c77059fa4880ad467b064d886f138" args="(UBool b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRegexMatcher.html">RegexMatcher</a>&amp; RegexMatcher::useTransparentBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the transparency of region bounds for this matcher. </p>
<p>Invoking this function with an argument of true will set this matcher to use transparent bounds. If the boolean argument is false, then opaque bounds will be used.</p>
<p>Using transparent bounds, the boundaries of this matcher's region are transparent to lookahead, lookbehind, and boundary matching constructs. Those constructs can see text beyond the boundaries of the region while checking for a match.</p>
<p>With opaque bounds, no text outside of the matcher's region is visible to lookahead, lookbehind, and boundary matching constructs.</p>
<p>By default, a matcher uses opaque bounds.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>TRUE for transparent bounds; FALSE for opaque bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This Matcher; </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003371">Stable:</a></b></dt><dd>ICU 4.0 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="regex_8h_source.html">regex.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Jul 26 12:57:02 2011 for ICU 4.8.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
