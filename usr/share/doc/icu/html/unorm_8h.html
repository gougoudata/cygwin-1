<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ICU 4.8.1: unorm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>unorm.h File Reference</h1>
<p>C API: Unicode Normalization.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="utypes_8h_source.html">unicode/utypes.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="uiter_8h_source.html">unicode/uiter.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="unorm2_8h_source.html">unicode/unorm2.h</a>&quot;</code><br/>

<p><a href="unorm_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#a2962ecfc131adbea913c9ac34eaed4b6">UNORM_COMPARE_NORM_OPTIONS_SHIFT</a>&nbsp;&nbsp;&nbsp;20</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowest-order bit number of <a class="el" href="unorm_8h.html#a991e0fe6f0d062dd6e8e924517f3f437" title="Compare two strings for canonical equivalence.">unorm_compare()</a> options bits corresponding to normalization options bits.  <a href="#a2962ecfc131adbea913c9ac34eaed4b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#ab2632f6548f0574ded0d37671ead94b6">UNORM_INPUT_IS_FCD</a>&nbsp;&nbsp;&nbsp;0x20000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Option bit for unorm_compare: Both input strings are assumed to fulfill FCD conditions.  <a href="#ab2632f6548f0574ded0d37671ead94b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#a6cc4c8b0d5be7ce1ac4b600ace7817f5">U_COMPARE_IGNORE_CASE</a>&nbsp;&nbsp;&nbsp;0x10000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Option bit for unorm_compare: Perform case-insensitive comparison.  <a href="#a6cc4c8b0d5be7ce1ac4b600ace7817f5"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> { <br/>
&nbsp;&nbsp;<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7a120a05cf3e51beaf4d9fbb6a4a1993c7">UNORM_NONE</a> =  1, 
<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7a60f3fa3dbcdfc2a075143fe078493e3a">UNORM_NFD</a> =  2, 
<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7a42f246a2e989929b24b2a4c84fe3a51a">UNORM_NFKD</a> =  3, 
<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7a5b8bb462684c034d347e8dbcf4b77331">UNORM_NFC</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7a0f833bde534a6902911c62dbb091a585">UNORM_DEFAULT</a> =  UNORM_NFC, 
<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7a9f7f2ae3788d9aa8e6dff82697d6d0db">UNORM_NFKC</a> = 5, 
<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7aac4a0a6b26928af19d2cef5985bdce8d">UNORM_FCD</a> =  6, 
<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7ab16cae528525fca531bcdee42b153796">UNORM_MODE_COUNT</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constants for normalization modes. </p>
 <a href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="unorm_8h.html#a05589fbab0657f08285ebdfe93f5ec9ea5b4745b8b611e2d7e6245c023e22e462">UNORM_UNICODE_3_2</a> = 0x20
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constants for options flags for normalization. </p>
 <a href="unorm_8h.html#a05589fbab0657f08285ebdfe93f5ec9e">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#a5410fab40c4e60a787c5cfbea5103c75">unorm_normalize</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *source, int32_t sourceLength, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, int32_t options, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *result, int32_t resultLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a string.  <a href="#a5410fab40c4e60a787c5cfbea5103c75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="unorm2_8h.html#a01b7464189aef5dae63c0c759e84bece">UNormalizationCheckResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#ad103c40dd46c7d95f6db4c97aed10277">unorm_quickCheck</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *source, int32_t sourcelength, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performing quick check on a string, to quickly determine if the string is in a particular normalization format.  <a href="#ad103c40dd46c7d95f6db4c97aed10277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="unorm2_8h.html#a01b7464189aef5dae63c0c759e84bece">UNormalizationCheckResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#ae437a1459c7379e327799d5d5ea44458">unorm_quickCheckWithOptions</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *src, int32_t srcLength, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, int32_t options, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performing quick check on a string; same as unorm_quickCheck but takes an extra options parameter like most normalization functions.  <a href="#ae437a1459c7379e327799d5d5ea44458"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#a919fb62224dc5f268e7b1cce21c2e873">unorm_isNormalized</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *src, int32_t srcLength, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a string is in a given normalization form.  <a href="#a919fb62224dc5f268e7b1cce21c2e873"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#a0a0e785c85a02052d405626ce301405e">unorm_isNormalizedWithOptions</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *src, int32_t srcLength, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, int32_t options, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a string is in a given normalization form; same as unorm_isNormalized but takes an extra options parameter like most normalization functions.  <a href="#a0a0e785c85a02052d405626ce301405e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#ab929eae6735fc93dfd799f7b71553614">unorm_next</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *src, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *dest, int32_t destCapacity, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, int32_t options, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> doNormalize, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> *pNeededToNormalize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative normalization forward.  <a href="#ab929eae6735fc93dfd799f7b71553614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#a1b64cb761d9eb7ccfd7ec58a5e045975">unorm_previous</a> (<a class="el" href="structUCharIterator.html">UCharIterator</a> *src, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *dest, int32_t destCapacity, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, int32_t options, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> doNormalize, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> *pNeededToNormalize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative normalization backward.  <a href="#a1b64cb761d9eb7ccfd7ec58a5e045975"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#aa258530f27604d78c887aac13771e4a1">unorm_concatenate</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *left, int32_t leftLength, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *right, int32_t rightLength, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *dest, int32_t destCapacity, <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a> mode, int32_t options, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate normalized strings, making sure that the result is normalized as well.  <a href="#aa258530f27604d78c887aac13771e4a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unorm_8h.html#a991e0fe6f0d062dd6e8e924517f3f437">unorm_compare</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *s1, int32_t length1, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *s2, int32_t length2, uint32_t options, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two strings for canonical equivalence.  <a href="#a991e0fe6f0d062dd6e8e924517f3f437"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>C API: Unicode Normalization. </p>
<h2>Unicode normalization API</h2>
<p>Note: This API has been replaced by the <a class="el" href="unorm2_8h.html" title="C API: New API for Unicode Normalization.">unorm2.h</a> API and is only available for backward compatibility. The functions here simply delegate to the <a class="el" href="unorm2_8h.html" title="C API: New API for Unicode Normalization.">unorm2.h</a> functions, for example <a class="el" href="unorm2_8h.html#aada0d2d95913d0cc3329e9e7fd571630" title="Returns a UNormalizer2 instance which uses the specified data file (packageName/name...">unorm2_getInstance()</a> and <a class="el" href="unorm2_8h.html#a0a596802db767da410b4b04cb75cbc53" title="Writes the normalized form of the source string to the destination string (replacing...">unorm2_normalize()</a>. There is one exception: The new API does not provide a replacement for <a class="el" href="unorm_8h.html#a991e0fe6f0d062dd6e8e924517f3f437" title="Compare two strings for canonical equivalence.">unorm_compare()</a>.</p>
<p><code>unorm_normalize</code> transforms Unicode text into an equivalent composed or decomposed form, allowing for easier sorting and searching of text. <code>unorm_normalize</code> supports the standard normalization forms described in <a href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">Unicode Standard Annex #15: Unicode Normalization Forms</a>.</p>
<p>Characters with accents or other adornments can be encoded in several different ways in Unicode. For example, take the character A-acute. In Unicode, this can be encoded as a single character (the "composed" form):</p>
<div class="fragment"><pre class="fragment">      00C1    LATIN CAPITAL LETTER A WITH ACUTE
</pre></div><p>or as two separate characters (the "decomposed" form):</p>
<div class="fragment"><pre class="fragment">      0041    LATIN CAPITAL LETTER A
      0301    COMBINING ACUTE ACCENT
</pre></div><p>To a user of your program, however, both of these sequences should be treated as the same "user-level" character "A with acute accent". When you are searching or comparing text, you must ensure that these two sequences are treated equivalently. In addition, you must handle characters with more than one accent. Sometimes the order of a character's combining accents is significant, while in other cases accent sequences in different orders are really equivalent.</p>
<p>Similarly, the string "ffi" can be encoded as three separate letters:</p>
<div class="fragment"><pre class="fragment">      0066    LATIN SMALL LETTER F
      0066    LATIN SMALL LETTER F
      0069    LATIN SMALL LETTER I
</pre></div><p>or as the single character</p>
<div class="fragment"><pre class="fragment">      FB03    LATIN SMALL LIGATURE FFI
</pre></div><p>The ffi ligature is not a distinct semantic character, and strictly speaking it shouldn't be in Unicode at all, but it was included for compatibility with existing character sets that already provided it. The Unicode standard identifies such characters by giving them "compatibility" decompositions into the corresponding semantic characters. When sorting and searching, you will often want to use these mappings.</p>
<p><code>unorm_normalize</code> helps solve these problems by transforming text into the canonical composed and decomposed forms as shown in the first example above. In addition, you can have it perform compatibility decompositions so that you can treat compatibility characters the same as their equivalents. Finally, <code>unorm_normalize</code> rearranges accents into the proper canonical order, so that you do not have to worry about accent rearrangement on your own.</p>
<p>Form FCD, "Fast C or D", is also designed for collation. It allows to work on strings that are not necessarily normalized with an algorithm (like in collation) that works under "canonical closure", i.e., it treats precomposed characters and their decomposed equivalents the same.</p>
<p>It is not a normalization form because it does not provide for uniqueness of representation. Multiple strings may be canonically equivalent (their NFDs are identical) and may all conform to FCD without being identical themselves.</p>
<p>The form is defined such that the "raw decomposition", the recursive canonical decomposition of each character, results in a string that is canonically ordered. This means that precomposed characters are allowed for as long as their decompositions do not need canonical reordering.</p>
<p>Its advantage for a process like collation is that all NFD and most NFC texts - and many unnormalized texts - already conform to FCD and do not need to be normalized (NFD) for such a process. The FCD quick check will return UNORM_YES for most strings in practice.</p>
<p>unorm_normalize(UNORM_FCD) may be implemented with UNORM_NFD.</p>
<p>For more details on FCD see the collation design document: <a href="http://source.icu-project.org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm">http://source.icu-project.org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm</a></p>
<p>ICU collation performs either NFD or FCD normalization automatically if normalization is turned on for the collator object. Beyond collation and string search, normalized strings may be useful for string equivalence comparisons, transliteration/transcription, unique representations, etc.</p>
<p>The W3C generally recommends to exchange texts in NFC. Note also that most legacy character encodings use only precomposed forms and often do not encode any combining marks by themselves. For conversion to such character encodings the Unicode text needs to be normalized to NFC. For more usage examples, see the Unicode Standard Annex. </p>

<p>Definition in file <a class="el" href="unorm_8h_source.html">unorm.h</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a6cc4c8b0d5be7ce1ac4b600ace7817f5"></a><!-- doxytag: member="unorm.h::U_COMPARE_IGNORE_CASE" ref="a6cc4c8b0d5be7ce1ac4b600ace7817f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_COMPARE_IGNORE_CASE&nbsp;&nbsp;&nbsp;0x10000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Option bit for unorm_compare: Perform case-insensitive comparison. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001758">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Definition at line <a class="el" href="unorm_8h_source.html#l00475">475</a> of file <a class="el" href="unorm_8h_source.html">unorm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2962ecfc131adbea913c9ac34eaed4b6"></a><!-- doxytag: member="unorm.h::UNORM_COMPARE_NORM_OPTIONS_SHIFT" ref="a2962ecfc131adbea913c9ac34eaed4b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNORM_COMPARE_NORM_OPTIONS_SHIFT&nbsp;&nbsp;&nbsp;20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lowest-order bit number of <a class="el" href="unorm_8h.html#a991e0fe6f0d062dd6e8e924517f3f437" title="Compare two strings for canonical equivalence.">unorm_compare()</a> options bits corresponding to normalization options bits. </p>
<p>The options parameter for <a class="el" href="unorm_8h.html#a991e0fe6f0d062dd6e8e924517f3f437" title="Compare two strings for canonical equivalence.">unorm_compare()</a> uses most bits for itself and for various comparison and folding flags. The most significant bits, however, are shifted down and passed on to the normalization implementation. (That is, from unorm_compare(..., options, ...), options&gt;&gt;UNORM_COMPARE_NORM_OPTIONS_SHIFT will be passed on to the internal normalization functions.)</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#a991e0fe6f0d062dd6e8e924517f3f437" title="Compare two strings for canonical equivalence.">unorm_compare</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001748">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

<p>Definition at line <a class="el" href="unorm_8h_source.html#l00185">185</a> of file <a class="el" href="unorm_8h_source.html">unorm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab2632f6548f0574ded0d37671ead94b6"></a><!-- doxytag: member="unorm.h::UNORM_INPUT_IS_FCD" ref="ab2632f6548f0574ded0d37671ead94b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNORM_INPUT_IS_FCD&nbsp;&nbsp;&nbsp;0x20000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Option bit for unorm_compare: Both input strings are assumed to fulfill FCD conditions. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001757">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Definition at line <a class="el" href="unorm_8h_source.html#l00468">468</a> of file <a class="el" href="unorm_8h_source.html">unorm.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9e"></a><!-- doxytag: member="unorm.h::@13" ref="a05589fbab0657f08285ebdfe93f5ec9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constants for options flags for normalization. </p>
<p>Use 0 for default options, including normalization according to the Unicode version that is currently supported by ICU (see u_getUnicodeVersion). </p>
<dl class="stable"><dt><b>Stable:</b></dt><dd>ICU 2.6 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9ea5b4745b8b611e2d7e6245c023e22e462"></a><!-- doxytag: member="UNORM_UNICODE_3_2" ref="a05589fbab0657f08285ebdfe93f5ec9ea5b4745b8b611e2d7e6245c023e22e462" args="" -->UNORM_UNICODE_3_2</em>&nbsp;</td><td>
<p>Options bit set value to select Unicode 3.2 normalization (except NormalizationCorrections). </p>
<p>At most one Unicode version can be selected at a time. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001768">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="unorm_8h_source.html#l00160">160</a> of file <a class="el" href="unorm_8h_source.html">unorm.h</a>.</p>

</div>
</div>
<a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7"></a><!-- doxytag: member="unorm.h::UNormalizationMode" ref="af317e3ace13f0ce7c86dd1ca48490ef7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constants for normalization modes. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001746">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7a120a05cf3e51beaf4d9fbb6a4a1993c7"></a><!-- doxytag: member="UNORM_NONE" ref="af317e3ace13f0ce7c86dd1ca48490ef7a120a05cf3e51beaf4d9fbb6a4a1993c7" args="" -->UNORM_NONE</em>&nbsp;</td><td>
<p>No decomposition/composition. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001760">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7a60f3fa3dbcdfc2a075143fe078493e3a"></a><!-- doxytag: member="UNORM_NFD" ref="af317e3ace13f0ce7c86dd1ca48490ef7a60f3fa3dbcdfc2a075143fe078493e3a" args="" -->UNORM_NFD</em>&nbsp;</td><td>
<p>Canonical decomposition. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001761">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7a42f246a2e989929b24b2a4c84fe3a51a"></a><!-- doxytag: member="UNORM_NFKD" ref="af317e3ace13f0ce7c86dd1ca48490ef7a42f246a2e989929b24b2a4c84fe3a51a" args="" -->UNORM_NFKD</em>&nbsp;</td><td>
<p>Compatibility decomposition. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001762">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7a5b8bb462684c034d347e8dbcf4b77331"></a><!-- doxytag: member="UNORM_NFC" ref="af317e3ace13f0ce7c86dd1ca48490ef7a5b8bb462684c034d347e8dbcf4b77331" args="" -->UNORM_NFC</em>&nbsp;</td><td>
<p>Canonical decomposition followed by canonical composition. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001763">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7a0f833bde534a6902911c62dbb091a585"></a><!-- doxytag: member="UNORM_DEFAULT" ref="af317e3ace13f0ce7c86dd1ca48490ef7a0f833bde534a6902911c62dbb091a585" args="" -->UNORM_DEFAULT</em>&nbsp;</td><td>
<p>Default normalization. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001764">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7a9f7f2ae3788d9aa8e6dff82697d6d0db"></a><!-- doxytag: member="UNORM_NFKC" ref="af317e3ace13f0ce7c86dd1ca48490ef7a9f7f2ae3788d9aa8e6dff82697d6d0db" args="" -->UNORM_NFKC</em>&nbsp;</td><td>
<p>Compatibility decomposition followed by canonical composition. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001765">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7aac4a0a6b26928af19d2cef5985bdce8d"></a><!-- doxytag: member="UNORM_FCD" ref="af317e3ace13f0ce7c86dd1ca48490ef7aac4a0a6b26928af19d2cef5985bdce8d" args="" -->UNORM_FCD</em>&nbsp;</td><td>
<p>"Fast C or D" form. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001766">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af317e3ace13f0ce7c86dd1ca48490ef7ab16cae528525fca531bcdee42b153796"></a><!-- doxytag: member="UNORM_MODE_COUNT" ref="af317e3ace13f0ce7c86dd1ca48490ef7ab16cae528525fca531bcdee42b153796" args="" -->UNORM_MODE_COUNT</em>&nbsp;</td><td>
<p>One more than the highest normalization mode constant. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001767">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="unorm_8h_source.html#l00133">133</a> of file <a class="el" href="unorm_8h_source.html">unorm.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a991e0fe6f0d062dd6e8e924517f3f437"></a><!-- doxytag: member="unorm.h::unorm_compare" ref="a991e0fe6f0d062dd6e8e924517f3f437" args="(const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, uint32_t options, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t unorm_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two strings for canonical equivalence. </p>
<p>Further options include case-insensitive comparison and code point order (as opposed to code unit order).</p>
<p>Canonical equivalence between two strings is defined as their normalized forms (NFD or NFC) being identical. This function compares strings incrementally instead of normalizing (and optionally case-folding) both strings entirely, improving performance significantly.</p>
<p>Bulk normalization is only necessary if the strings do not fulfill the FCD conditions. Only in this case, and only if the strings are relatively long, is memory allocated temporarily. For FCD strings and short non-FCD strings there is no memory allocation.</p>
<p>Semantically, this is equivalent to strcmp[CodePointOrder](NFD(foldCase(NFD(s1))), NFD(foldCase(NFD(s2)))) where code point order and foldCase are all optional.</p>
<p>UAX 21 2.5 Caseless Matching specifies that for a canonical caseless match the case folding must be performed first, then the normalization.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>First source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length1</em>&nbsp;</td><td>Length of first source string, or -1 if NUL-terminated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>Second source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length2</em>&nbsp;</td><td>Length of second source string, or -1 if NUL-terminated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>A bit set of options:</p>
<ul>
<li>U_FOLD_CASE_DEFAULT or 0 is used for default options: Case-sensitive comparison in code unit order, and the input strings are quick-checked for FCD.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>UNORM_INPUT_IS_FCD Set if the caller knows that both s1 and s2 fulfill the FCD conditions. If not set, the function will quickCheck for FCD and normalize if necessary.</li>
</ul>
<ul>
<li>U_COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order (see u_strCompare for details).</li>
</ul>
<ul>
<li>U_COMPARE_IGNORE_CASE Set to compare strings case-insensitively using case folding, instead of case-sensitively. If set, then the following case folding options are used.</li>
</ul>
<ul>
<li>Options as used with case-insensitive comparisons, currently:</li>
</ul>
<ul>
<li>U_FOLD_CASE_EXCLUDE_SPECIAL_I (see u_strCaseCompare for details)</li>
</ul>
<ul>
<li>regular normalization options shifted left by UNORM_COMPARE_NORM_OPTIONS_SHIFT</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 or 0 or &gt;0 as usual for string comparisons</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#a5410fab40c4e60a787c5cfbea5103c75" title="Normalize a string.">unorm_normalize</a> </dd>
<dd>
<a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7aac4a0a6b26928af19d2cef5985bdce8d" title="&quot;Fast C or D&quot; form.">UNORM_FCD</a> </dd>
<dd>
<a class="el" href="ustring_8h.html#a51fe041d3e4e408595d665c0f5f68715" title="Compare two Unicode strings (binary order).">u_strCompare</a> </dd>
<dd>
<a class="el" href="ustring_8h.html#a56c7ed13d57379ff8b5f0736b0628e09" title="Compare two strings case-insensitively using full case folding.">u_strCaseCompare</a></dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001759">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Referenced by <a class="el" href="normlzr_8h_source.html#l00783">Normalizer::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="aa258530f27604d78c887aac13771e4a1"></a><!-- doxytag: member="unorm.h::unorm_concatenate" ref="aa258530f27604d78c887aac13771e4a1" args="(const UChar *left, int32_t leftLength, const UChar *right, int32_t rightLength, UChar *dest, int32_t destCapacity, UNormalizationMode mode, int32_t options, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t unorm_concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>leftLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>rightLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Concatenate normalized strings, making sure that the result is normalized as well. </p>
<p>If both the left and the right strings are in the normalization form according to "mode/options", then the result will be</p>
<div class="fragment"><pre class="fragment">     dest=normalize(left+right, mode, options)
</pre></div><p>With the input strings already being normalized, this function will use <a class="el" href="unorm_8h.html#ab929eae6735fc93dfd799f7b71553614" title="Iterative normalization forward.">unorm_next()</a> and <a class="el" href="unorm_8h.html#a1b64cb761d9eb7ccfd7ec58a5e045975" title="Iterative normalization backward.">unorm_previous()</a> to find the adjacent end pieces of the input strings. Only the concatenation of these end pieces will be normalized and then concatenated with the remaining parts of the input strings.</p>
<p>It is allowed to have dest==left to avoid copying the entire left string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>Left source string, may be same as dest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>leftLength</em>&nbsp;</td><td>Length of left source string, or -1 if NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right</em>&nbsp;</td><td>Right source string. Must not be the same as dest, nor overlap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rightLength</em>&nbsp;</td><td>Length of right source string, or -1 if NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The output buffer; can be NULL if destCapacity==0 for pure preflighting. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The number of UChars that fit into dest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The normalization mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The normalization options, ORed together (0 for no options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of output (number of UChars) when successful or buffer overflow.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#a5410fab40c4e60a787c5cfbea5103c75" title="Normalize a string.">unorm_normalize</a> </dd>
<dd>
<a class="el" href="unorm_8h.html#ab929eae6735fc93dfd799f7b71553614" title="Iterative normalization forward.">unorm_next</a> </dd>
<dd>
<a class="el" href="unorm_8h.html#a1b64cb761d9eb7ccfd7ec58a5e045975" title="Iterative normalization backward.">unorm_previous</a></dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001756">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a919fb62224dc5f268e7b1cce21c2e873"></a><!-- doxytag: member="unorm.h::unorm_isNormalized" ref="a919fb62224dc5f268e7b1cce21c2e873" args="(const UChar *src, int32_t srcLength, UNormalizationMode mode, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> unorm_isNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a string is in a given normalization form. </p>
<p>This is semantically equivalent to source.equals(normalize(source, mode)) .</p>
<p>Unlike <a class="el" href="unorm_8h.html#ad103c40dd46c7d95f6db4c97aed10277" title="Performing quick check on a string, to quickly determine if the string is in a particular...">unorm_quickCheck()</a>, this function returns a definitive result, never a "maybe". For NFD, NFKD, and FCD, both functions work exactly the same. For NFC and NFKC where quickCheck may return "maybe", this function will perform further tests to arrive at a TRUE/FALSE result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>String that is to be tested if it is in a normalization format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>Length of source to test, or -1 if NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Which normalization form to test for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean value indicating whether the source string is in the "mode" normalization form.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#ad103c40dd46c7d95f6db4c97aed10277" title="Performing quick check on a string, to quickly determine if the string is in a particular...">unorm_quickCheck</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001752">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a0a0e785c85a02052d405626ce301405e"></a><!-- doxytag: member="unorm.h::unorm_isNormalizedWithOptions" ref="a0a0e785c85a02052d405626ce301405e" args="(const UChar *src, int32_t srcLength, UNormalizationMode mode, int32_t options, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> unorm_isNormalizedWithOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a string is in a given normalization form; same as unorm_isNormalized but takes an extra options parameter like most normalization functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>String that is to be tested if it is in a normalization format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>Length of source to test, or -1 if NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Which normalization form to test for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The normalization options, ORed together (0 for no options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean value indicating whether the source string is in the "mode/options" normalization form.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#ad103c40dd46c7d95f6db4c97aed10277" title="Performing quick check on a string, to quickly determine if the string is in a particular...">unorm_quickCheck</a> </dd>
<dd>
<a class="el" href="unorm_8h.html#a919fb62224dc5f268e7b1cce21c2e873" title="Test if a string is in a given normalization form.">unorm_isNormalized</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001753">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ab929eae6735fc93dfd799f7b71553614"></a><!-- doxytag: member="unorm.h::unorm_next" ref="ab929eae6735fc93dfd799f7b71553614" args="(UCharIterator *src, UChar *dest, int32_t destCapacity, UNormalizationMode mode, int32_t options, UBool doNormalize, UBool *pNeededToNormalize, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t unorm_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>doNormalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> *&nbsp;</td>
          <td class="paramname"> <em>pNeededToNormalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterative normalization forward. </p>
<p>This function (together with unorm_previous) is somewhat similar to the C++ <a class="el" href="classNormalizer.html" title="The Normalizer class supports the standard normalization forms described in Unicode...">Normalizer</a> class (see its non-static functions).</p>
<p>Iterative normalization is useful when only a small portion of a longer string/text needs to be processed.</p>
<p>For example, the likelihood may be high that processing the first 10% of some text will be sufficient to find certain data. Another example: When one wants to concatenate two normalized strings and get a normalized result, it is much more efficient to normalize just a small part of the result around the concatenation place instead of re-normalizing everything.</p>
<p>The input text is an instance of the C character iteration API <a class="el" href="structUCharIterator.html" title="C API for code unit iteration.">UCharIterator</a>. It may wrap around a simple string, a <a class="el" href="classCharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a>, a <a class="el" href="classReplaceable.html" title="Replaceable is an abstract base class representing a string of characters that supports...">Replaceable</a>, or any other kind of text object.</p>
<p>If a buffer overflow occurs, then the caller needs to reset the iterator to the old index and call the function again with a larger buffer - if the caller cares for the actual output. Regardless of the output buffer, the iterator will always be moved to the next normalization boundary.</p>
<p>This function (like unorm_previous) serves two purposes:</p>
<p>1) To find the next boundary so that the normalization of the part of the text from the current position to that boundary does not affect and is not affected by the part of the text beyond that boundary.</p>
<p>2) To normalize the text up to the boundary.</p>
<p>The second step is optional, per the doNormalize parameter. It is omitted for operations like string concatenation, where the two adjacent string ends need to be normalized together. In such a case, the output buffer will just contain a copy of the text up to the boundary.</p>
<p>pNeededToNormalize is an output-only parameter. Its output value is only defined if normalization was requested (doNormalize) and successful (especially, no buffer overflow). It is useful for operations like a normalizing transliterator, where one would not want to replace a piece of text if it is not modified.</p>
<p>If doNormalize==TRUE and pNeededToNormalize!=NULL then *pNeeded... is set TRUE if the normalization was necessary.</p>
<p>If doNormalize==FALSE then *pNeededToNormalize will be set to FALSE.</p>
<p>If the buffer overflows, then *pNeededToNormalize will be undefined; essentially, whenever U_FAILURE is true (like in buffer overflows), this result will be undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The input text in the form of a C character iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The output buffer; can be NULL if destCapacity==0 for pure preflighting. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The number of UChars that fit into dest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The normalization mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The normalization options, ORed together (0 for no options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doNormalize</em>&nbsp;</td><td>Indicates if the source text up to the next boundary is to be normalized (TRUE) or just copied (FALSE). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNeededToNormalize</em>&nbsp;</td><td>Output flag indicating if the normalization resulted in different text from the input. Not defined if an error occurs including buffer overflow. Always FALSE if !doNormalize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of output (number of UChars) when successful or buffer overflow.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#a1b64cb761d9eb7ccfd7ec58a5e045975" title="Iterative normalization backward.">unorm_previous</a> </dd>
<dd>
<a class="el" href="unorm_8h.html#a5410fab40c4e60a787c5cfbea5103c75" title="Normalize a string.">unorm_normalize</a></dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001754">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a5410fab40c4e60a787c5cfbea5103c75"></a><!-- doxytag: member="unorm.h::unorm_normalize" ref="a5410fab40c4e60a787c5cfbea5103c75" args="(const UChar *source, int32_t sourceLength, UNormalizationMode mode, int32_t options, UChar *result, int32_t resultLength, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t unorm_normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>resultLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize a string. </p>
<p>The string will be normalized according the specified normalization mode and options. The source and result buffers must not be the same, nor overlap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The string to normalize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLength</em>&nbsp;</td><td>The length of source, or -1 if NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The normalization mode; one of UNORM_NONE, UNORM_NFD, UNORM_NFC, UNORM_NFKC, UNORM_NFKD, UNORM_DEFAULT. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The normalization options, ORed together (0 for no options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>A pointer to a buffer to receive the result string. The result string is NUL-terminated if possible. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resultLength</em>&nbsp;</td><td>The maximum size of result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>A pointer to a UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total buffer size needed; if greater than resultLength, the output was truncated, and the error code is set to U_BUFFER_OVERFLOW_ERROR. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001749">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1b64cb761d9eb7ccfd7ec58a5e045975"></a><!-- doxytag: member="unorm.h::unorm_previous" ref="a1b64cb761d9eb7ccfd7ec58a5e045975" args="(UCharIterator *src, UChar *dest, int32_t destCapacity, UNormalizationMode mode, int32_t options, UBool doNormalize, UBool *pNeededToNormalize, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t unorm_previous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUCharIterator.html">UCharIterator</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&nbsp;</td>
          <td class="paramname"> <em>doNormalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> *&nbsp;</td>
          <td class="paramname"> <em>pNeededToNormalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterative normalization backward. </p>
<p>This function (together with unorm_next) is somewhat similar to the C++ <a class="el" href="classNormalizer.html" title="The Normalizer class supports the standard normalization forms described in Unicode...">Normalizer</a> class (see its non-static functions). For all details see unorm_next.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The input text in the form of a C character iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The output buffer; can be NULL if destCapacity==0 for pure preflighting. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCapacity</em>&nbsp;</td><td>The number of UChars that fit into dest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The normalization mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The normalization options, ORed together (0 for no options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doNormalize</em>&nbsp;</td><td>Indicates if the source text up to the next boundary is to be normalized (TRUE) or just copied (FALSE). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNeededToNormalize</em>&nbsp;</td><td>Output flag indicating if the normalization resulted in different text from the input. Not defined if an error occurs including buffer overflow. Always FALSE if !doNormalize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of output (number of UChars) when successful or buffer overflow.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#ab929eae6735fc93dfd799f7b71553614" title="Iterative normalization forward.">unorm_next</a> </dd>
<dd>
<a class="el" href="unorm_8h.html#a5410fab40c4e60a787c5cfbea5103c75" title="Normalize a string.">unorm_normalize</a></dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001755">Stable:</a></b></dt><dd>ICU 2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ad103c40dd46c7d95f6db4c97aed10277"></a><!-- doxytag: member="unorm.h::unorm_quickCheck" ref="ad103c40dd46c7d95f6db4c97aed10277" args="(const UChar *source, int32_t sourcelength, UNormalizationMode mode, UErrorCode *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unorm2_8h.html#a01b7464189aef5dae63c0c759e84bece">UNormalizationCheckResult</a> unorm_quickCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sourcelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performing quick check on a string, to quickly determine if the string is in a particular normalization format. </p>
<p>Three types of result can be returned UNORM_YES, UNORM_NO or UNORM_MAYBE. Result UNORM_YES indicates that the argument string is in the desired normalized format, UNORM_NO determines that argument string is not in the desired normalized format. A UNORM_MAYBE result indicates that a more thorough check is required, the user may have to put the string in its normalized form and compare the results.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>string for determining if it is in a normalized format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourcelength</em>&nbsp;</td><td>length of source to test, or -1 if NUL-terminated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>which normalization form to test for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a pointer to a UErrorCode to receive any errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UNORM_YES, UNORM_NO or UNORM_MAYBE</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#a919fb62224dc5f268e7b1cce21c2e873" title="Test if a string is in a given normalization form.">unorm_isNormalized</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001750">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae437a1459c7379e327799d5d5ea44458"></a><!-- doxytag: member="unorm.h::unorm_quickCheckWithOptions" ref="ae437a1459c7379e327799d5d5ea44458" args="(const UChar *src, int32_t srcLength, UNormalizationMode mode, int32_t options, UErrorCode *pErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unorm2_8h.html#a01b7464189aef5dae63c0c759e84bece">UNormalizationCheckResult</a> unorm_quickCheckWithOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unorm_8h.html#af317e3ace13f0ce7c86dd1ca48490ef7">UNormalizationMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performing quick check on a string; same as unorm_quickCheck but takes an extra options parameter like most normalization functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>String that is to be tested if it is in a normalization format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcLength</em>&nbsp;</td><td>Length of source to test, or -1 if NUL-terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Which normalization form to test for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The normalization options, ORed together (0 for no options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrorCode</em>&nbsp;</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UNORM_YES, UNORM_NO or UNORM_MAYBE</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="unorm_8h.html#ad103c40dd46c7d95f6db4c97aed10277" title="Performing quick check on a string, to quickly determine if the string is in a particular...">unorm_quickCheck</a> </dd>
<dd>
<a class="el" href="unorm_8h.html#a919fb62224dc5f268e7b1cce21c2e873" title="Test if a string is in a given normalization form.">unorm_isNormalized</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable001751">Stable:</a></b></dt><dd>ICU 2.6 </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Jul 26 12:56:52 2011 for ICU 4.8.1 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
