<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>FLTK 1.3.2: Fl_Preferences Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLTK 1.3.2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classFl__Preferences.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFl__Preferences-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Fl_Preferences Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> provides methods to store user settings between application starts.  
 <a href="classFl__Preferences.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Fl__Preferences_8H_source.html">Fl_Preferences.H</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Fl_Preferences:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFl__Preferences.png" usemap="#Fl_Preferences_map" alt=""/>
  <map id="Fl_Preferences_map" name="Fl_Preferences_map">
<area href="classFl__Plugin__Manager.html" title="Fl_Plugin_Manager manages link-time and run-time plugin binaries." alt="Fl_Plugin_Manager" shape="rect" coords="0,56,123,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFl__Preferences_1_1Entry.html">Entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences_1_1Name.html">Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">'<a class="el" href="classFl__Preferences_1_1Name.html" title="&#39;Name&#39; provides a simple method to create numerical or more complex procedural names for entries and ...">Name</a>' provides a simple method to create numerical or more complex procedural names for entries and groups on the fly.  <a href="classFl__Preferences_1_1Name.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7050f8b1c0cbb70693e61bcfbf4f5853"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a></td></tr>
<tr class="memdesc:a7050f8b1c0cbb70693e61bcfbf4f5853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every Fl_Preferences-Group has a uniqe ID.  <a href="#a7050f8b1c0cbb70693e61bcfbf4f5853">More...</a><br/></td></tr>
<tr class="separator:a7050f8b1c0cbb70693e61bcfbf4f5853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0947b73d778ca66b9fbb97b75bbbd7cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Root</a> { <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cba057fd9ac75376136f30efb0d700e8db4">SYSTEM</a> =0, 
<a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053">USER</a>
 }</td></tr>
<tr class="memdesc:a0947b73d778ca66b9fbb97b75bbbd7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the scope of the preferences.  <a href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">More...</a><br/></td></tr>
<tr class="separator:a0947b73d778ca66b9fbb97b75bbbd7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae0fc8533d4cfb2d8c7e67b71b7080129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0fc8533d4cfb2d8c7e67b71b7080129"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae0fc8533d4cfb2d8c7e67b71b7080129">clear</a> ()</td></tr>
<tr class="memdesc:ae0fc8533d4cfb2d8c7e67b71b7080129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all groups and all entries. <br/></td></tr>
<tr class="separator:ae0fc8533d4cfb2d8c7e67b71b7080129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73078b80334cc3f43542f4862de402b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af73078b80334cc3f43542f4862de402b"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#af73078b80334cc3f43542f4862de402b">deleteAllEntries</a> ()</td></tr>
<tr class="memdesc:af73078b80334cc3f43542f4862de402b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all entries. <br/></td></tr>
<tr class="separator:af73078b80334cc3f43542f4862de402b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7563cd64c29348cd5c4d4c14e97614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d7563cd64c29348cd5c4d4c14e97614"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a9d7563cd64c29348cd5c4d4c14e97614">deleteAllGroups</a> ()</td></tr>
<tr class="memdesc:a9d7563cd64c29348cd5c4d4c14e97614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all groups. <br/></td></tr>
<tr class="separator:a9d7563cd64c29348cd5c4d4c14e97614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1710633307e8e79ba8fd89a803042e"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a3a1710633307e8e79ba8fd89a803042e">deleteEntry</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>)</td></tr>
<tr class="memdesc:a3a1710633307e8e79ba8fd89a803042e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a single name/value pair.  <a href="#a3a1710633307e8e79ba8fd89a803042e">More...</a><br/></td></tr>
<tr class="separator:a3a1710633307e8e79ba8fd89a803042e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602c3104b2c5259160cb7e0fe5dd335"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a6602c3104b2c5259160cb7e0fe5dd335">deleteGroup</a> (const char *<a class="el" href="classFl__Preferences.html#a8aeb2bab88aea893c700533c5dea3d41">group</a>)</td></tr>
<tr class="memdesc:a6602c3104b2c5259160cb7e0fe5dd335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a group.  <a href="#a6602c3104b2c5259160cb7e0fe5dd335">More...</a><br/></td></tr>
<tr class="separator:a6602c3104b2c5259160cb7e0fe5dd335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9004c55f8c0c9515943b96853ea17940"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a9004c55f8c0c9515943b96853ea17940">entries</a> ()</td></tr>
<tr class="memdesc:a9004c55f8c0c9515943b96853ea17940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries (name/value pairs) in a group.  <a href="#a9004c55f8c0c9515943b96853ea17940">More...</a><br/></td></tr>
<tr class="separator:a9004c55f8c0c9515943b96853ea17940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bd91e8c3ee2a3f8bccd00ee2a65b8d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a> (int index)</td></tr>
<tr class="memdesc:a61bd91e8c3ee2a3f8bccd00ee2a65b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an entry.  <a href="#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">More...</a><br/></td></tr>
<tr class="separator:a61bd91e8c3ee2a3f8bccd00ee2a65b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c3d7cbf364d5d1ed350ef33850f702"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a05c3d7cbf364d5d1ed350ef33850f702">entryExists</a> (const char *key)</td></tr>
<tr class="memdesc:a05c3d7cbf364d5d1ed350ef33850f702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if an entry with this name exists.  <a href="#a05c3d7cbf364d5d1ed350ef33850f702">More...</a><br/></td></tr>
<tr class="separator:a05c3d7cbf364d5d1ed350ef33850f702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8418ff8af933d22dbb70a082525a74e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#af8418ff8af933d22dbb70a082525a74e">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Root</a> root, const char *vendor, const char *application)</td></tr>
<tr class="memdesc:af8418ff8af933d22dbb70a082525a74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor creates a group that manages name/value pairs and child groups.  <a href="#af8418ff8af933d22dbb70a082525a74e">More...</a><br/></td></tr>
<tr class="separator:af8418ff8af933d22dbb70a082525a74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2ec1496b7eb3cc5b2b9e8f6584c979"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a7e2ec1496b7eb3cc5b2b9e8f6584c979">Fl_Preferences</a> (const char *<a class="el" href="classFl__Preferences.html#aaf2e1a8f1904abb41f3cfa195ae9df41">path</a>, const char *vendor, const char *application)</td></tr>
<tr class="memdesc:a7e2ec1496b7eb3cc5b2b9e8f6584c979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this constructor to create or read a preferences file at an arbitrary position in the file system.  <a href="#a7e2ec1496b7eb3cc5b2b9e8f6584c979">More...</a><br/></td></tr>
<tr class="separator:a7e2ec1496b7eb3cc5b2b9e8f6584c979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b60d610214f1ff60e9603babdea664"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a44b60d610214f1ff60e9603babdea664">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;parent, const char *<a class="el" href="classFl__Preferences.html#a8aeb2bab88aea893c700533c5dea3d41">group</a>)</td></tr>
<tr class="memdesc:a44b60d610214f1ff60e9603babdea664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate or read a new group of entries within another group.  <a href="#a44b60d610214f1ff60e9603babdea664">More...</a><br/></td></tr>
<tr class="separator:a44b60d610214f1ff60e9603babdea664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402ba68241bfefeabcd3665613d81607"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a402ba68241bfefeabcd3665613d81607">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *parent, const char *<a class="el" href="classFl__Preferences.html#a8aeb2bab88aea893c700533c5dea3d41">group</a>)</td></tr>
<tr class="memdesc:a402ba68241bfefeabcd3665613d81607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or access a group of preferences using a name.  <a href="#a402ba68241bfefeabcd3665613d81607">More...</a><br/></td></tr>
<tr class="separator:a402ba68241bfefeabcd3665613d81607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87308454632a4c0a9feb040f42a1a39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ac87308454632a4c0a9feb040f42a1a39">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;parent, int groupIndex)</td></tr>
<tr class="memdesc:ac87308454632a4c0a9feb040f42a1a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a child group using a given index.  <a href="#ac87308454632a4c0a9feb040f42a1a39">More...</a><br/></td></tr>
<tr class="separator:ac87308454632a4c0a9feb040f42a1a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b8a66cd9fda6f727e391847653c4df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a20b8a66cd9fda6f727e391847653c4df">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *parent, int groupIndex)</td></tr>
<tr class="separator:a20b8a66cd9fda6f727e391847653c4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a5569fb0b4f270ff8b343f34d11eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49a5569fb0b4f270ff8b343f34d11eac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a49a5569fb0b4f270ff8b343f34d11eac">Fl_Preferences</a> (const <a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;)</td></tr>
<tr class="memdesc:a49a5569fb0b4f270ff8b343f34d11eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create another reference to a Preferences group. <br/></td></tr>
<tr class="separator:a49a5569fb0b4f270ff8b343f34d11eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2811816dd028d35d8b6b1cafd4f2e44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae2811816dd028d35d8b6b1cafd4f2e44">Fl_Preferences</a> (<a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a> <a class="el" href="classFl__Preferences.html#a1170302365aa48fbd04335ca52c20319">id</a>)</td></tr>
<tr class="memdesc:ae2811816dd028d35d8b6b1cafd4f2e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dataset access point using a dataset ID.  <a href="#ae2811816dd028d35d8b6b1cafd4f2e44">More...</a><br/></td></tr>
<tr class="separator:ae2811816dd028d35d8b6b1cafd4f2e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d49e9959bc26fdc20641534497f3792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a4d49e9959bc26fdc20641534497f3792">flush</a> ()</td></tr>
<tr class="memdesc:a4d49e9959bc26fdc20641534497f3792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all preferences to disk.  <a href="#a4d49e9959bc26fdc20641534497f3792">More...</a><br/></td></tr>
<tr class="separator:a4d49e9959bc26fdc20641534497f3792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0991a0bea2800ce5cd362ff6a778c0d3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0991a0bea2800ce5cd362ff6a778c0d3">get</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, int &amp;value, int defaultValue)</td></tr>
<tr class="memdesc:a0991a0bea2800ce5cd362ff6a778c0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a0991a0bea2800ce5cd362ff6a778c0d3">More...</a><br/></td></tr>
<tr class="separator:a0991a0bea2800ce5cd362ff6a778c0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128339abc1a1ff6bca073de3a62b2cb3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a128339abc1a1ff6bca073de3a62b2cb3">get</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, float &amp;value, float defaultValue)</td></tr>
<tr class="memdesc:a128339abc1a1ff6bca073de3a62b2cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a128339abc1a1ff6bca073de3a62b2cb3">More...</a><br/></td></tr>
<tr class="separator:a128339abc1a1ff6bca073de3a62b2cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d71373c6af5199bc1bb1fb955cb3a64"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0d71373c6af5199bc1bb1fb955cb3a64">get</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, double &amp;value, double defaultValue)</td></tr>
<tr class="memdesc:a0d71373c6af5199bc1bb1fb955cb3a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a0d71373c6af5199bc1bb1fb955cb3a64">More...</a><br/></td></tr>
<tr class="separator:a0d71373c6af5199bc1bb1fb955cb3a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e9d1ae031b06f501779c8937533740"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a30e9d1ae031b06f501779c8937533740">get</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, char *&amp;value, const char *defaultValue)</td></tr>
<tr class="memdesc:a30e9d1ae031b06f501779c8937533740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a30e9d1ae031b06f501779c8937533740">More...</a><br/></td></tr>
<tr class="separator:a30e9d1ae031b06f501779c8937533740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1074a165aa35687955568c7a13ba1462"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1074a165aa35687955568c7a13ba1462">get</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, char *value, const char *defaultValue, int maxSize)</td></tr>
<tr class="memdesc:a1074a165aa35687955568c7a13ba1462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a1074a165aa35687955568c7a13ba1462">More...</a><br/></td></tr>
<tr class="separator:a1074a165aa35687955568c7a13ba1462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0188c9976139103b5c49761c8b765a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a4b0188c9976139103b5c49761c8b765a">get</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, void *&amp;value, const void *defaultValue, int defaultSize)</td></tr>
<tr class="memdesc:a4b0188c9976139103b5c49761c8b765a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#a4b0188c9976139103b5c49761c8b765a">More...</a><br/></td></tr>
<tr class="separator:a4b0188c9976139103b5c49761c8b765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae909187975eefda3c8bbef494296bc9f"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae909187975eefda3c8bbef494296bc9f">get</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, void *value, const void *defaultValue, int defaultSize, int maxSize)</td></tr>
<tr class="memdesc:ae909187975eefda3c8bbef494296bc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an entry from the group.  <a href="#ae909187975eefda3c8bbef494296bc9f">More...</a><br/></td></tr>
<tr class="separator:ae909187975eefda3c8bbef494296bc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3c545a4006ef50b091ed45b6f7ce2a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#acf3c545a4006ef50b091ed45b6f7ce2a">getUserdataPath</a> (char *<a class="el" href="classFl__Preferences.html#aaf2e1a8f1904abb41f3cfa195ae9df41">path</a>, int pathlen)</td></tr>
<tr class="memdesc:acf3c545a4006ef50b091ed45b6f7ce2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path that is related to the preferences file and that is usable for additional application data.  <a href="#acf3c545a4006ef50b091ed45b6f7ce2a">More...</a><br/></td></tr>
<tr class="separator:acf3c545a4006ef50b091ed45b6f7ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aeb2bab88aea893c700533c5dea3d41"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a8aeb2bab88aea893c700533c5dea3d41">group</a> (int num_group)</td></tr>
<tr class="memdesc:a8aeb2bab88aea893c700533c5dea3d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the Nth (<code>num_group</code>) group.  <a href="#a8aeb2bab88aea893c700533c5dea3d41">More...</a><br/></td></tr>
<tr class="separator:a8aeb2bab88aea893c700533c5dea3d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4009efec7d5505a8060ca7a95c1bee2e"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a4009efec7d5505a8060ca7a95c1bee2e">groupExists</a> (const char *key)</td></tr>
<tr class="memdesc:a4009efec7d5505a8060ca7a95c1bee2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if a group with this name exists.  <a href="#a4009efec7d5505a8060ca7a95c1bee2e">More...</a><br/></td></tr>
<tr class="separator:a4009efec7d5505a8060ca7a95c1bee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cfbe5245270b772806e085603a7ab8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a70cfbe5245270b772806e085603a7ab8">groups</a> ()</td></tr>
<tr class="memdesc:a70cfbe5245270b772806e085603a7ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of groups that are contained within a group.  <a href="#a70cfbe5245270b772806e085603a7ab8">More...</a><br/></td></tr>
<tr class="separator:a70cfbe5245270b772806e085603a7ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1170302365aa48fbd04335ca52c20319"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1170302365aa48fbd04335ca52c20319"></a>
<a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1170302365aa48fbd04335ca52c20319">id</a> ()</td></tr>
<tr class="memdesc:a1170302365aa48fbd04335ca52c20319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an ID that can later be reused to open more references to this dataset. <br/></td></tr>
<tr class="separator:a1170302365aa48fbd04335ca52c20319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff11b679bec179ebb211c31f8e46f2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff11b679bec179ebb211c31f8e46f2e"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a6ff11b679bec179ebb211c31f8e46f2e">name</a> ()</td></tr>
<tr class="memdesc:a6ff11b679bec179ebb211c31f8e46f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this entry. <br/></td></tr>
<tr class="separator:a6ff11b679bec179ebb211c31f8e46f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2e1a8f1904abb41f3cfa195ae9df41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf2e1a8f1904abb41f3cfa195ae9df41"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#aaf2e1a8f1904abb41f3cfa195ae9df41">path</a> ()</td></tr>
<tr class="memdesc:aaf2e1a8f1904abb41f3cfa195ae9df41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full path to this entry. <br/></td></tr>
<tr class="separator:aaf2e1a8f1904abb41f3cfa195ae9df41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1928e8ca3f21f66304951b757f24d70a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1928e8ca3f21f66304951b757f24d70a">set</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, int value)</td></tr>
<tr class="memdesc:a1928e8ca3f21f66304951b757f24d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a1928e8ca3f21f66304951b757f24d70a">More...</a><br/></td></tr>
<tr class="separator:a1928e8ca3f21f66304951b757f24d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06e7b756a9c87acc508b835286d569"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a3d06e7b756a9c87acc508b835286d569">set</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, float value)</td></tr>
<tr class="memdesc:a3d06e7b756a9c87acc508b835286d569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a3d06e7b756a9c87acc508b835286d569">More...</a><br/></td></tr>
<tr class="separator:a3d06e7b756a9c87acc508b835286d569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd606d0dd993488d149204ee0841925"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a8bd606d0dd993488d149204ee0841925">set</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, float value, int precision)</td></tr>
<tr class="memdesc:a8bd606d0dd993488d149204ee0841925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a8bd606d0dd993488d149204ee0841925">More...</a><br/></td></tr>
<tr class="separator:a8bd606d0dd993488d149204ee0841925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929db63f2f0d24d11c64ee929688b39e"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a929db63f2f0d24d11c64ee929688b39e">set</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, double value)</td></tr>
<tr class="memdesc:a929db63f2f0d24d11c64ee929688b39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a929db63f2f0d24d11c64ee929688b39e">More...</a><br/></td></tr>
<tr class="separator:a929db63f2f0d24d11c64ee929688b39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2d3935a8ba462d27d0e3c2c9e33841"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0b2d3935a8ba462d27d0e3c2c9e33841">set</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, double value, int precision)</td></tr>
<tr class="memdesc:a0b2d3935a8ba462d27d0e3c2c9e33841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a0b2d3935a8ba462d27d0e3c2c9e33841">More...</a><br/></td></tr>
<tr class="separator:a0b2d3935a8ba462d27d0e3c2c9e33841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbc84064bf5f2675b10724567505fd5"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a1bbc84064bf5f2675b10724567505fd5">set</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, const char *value)</td></tr>
<tr class="memdesc:a1bbc84064bf5f2675b10724567505fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#a1bbc84064bf5f2675b10724567505fd5">More...</a><br/></td></tr>
<tr class="separator:a1bbc84064bf5f2675b10724567505fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc689e9cdf957f7636992d275498d72b"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#acc689e9cdf957f7636992d275498d72b">set</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>, const void *value, int <a class="el" href="classFl__Preferences.html#aca6793ffe782ad4a55c604caed794ea9">size</a>)</td></tr>
<tr class="memdesc:acc689e9cdf957f7636992d275498d72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry (name/value pair).  <a href="#acc689e9cdf957f7636992d275498d72b">More...</a><br/></td></tr>
<tr class="separator:acc689e9cdf957f7636992d275498d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6793ffe782ad4a55c604caed794ea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#aca6793ffe782ad4a55c604caed794ea9">size</a> (const char *<a class="el" href="classFl__Preferences.html#a61bd91e8c3ee2a3f8bccd00ee2a65b8d">entry</a>)</td></tr>
<tr class="memdesc:aca6793ffe782ad4a55c604caed794ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the value part of an entry.  <a href="#aca6793ffe782ad4a55c604caed794ea9">More...</a><br/></td></tr>
<tr class="separator:aca6793ffe782ad4a55c604caed794ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb024a8350c344303755fedb1582185"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a0eb024a8350c344303755fedb1582185">~Fl_Preferences</a> ()</td></tr>
<tr class="memdesc:a0eb024a8350c344303755fedb1582185"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor removes allocated resources.  <a href="#a0eb024a8350c344303755fedb1582185">More...</a><br/></td></tr>
<tr class="separator:a0eb024a8350c344303755fedb1582185"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae357c2136fce436e367b92c0337a4778"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#ae357c2136fce436e367b92c0337a4778">newUUID</a> ()</td></tr>
<tr class="memdesc:ae357c2136fce436e367b92c0337a4778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UUID as generated by the system.  <a href="#ae357c2136fce436e367b92c0337a4778">More...</a><br/></td></tr>
<tr class="separator:ae357c2136fce436e367b92c0337a4778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9960e5ac57a9a9af4cb3bfe422320f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b9960e5ac57a9a9af4cb3bfe422320f"></a>
static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl__Preferences.html#a7b9960e5ac57a9a9af4cb3bfe422320f">remove</a> (<a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">ID</a> id_)</td></tr>
<tr class="memdesc:a7b9960e5ac57a9a9af4cb3bfe422320f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the group with this ID from a database. <br/></td></tr>
<tr class="separator:a7b9960e5ac57a9a9af4cb3bfe422320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae5633500be10cea17e2ffb2791f05b6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5633500be10cea17e2ffb2791f05b6c"></a>
Node *&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr class="separator:ae5633500be10cea17e2ffb2791f05b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d05b8bf3baf9255771e7c57aa8620cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d05b8bf3baf9255771e7c57aa8620cc"></a>
RootNode *&#160;</td><td class="memItemRight" valign="bottom"><b>rootNode</b></td></tr>
<tr class="separator:a1d05b8bf3baf9255771e7c57aa8620cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6db9d28bd448a131448276ee03de1e6d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb397989a4485545d4d65709ce3c863"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bb397989a4485545d4d65709ce3c863"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RootNode</b></td></tr>
<tr class="separator:a3bb397989a4485545d4d65709ce3c863"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> provides methods to store user settings between application starts. </p>
<p>It is similar to the Registry on WIN32 and Preferences on MacOS, and provides a simple configuration mechanism for UNIX.</p>
<p><a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> uses a hierarchy to store data. It bundles similar data into groups and manages entries into those groups as name/value pairs.</p>
<p>Preferences are stored in text files that can be edited manually. The file format is easy to read and relatively forgiving. Preferences files are the same on all platforms. User comments in preference files are preserved. Filenames are unique for each application by using a vendor/application naming scheme. The user must provide default values for all entries to ensure proper operation should preferences be corrupted or not yet exist.</p>
<p>Entries can be of any length. However, the size of each preferences file should be kept small for performance reasons. One application can have multiple preferences files. Extensive binary data however should be stored in separate files: see <a class="el" href="classFl__Preferences.html#acf3c545a4006ef50b091ed45b6f7ce2a" title="Creates a path that is related to the preferences file and that is usable for additional application ...">getUserdataPath()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Starting with FLTK 1.3, preference databases are expected to be in UTF-8 encoding. Previous databases were stored in the current character set or code page which renders them incompatible for text entries using international characters. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a7050f8b1c0cbb70693e61bcfbf4f5853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">Fl_Preferences::ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Every Fl_Preferences-Group has a uniqe ID. </p>
<p>ID's can be retrieved from an Fl_Preferences-Group and can then be used to create more Fl_Preference references to the same data set, as long as the database remains open. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a0947b73d778ca66b9fbb97b75bbbd7cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Fl_Preferences::Root</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the scope of the preferences. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a0947b73d778ca66b9fbb97b75bbbd7cba057fd9ac75376136f30efb0d700e8db4"></a>SYSTEM</em>&nbsp;</td><td class="fielddoc">
<p>Preferences are used system-wide. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053"></a>USER</em>&nbsp;</td><td class="fielddoc">
<p>Preferences apply only to the current user. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af8418ff8af933d22dbb70a082525a74e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cb">Root</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>application</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor creates a group that manages name/value pairs and child groups. </p>
<p>Groups are ready for reading and writing at any time. The root argument is either <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053" title="Preferences apply only to the current user.">Fl_Preferences::USER</a> or <a class="el" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cba057fd9ac75376136f30efb0d700e8db4" title="Preferences are used system-wide.">Fl_Preferences::SYSTEM</a>.</p>
<p>This constructor creates the <em>base</em> instance for all following entries and reads existing databases into memory. The vendor argument is a unique text string identifying the development team or vendor of an application. A domain name or an EMail address are great unique names, e.g. "researchATmatthiasm.com" or "fltk.org". The application argument can be the working title or final name of your application. Both vendor and application must be valid relative UNIX pathnames and may contain '/'s to create deeper file structures.</p>
<p>A set of Preferences marked "run-time" exists exactly one per application and only as long as the application runs. It can be used as a database for volatile information. FLTK uses it to register plugins at run-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>can be <code>USER</code> or <code>SYSTEM</code> for user specific or system wide preferences </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vendor</td><td>unique text describing the company or author of this file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td>unique text describing the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e2ec1496b7eb3cc5b2b9e8f6584c979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>application</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this constructor to create or read a preferences file at an arbitrary position in the file system. </p>
<p>The file name is generated in the form <code><em>path</em>/<em>application</em>.prefs</code>. If <code>application</code> is <code>NULL</code>, <code>path</code> must contain the full file name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path to the directory that contains the preferences file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vendor</td><td>unique text describing the company or author of this file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td>unique text describing the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44b60d610214f1ff60e9603babdea664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate or read a new group of entries within another group. </p>
<p>Use the <code>group</code> argument to name the group that you would like to access. <code>Group</code> can also contain a path to a group further down the hierarchy by separating group names with a forward slash '/'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>reference object for the new group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>name of the group to access (may contain '/'s) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a402ba68241bfefeabcd3665613d81607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create or access a group of preferences using a name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>the parameter parent is a pointer to the parent group. <code>Parent</code> may be <code>NULL</code>. It then refers to an application internal database which exists only once, and remains in RAM only until the application quits. This database is used to manage plugins and other data indexes by strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>a group name that is used as a key into the database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFl__Preferences.html#a44b60d610214f1ff60e9603babdea664" title="Generate or read a new group of entries within another group.">Fl_Preferences( Fl_Preferences&amp;, const char *group )</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac87308454632a4c0a9feb040f42a1a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a child group using a given index. </p>
<p>Use the <code>groupIndex</code> argument to find the group that you would like to access. If the given index is invalid (negative or too high), a new group is created with a UUID as a name.</p>
<p>The index needs to be fixed. It is currently backward. Index 0 points to the last member in the 'list' of preferences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>reference object for the new group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">groupIndex</td><td>zero based index into child groups </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20b8a66cd9fda6f727e391847653c4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html">Fl_Preferences</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classFl__Preferences.html#ac87308454632a4c0a9feb040f42a1a39" title="Open a child group using a given index.">Fl_Preferences( Fl_Preferences&amp;, int groupIndex )</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2811816dd028d35d8b6b1cafd4f2e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::Fl_Preferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl__Preferences.html#a7050f8b1c0cbb70693e61bcfbf4f5853">Fl_Preferences::ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new dataset access point using a dataset ID. </p>
<p>ID's are a great way to remember shortcuts to database entries that are deeply nested in a preferences database, as long as the database root is not deleted. An ID can be retrieved from any <a class="el" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> dataset, and can then be used to create multiple new references to the same dataset.</p>
<p>ID's can be very helpful when put into the <code>user_data()</code> field of widget callbacks. </p>

</div>
</div>
<a class="anchor" id="a0eb024a8350c344303755fedb1582185"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Fl_Preferences::~Fl_Preferences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor removes allocated resources. </p>
<p>When used on the <em>base</em> preferences group, the destructor flushes all changes to the preferences file and deletes all internal databases.</p>
<p>The destructor does not remove any data from the database. It merely deletes your reference to the database. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3a1710633307e8e79ba8fd89a803042e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::deleteEntry </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a single name/value pair. </p>
<p>This function removes the entry <code>key</code> from the database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if deleting the entry failed </dd></dl>

</div>
</div>
<a class="anchor" id="a6602c3104b2c5259160cb7e0fe5dd335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::deleteGroup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a group. </p>
<p>Removes a group and all keys and groups within that group from the database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>name of the group to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if call failed </dd></dl>

</div>
</div>
<a class="anchor" id="a9004c55f8c0c9515943b96853ea17940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Preferences::entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of entries (name/value pairs) in a group. </p>
<dl class="section return"><dt>Returns</dt><dd>number of entries </dd></dl>

</div>
</div>
<a class="anchor" id="a61bd91e8c3ee2a3f8bccd00ee2a65b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Fl_Preferences::entry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of an entry. </p>
<p>There is no guaranteed order of entry names. The index must be within the range given by <a class="el" href="classFl__Preferences.html#a9004c55f8c0c9515943b96853ea17940" title="Returns the number of entries (name/value pairs) in a group.">entries()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>number indexing the requested entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to value cstring </dd></dl>

</div>
</div>
<a class="anchor" id="a05c3d7cbf364d5d1ed350ef33850f702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::entryExists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if an entry with this name exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry that is searched for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if entry was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a4d49e9959bc26fdc20641534497f3792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Fl_Preferences::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes all preferences to disk. </p>
<p>This function works only with the base preferences group. This function is rarely used as deleting the base preferences flushes automatically. </p>

</div>
</div>
<a class="anchor" id="a0991a0bea2800ce5cd362ff6a778c0d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a128339abc1a1ff6bca073de3a62b2cb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a0d71373c6af5199bc1bb1fb955cb3a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a30e9d1ae031b06f501779c8937533740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). <a class="el" href="classFl__Preferences.html#a0991a0bea2800ce5cd362ff6a778c0d3" title="Reads an entry from the group.">get()</a> allocates memory of sufficient size to hold the value. The buffer must be free'd by the developer using 'free(value)'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">text</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a1074a165aa35687955568c7a13ba1462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). 'maxSize' is the maximum length of text that will be read. The text buffer must allow for one additional byte for a trailing zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">text</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>maximum length of value plus one byte for a trailing zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="a4b0188c9976139103b5c49761c8b765a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). <a class="el" href="classFl__Preferences.html#a0991a0bea2800ce5cd362ff6a778c0d3" title="Reads an entry from the group.">get()</a> allocates memory of sufficient size to hold the value. The buffer must be free'd by the developer using 'free(value)'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultSize</td><td>size of default value array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the default value was used </dd></dl>

</div>
</div>
<a class="anchor" id="ae909187975eefda3c8bbef494296bc9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>defaultValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an entry from the group. </p>
<p>A default value must be supplied. The return value indicates if the value was available (non-zero) or the default was used (0). 'maxSize' is the maximum length of text that will be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>value returned from preferences or default value if none was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>default value to be used if no preference was set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultSize</td><td>size of default value array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>maximum length of value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the default value was used</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>maxSize should receive the number of bytes that were read. </dd></dl>

</div>
</div>
<a class="anchor" id="acf3c545a4006ef50b091ed45b6f7ce2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::getUserdataPath </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pathlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path that is related to the preferences file and that is usable for additional application data. </p>
<p>This function creates a directory that is named after the preferences database without the <code></code>.prefs extension and located in the same directory. It then fills the given buffer with the complete path name.</p>
<p>Exmaple: </p>
<div class="fragment"><div class="line"><a class="code" href="classFl__Preferences.html" title="Fl_Preferences provides methods to store user settings between application starts.">Fl_Preferences</a> prefs( <a class="code" href="classFl__Preferences.html#a0947b73d778ca66b9fbb97b75bbbd7cbaaf4354ca5ac4df110c2fd1fc36c61053" title="Preferences apply only to the current user.">USER</a>, <span class="stringliteral">&quot;matthiasm.com&quot;</span>, <span class="stringliteral">&quot;test&quot;</span> );</div>
<div class="line"><span class="keywordtype">char</span> <a class="code" href="classFl__Preferences.html#aaf2e1a8f1904abb41f3cfa195ae9df41" title="Return the full path to this entry.">path</a>[<a class="code" href="group__filenames.html#ga29253083ed9918c2f9d532bd5ed89cc3" title="all path buffers should use this length">FL_PATH_MAX</a>];</div>
<div class="line">prefs.getUserdataPath( path );</div>
</div><!-- fragment --><p> creates the preferences database in (MS Windows): </p>
<div class="fragment"><div class="line">c:/Documents and Settings/matt/Application Data/matthiasm.com/test.prefs</div>
</div><!-- fragment --><p> and returns the userdata path: </p>
<div class="fragment"><div class="line">c:/Documents and Settings/matt/Application Data/matthiasm.com/test/</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>buffer for user data path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathlen</td><td>size of path buffer (should be at least <code>FL_PATH_MAX</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if path was not created or pathname can't fit into buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a8aeb2bab88aea893c700533c5dea3d41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Fl_Preferences::group </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the Nth (<code>num_group</code>) group. </p>
<p>There is no guaranteed order of group names. The index must be within the range given by <a class="el" href="classFl__Preferences.html#a70cfbe5245270b772806e085603a7ab8" title="Returns the number of groups that are contained within a group.">groups()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_group</td><td>number indexing the requested group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'C' string pointer to the group name </dd></dl>

</div>
</div>
<a class="anchor" id="a4009efec7d5505a8060ca7a95c1bee2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::groupExists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if a group with this name exists. </p>
<p>Group names are relative to the Preferences node and can contain a path. "." describes the current node, "./" describes the topmost node. By preceding a groupname with a "./", its path becomes relative to the topmost node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of group that is searched for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no group by that name was found </dd></dl>

</div>
</div>
<a class="anchor" id="a70cfbe5245270b772806e085603a7ab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Preferences::groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of groups that are contained within a group. </p>
<dl class="section return"><dt>Returns</dt><dd>0 for no groups at all </dd></dl>

</div>
</div>
<a class="anchor" id="ae357c2136fce436e367b92c0337a4778"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Fl_Preferences::newUUID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a UUID as generated by the system. </p>
<p>A UUID is a "universally unique identifier" which is commonly used in configuration files to create identities. A UUID in ASCII looks like this: <code>937C4900-51AA-4C11-8DD3-7AB59944F03E</code>. It has always 36 bytes plus a trailing zero.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a static buffer containing the new UUID in ASCII format. The buffer is overwritten during every call to this function! </dd></dl>

</div>
</div>
<a class="anchor" id="a1928e8ca3f21f66304951b757f24d70a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a3d06e7b756a9c87acc508b835286d569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a8bd606d0dd993488d149204ee0841925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>number of decimal digits to represent value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a929db63f2f0d24d11c64ee929688b39e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a0b2d3935a8ba462d27d0e3c2c9e33841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>set this entry to <code>value</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>number of decimal digits to represent value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="a1bbc84064bf5f2675b10724567505fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>set this entry to <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="acc689e9cdf957f7636992d275498d72b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Fl_Preferences::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an entry (name/value pair). </p>
<p>The return value indicates if there was a problem storing the data in memory. However it does not reflect if the value was actually stored in the preferences file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>set this entry to <code>value</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dsize</td><td>size of data array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if setting the value failed </dd></dl>

</div>
</div>
<a class="anchor" id="aca6793ffe782ad4a55c604caed794ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Fl_Preferences::size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the value part of an entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>name of entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of value </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Fl__Preferences_8H_source.html">Fl_Preferences.H</a></li>
<li>Fl_Preferences.cxx</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer">
      <!-- Generated for FLTK 1.3.2 by Doxygen -->
      &copy; 1998-2012 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="http://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>
</body>
</html>
