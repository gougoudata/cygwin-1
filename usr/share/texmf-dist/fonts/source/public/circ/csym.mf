%%
%% This is file `csym.mf',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% circ.dtx  (with options: `csym')
%% CIRC is a LaTeX package to typeset circuit and optics diagrams.
%% Copyright (C) 1997,1998,2003  Sebastian Tannert and Andreas Tille
%% 
%%   This program is free software; you can redistribute it and/or modify
%%   it under the terms of the GNU General Public License as published by
%%   the Free Software Foundation; either version 2 of the License, or
%%   (at your option) any later version.
%% 
%%   This program is distributed in the hope that it will be useful,
%%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%   GNU General Public License for more details.
%% 
%%   You should have received a copy of the GNU General Public License
%%   along with this program; if not, write to the Free Software
%%   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%% 
%% For error reports concerning UNCHANGED versions of this file no
%% more than one year old, see CIRC.DVI after installation.
%% If installation fails search thru this file for 'bug'.
mode_setup;

lLE#      :=7pt#;
define_whole_pixels(lLE);

linethickness#:= 0.45pt#;
thinline#     := 0.5linethickness#;
normalline#   := 1.0linethickness#;
thickline#    := 1.5linethickness#;
verythickline#:= 2.5linethickness#;
define_whole_blacker_pixels(normalline,thinline,thickline,verythickline);

fontdimen6: 1lLE#;



box_wd#  := 4lLE#;
define_pixels(box_wd);

osc_dia# := 3lLE#;
osc_t    := .75;    % settings from Andreas Tille
osc_spc  := .5lLE;
define_pixels(osc_dia);

ww_spc   := .25lLE;

darr_ht# := 1.3lLE#;
darr_lt# := 1lLE#;
darr_phi := 10;
darr_rad := 1lLE;
define_pixels(darr_ht,darr_lt);

bnd_lt# := 1lLE#;
bnd_phi := 60;
define_pixels(bnd_lt);

dsw_wd# := 4lLE#;
dsw_ht# := 2lLE#;
dsw_ov  := .2lLE;
dsw_t   := .2;
dsw_cc  := .35;
dsw_c   := .3;
dsw_phi := 12;
define_pixels(dsw_wd,dsw_ht);

tri_lt   := 0.8lLE;
tri_phi  := 18;

arr_lt   := 0.8lLE;
arr_phi  := 10;

cap_wd   :=  .4lLE;      %only for electrolytic capacitor
cap_spx  := .32lLE;      %only for electrolytic capacitor
cap_spy  :=  .5lLE;      %only for electrolytic capacitor
cap_rad  :=  .4lLE;
cap_spc  := .32lLE;
cap_ht#  :=   2lLE#;
cap_lt#  :=   2lLE#;
cap_phi  :=   45;
cap_ara  :=   1.4lLE;
cap_arb  :=   1.2lLE;
define_pixels(cap_lt,cap_ht);

res_wd   :=   3lLE;
res_ht#  :=   1lLE#;
res_lt#  :=   4lLE#;
res_ara# :=  3.3lLE#;
res_phi  :=   45;
res_x#   :=   1lLE#;
res_y#   :=   1lLE#;
res_o#   :=   res_ara#*cosd(res_phi)-res_y#;
define_pixels(res_lt,res_ht,res_x,res_y,res_o,res_ara);

did_wd   :=   1.5lLE;
did_ht#  :=   1.5lLE#;
did_lt#  :=   3lLE#;
did_zlt  :=   .4lLE;
Dcap_ht  := .5lLE;
Dcap_spc := .15lLE;
Dcap_wd  := .35lLE;
define_pixels(did_lt,did_ht);

thy_ht# := 1lLE#;
define_pixels(thy_ht);

led_lt#  :=   1.5lLE#;
led_wd   :=  .8lLE;
led_phi  :=  10;       %aperture-angle of arrows
led_psi  :=  50;       %angle of arrows from baseline
led_spc  := .4lLE;     %space between arrows
led_spx  :=  .4lLE;
led_spy#  := .8lLE#;
define_pixels(led_spy, led_lt);

pnp_dis  :=  0.18;
npn_dis  :=  (1-pnp_dis);
tst_fac  :=  0.23333;
tst_phi  :=  20;
tst_iht  :=  3lLE;
tst_wd#  :=  1lLE#;
tst_lt#  :=  2lLE#;
tst_ht#  :=  4lLE#;
define_pixels(tst_ht,tst_lt,tst_wd);

cry_wd   :=  .8lLE;
cry_spc  := .32lLE;
cry_ht#  :=   2lLE#;
cry_lt#  :=   4lLE#;
define_pixels(cry_lt,cry_ht);

ioc_dia  := .5lLE;
ioc_ht#  := .5lLE#;
ioc_lt#  :=   1lLE#;
ioc_arr  := 0.7lLE;
ioc_phi  :=  12;
define_pixels(ioc_ht,ioc_lt);

cdt_dia  := .4lLE;
cdt_ht#  := .4lLE#;
cdt_lt#  := .2lLE#;
define_pixels(cdt_ht,cdt_lt);

GND_wd#  := 1.4res_ht#;
gnd_wd#  := 1.8lLE#;
gnd_ht#  :=   1lLE#;
gnd_spc#  := .2lLE#;
gnd_q    := .7;
define_pixels(gnd_ht,gnd_spc,gnd_wd,GND_wd);

inv_rad  :=  .36lLE;
gat_ht#  :=   5lLE#;
gat_lt#  :=   7lLE#;
define_pixels(gat_lt,gat_ht);

bbd_wd# := 6lLE#;
bbd_ht# := 10lLE#;
bba_wd# := 8lLE#;
bba_ht# := 4lLE#;
define_pixels(bbd_wd,bbd_ht,bba_wd,bba_ht);

pin_lt#  :=   2lLE#;  % pin length
ios_wd#  :=   2.5lLE#;  % in out space
mid_wd#  :=   0lLE#;  % middle width
pin_spc# :=   2lLE#;  % pin space
out_spc# :=   1lLE#;  % outer space between pin and box

define_pixels(pin_lt,ios_wd,mid_wd,pin_spc,pin_wht,out_spc);

val_lt#  :=   2lLE#;
val_phi  :=   7;
val_lft  :=   0;
val_rht  :=   0.9;
val_ht#  :=   .2lLE#;
define_pixels(val_lt,val_ht);

cir_ht#  :=  1.2lLE#;
cir_lt#  :=  4lLE#;
cir_phi  :=  45;
cir_ara  :=  2.2lLE;
cir_arb  :=  1.8lLE;
define_pixels(cir_ht,cir_lt);

uso_ht#  :=  1.5lLE#;
uso_lt#  :=  4lLE#;
uso_min  :=  1lLE;
uso_pls  :=  3lLE;
uso_spc  := .5lLE;
uso_rad  :=  3lLE;
uso_dis  := 0.2;
uso_phi  := 45;
uso_ara  := 1.6lLE;
uso_arb  := .8lLE;
define_pixels(uso_ht,uso_lt);

iso_ht#  := 1.2lLE#;
iso_lt#  := 4lLE#;
iso_dis  := 0.7;
iso_rad  :=  .8lLE;
iso_phi  := 45;
iso_ara  := 2.2lLE;
iso_arb  := 1.8lLE;
define_pixels(iso_ht,iso_lt);

coi_ht#  :=  .35lLE#;
coi_lt#  :=    4lLE#;
define_pixels(coi_ht,coi_lt);
coi_rad  :=  coi_ht;
coi_num  :=    4;

swt_lt#  :=  4lLE#;
swt_phi  :=  30;
swt_dis  :=  0.3;
swt_ind  :=  0.8;
swt_slt  :=  0.4lLE;
swt_ht#  := (1-2swt_dis)*sind(swt_phi)*swt_lt#;
define_pixels(swt_ht,swt_lt);

opv_ht#  := 4.5lLE#;
opv_lt#  := 14lLE#;
opv_dis#  := 3lLE#;
opv_frc  := 1.1;
define_pixels(opv_lt,opv_ht,opv_dis);

fet_SD#  :=  4lLE#;     % Source--Drain
fet_GSx# :=  2lLE#;     % Gate--Source, x
fet_GSy# :=  1lLE#;     % Gate--Source, y
fet_Gsub :=  1lLE;      % Gate--Substrat
fet_soSD :=  0.3lLE;    % Substrat "uber Source und Drain
fet_sarr :=  0.2lLE;    % Substrat--Pfeil
define_pixels(fet_SD,fet_GSx,fet_GSy);

mos_SD#  := fet_SD#;
mos_GSx# := fet_GSx#;
mos_GSy# := fet_GSy#;

mos_sd   := 2.3lLE;
mos_Gsub := fet_Gsub;
mos_ox   := 0.3lLE;
mos_soSD := fet_soSD;
mos_rad  := 0.2lLE;
define_pixels(mos_SD,mos_GSx,mos_GSy);

sym# := 232/36pt#;
define_pixels(sym);


extra_endchar:=extra_endchar & "labels(range 0 thru 30);";

def {{ =
   begingroup
   save T; transform T;
   T:=currenttransform;
   save currenttransform;
   transform currenttransform;
   currenttransform:=T;
enddef;

def }} = endgroup; enddef;

def noarrowTF =
  transform _aT;
  numeric _x[],_y[];
  _aT:=currenttransform;
  for $=1 upto 20 : _x[$]:=x[$]; _y[$]:=y[$]; endfor;
  endgroup;
  for $=1 upto 20 : x[$]:=_x[$]; y[$]:=_y[$]; endfor;
  {{
enddef;

def addTF(text t) = currenttransform:=currenttransform t; enddef;
def addxTF(text t) = currenttransform:=(identity t) transformed
                     currenttransform; enddef;

def triangle(expr p, l, alpha, phi) =
  pair iz[];
  iz0=(0,0);
  iz1=iz0+((l,0) rotated (alpha+phi));
  iz2=iz0+((l,0) rotated (-alpha+phi));
  fill ((iz0--iz1--iz2--cycle) shifted round(p));
enddef;

def arrow(expr p, a, b, phi, l, alpha)(text doother) =
  pair iz[];
  iz0=(0,0);
  iz1=iz0-((l,0) rotated (alpha+phi));
  iz2=iz0-((l,0) rotated (-alpha+phi));
  iz3=p transformed if known _aT : _aT; else: identity; fi;
  iz3-iz4=(b,0) rotated phi;
  iz5-iz3=(a,0) rotated phi;
  iz6-iz3=(a-3*rt(0),0) rotated phi;
  draw iz4--iz6;
  doother;
  draw ((iz1--iz0--iz2) shifted round(iz5));
  transform _aT; %Transformation l"oschen
enddef;

def fillarrow(expr p, a, b, phi, l, alpha)(text doother) =
  pair iz[];
  iz0=(0,0);
  iz1=iz0-((l,0) rotated (alpha+phi));
  iz2=iz0-((l,0) rotated (-alpha+phi));
  iz3=p transformed if known _aT : _aT; else: identity; fi;
  iz3-iz4=(b,0) rotated phi;
  iz5-iz3=(a,0) rotated phi;
  iz6-iz3=(a-3*rt(0),0) rotated phi;
  draw iz4--iz6;
  doother;
  fill ((iz1--iz0--iz2--cycle) shifted round(iz5));
  transform _aT; %Transformation l"oschen
enddef;

lightarr_spc#=.5lLE#;
lightarr_lt#=1.5lLE#;
lightarr_alt=round(.7lLE);
lightarr_awd=round(.2lLE);
define_pixels(lightarr_spc,lightarr_lt);
def lightarrows(expr zpoint,lightarr_psi) =
  z100=zpoint;
  x100=x103=x105;
  x101=x104=x106=x100+lightarr_lt;
  y103=y104=y100+.5lightarr_spc;
  y105=y106=y100-.5lightarr_spc;
  x107=x108=x109=x110=x104-lightarr_alt;
  y107-y108=y109-y110=good.y(lightarr_awd);
  .5[y107,y108]=y104;
  .5[y109,y110]=y106;
  pickup pensquare scaled normalline rotated lightarr_psi;
  draw (z107--z104--z108--cycle) rotatedaround(z100,lightarr_psi);
  draw (z109--z106--z110--cycle) rotatedaround(z100,lightarr_psi);
  draw (z103--z104) rotatedaround(z100,lightarr_psi);
  draw (z105--z106) rotatedaround(z100,lightarr_psi);

enddef;

def eightchars(expr cfchar)   % erster Zeichenkode
              (text dochar)   % Zeichenkommandos
              (expr x, yf, ys, o) = % Abst"ande

  beginchar(cfchar,x,ys,yf); charic:=o;
    dochar;
  endchar;
  beginchar(cfchar+1,x,ys,yf); charic:=o;
    {{addTF(reflectedabout(up,down)); dochar;}}
  endchar;
  beginchar(cfchar+2,yf,x,o+x); charic:=ys;
    {{addTF(rotated 270); dochar;}}
  endchar;
  beginchar(cfchar+3,yf,x+o,x); charic:=ys;
    {{addTF(rotated 270); addTF(reflectedabout(left,right)); dochar;}}
  endchar;
  beginchar(cfchar+4,x,yf,ys); charic:=o;
    {{addTF(reflectedabout(left,right)); dochar;}}
  endchar;
  beginchar(cfchar+5,x,yf,ys); charic:=o;
    {{addTF(rotated 180); dochar;}}
  endchar;
  beginchar(cfchar+6,ys,x,x+o); charic:=yf;
    {{addTF(rotated 270); addTF(reflectedabout(up,down)); dochar;}}
  endchar;
  beginchar(cfchar+7,ys,x+o,x); charic:=yf;
    {{addTF(rotated 90); dochar;}}
  endchar;
enddef;

def twochars(expr cfchar)(text dochar)(expr ht, wd, dp) =
  beginchar(cfchar,wd,ht,dp);
    dochar;
  endchar;
  beginchar(cfchar+1,dp,wd,ht);
    {{addTF(rotated 90); dochar;}}
  endchar;
enddef;

def fourchars(expr cfchar)(text dochar)(text op)(expr ht, wd, dp) =
  beginchar(cfchar,wd,ht,dp);
    dochar;
  endchar;
  beginchar(cfchar+1,dp,wd,ht);
    {{addTF(rotated 90); dochar;}}
  endchar;
  beginchar(cfchar+2,wd,dp,ht);
    {{addTF(shifted -op rotated 180); dochar;}}
  endchar;
  beginchar(cfchar+3,ht,wd,dp);
    {{addTF(shifted -op rotated -90); dochar;}}
  endchar;
enddef;

def fourfourchars(expr cfchar)(text dochar)(text op)(expr ht, wd, dp) =
  beginchar(cfchar,wd,ht,dp);
    dochar;
  endchar;
  beginchar(cfchar+1,dp,wd,ht);
    {{addTF(rotated 90); dochar;}}
  endchar;
  beginchar(cfchar+2,wd,dp,ht);
    {{addTF(shifted -op rotated 180); dochar;}}
  endchar;
  beginchar(cfchar+3,ht,wd,dp);
    {{addTF(shifted -op rotated -90); dochar;}}
  endchar;
  beginchar(cfchar+4,wd,dp,ht);
    {{addTF(reflectedabout(left,right)); dochar;}}
  endchar;
  beginchar(cfchar+5,ht,wd,dp);
    {{addTF(reflectedabout(left,right) rotated 90); dochar;}}
  endchar;
  beginchar(cfchar+6,wd,ht,dp);
    {{addTF(reflectedabout (left,right) shifted -op rotated 180); dochar;}}
  endchar;
  beginchar(cfchar+7,dp,wd,ht);
    {{addTF(reflectedabout(left,right) shifted -op rotated -90); dochar;}}
  endchar;
enddef;


primarydef x gridmod y = if x>0: (x mod y) else: -(-x mod y) fi enddef;

def vshade(suffix pa, pb)(expr di, patternpath) = begingroup
  path vl;
  boolean ifshift;

  if not cycle patternpath:
    errmessage "patternpath has to be a cyclic path!" fi;

  interim smoothing:=0;                  %change local only
  interim autorounding:=0;

  ifshift:=true;
  ydi:=round(1.41di);                    % round against pattern in
  xdi:=round(di);                        % pattern
  if xdi<2: errmessage "di to small! di>=2" fi;
  xs:=xpart(point 0 of pa);
  xe:=xpart(point infinity of pa);
  if xs>xe: ye:=xe; xe:=xs; xs:=ye; fi   %force xs<xe
  xs:=xs+((xe-xs) mod xdi) / 2;          %adjust grid horizontally
  vl:=(xs,infinity)--(xs,-infinity);
  oys:=ypart(pa intersectionpoint vl);
  oys:=oys-.5ydi;                        %adjust grid vertically
  for xs:=xs step xdi until xe:
    vl:=(xs,infinity)--(xs,-infinity);   % new cut line
    ys:=ypart(pa intersectionpoint vl);
    ye:=ypart(pb intersectionpoint vl);
    ifshift:=not(ifshift);               %shift periodically
    sy:=ydi-((ys-oys) gridmod ydi);
    ys:=ys+sy if ifshift: if sy-.5ydi<0:+else:-fi .5ydi fi;
    for ys:=ys step if ys>ye:-fi ydi until ye:
      fill patternpath shifted (xs,ys);
    endfor
  endfor;
  endgroup
enddef;

def hshade(suffix pa, pb)(expr di, patternpath) = begingroup
  path hl;
  boolean ifshift;

  if not cycle patternpath:
    errmessage "patternpath has to be a cyclic path!" fi;

  interim smoothing:=0;                  %change local only
  interim autorounding:=0;

  ifshift:=true;
  xdi:=round(1.41di);                    % round against pattern in
  ydi:=round(di);                        % pattern
  if ydi<2: errmessage "di to small! di>=2" fi;
  ys:=ypart(point 0 of pa);
  ye:=ypart(point infinity of pa);
  if ys>ye: xe:=ye; ye:=ys; ys:=xe; fi   %force ys<ye
  ys:=ys+((ye-ys) mod ydi) / 2;          %adjust grid vertically
  hl:=(infinity,ys)--(-infinity,ys);
  oxs:=xpart(pa intersectionpoint hl);
  oxs:=oxs-.5ydi;                        %adjust grid horizontally
  for ys:=ys step ydi until ye:
    hl:=(infinity,ys)--(-infinity,ys);   % new cut line
    xs:=xpart(pa intersectionpoint hl);
    xe:=xpart(pb intersectionpoint hl);
    ifshift:=not(ifshift);               %shift periodically
    sx:=xdi-((xs-oxs) gridmod xdi);
    xs:=xs+sx if ifshift: if sx-.5xdi<0:+else:-fi .5xdi fi;
    for xs:=xs step if xs>xe:-fi xdi until xe:
      fill patternpath shifted (xs,ys);
    endfor
  endfor;
  endgroup
enddef;

endinput;
%% 
%%
%% End of file `csym.mf'.
