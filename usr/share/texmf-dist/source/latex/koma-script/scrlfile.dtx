% \CheckSum{593}
% \iffalse meta-comment
% ======================================================================
% scrlfile.dtx
% Copyright (c) Markus Kohm, 2002-2012
%
% This file is part of the work `scrlfile' which is part of the LaTeX2e
% KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of files `scrlfile.dtx', `scrlfile.ins' and 
% `scrlogo.dtx' at least.
% ----------------------------------------------------------------------
% scrlfile.dtx
% Copyright (c) Markus Kohm, 2002-2012
%
% Diese Datei ist Teil des Werks `scrlfile', das wiederum Teil des
% LaTeX2e KOMA-Script Pakets ist.
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht mindestens aus den Dateien `scrlfile.dtx',
% `scrlfile.ins' und `scrlogo.dtx'.
% ======================================================================
% \fi
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse
%%% From File: scrlfile.dtx
%<*driver|scrlfile|load>
% \fi
\def\scrlfileversion{2011/03/09 v3.09}
% \iffalse
%</driver|scrlfile|load>
%<*driver>
% \fi
\ProvidesFile{scrlfile.dtx}[%
% \iffalse
%</driver>
%<*driver|scrlfile>
%<scrlfile>\ProvidesPackage{scrlfile}[%
% \fi
  \scrlfileversion\space KOMA-Script package (loading files)]
% \iffalse
%</driver|scrlfile>
%<*driver>
\IfFileExists{scrdoc.cls}{%
  \documentclass[halfparskip-]{scrdoc}
}{%
  \documentclass{ltxdoc}
}
\providecommand*{\KOMAScript}{\textsf{KOMA-Script}}
\usepackage[german,english]{babel}
\CodelineIndex
\RecordChanges
\GetFileInfo{scrlfile.dtx}
\title{\KOMAScript{} \partname\ \texttt{\filename}%
  \thanks{This file is version \fileversion\ of file \texttt{\filename}.}}  
\date{\filedate}
\author{Markus Kohm\thanks{mailto:komascript@gmx.info}~\thanks{Parts of
    description sections of the documentation where written by Jens-Uwe
    Morawski.}}

\begin{document}
  \maketitle
  \begin{abstract}
    This package provides hooks before and after loading files, packages or
    classes. It also provides a hook after the last \cs{clearpage} of the
    document. It allowes to replace files, packages and classes by other
    files, packages and classes. It is inteded to be used by package and class
    authors but may also be used by \LaTeX{} users.
  \end{abstract}

  \section{Legal Note}
  This is the only part of \KOMAScript{} you are allowed to
  redistribute without all the other files of \KOMAScript.  You are
  allowed to redistribute and/or modifie the files
  ``\texttt{scrlogo.dtx}'', ``\texttt{scrlfile.dtx}'' and
  ``\texttt{scrlfile.ins}'' under the conditions of \LaTeX{} Project
  Public License, either version 1.3c of this license or (at your
  option) any later version.  The latest version of this license is in
  \mbox{http://www.latex-project.org/lppl.txt} and version 1.3c or
  later is part of all distributions of \LaTeX{} version 2005/12/01 or
  later.  You are not allowed to distribute one of the three files
  ``\texttt{scrlogo.dtx}'', ``\texttt{scrlfile.dtx}'' and
  ``\texttt{scrlfile.ins}'' without the others but all these files
  together.
  
  \KOMAScript{} is a versatile bundle of \LaTeX{} classes and
  packages. Large german and english manuals, both with more than
  200~pages, are part of \KOMAScript{} bundle.  You can find a longer
  version of the \textsf{scrlfile}-documentation at the \KOMAScript{}
  manuals. 
  
  You can find the latest version of \KOMAScript{} bundle and
  \texttt{scrlfile} at
  \mbox{CTAN:/macros/latex/contrib/supported/koma-script/} in the
  course of which ``CTAN:'' is a short hand synonym for directory
  ``tex-archive'' at every CTAN server and mirror, e.g.\ 
  \mbox{ftp://ftp.dante.de/tex-archive/}.  See
  \mbox{http://www.ctan.org} for a list of CTAN servers and mirrors.

  \DocInput{\filename}
\end{document}
%</driver>
% \fi
%
% \selectlanguage{english}
%
% \changes{v2.95}{2002/06/11}{%
%   First version split from hugh scrclass.dtx}
%
%
% \section[Hook loading files, packages or classes]{%
%   Hooks loading files, packages or classes\footnote{You'll find a
%   short version of \textsf{scrlfile} documentation here. A longer
%   version may be found at english and german \KOMAScript{} manual.}}
%
% The introduction of \LaTeXe{} in 1994 brought many changes in the
% handling with \LaTeX-extensions.  Today the package author has many
% macros in order to determine if another package or class is employed
% and whether specific options are used.  The author can load other
% packages or can specify options in the the case the package is loaded
% later.  This has led to the expectation that the order of
% package-loading will be not important.  But this hope has not been
% fulfilled, since often different packages define or redefine one macro
% again and again.  In such a case the order of package-loading becomes
% very important.  For the user it is sometimes difficult to understand
% the behaviour and in some cases the user wants only react on the
% loading of a package.  This is also not really simple.
%     
% Assuming the simple example that loads the package \textsf{longtable}
% with a \KOMAScript{} document-class employed.  The \textsf{longtable}
% package defines table captions suitable for the standard classes, but
% the captions are totally unsuitable for documents using \KOMAScript{}
% and thus the provided configuration commands have no influence.  In
% order to solve this problem the commands which are responsible for the
% table captions of the \textsf{longtable} package have to be
% re-defined.  But at the moment when the \textsf{longtable} is loaded
% the \KOMAScript{} class is already processed.
% 
% The only chance for \KOMAScript{} was to delay the re-definition until
% the begin of the document with help of the macro |\AtBeginDocument|.
% If the user wants to change the definitions too, it is recommended to
% do this in the preamble of the document.  But this is impossible since
% later at |\begin{document}| \KOMAScript will again overwrite the
% user-definition with its own.  Therefore the user has to delay his
% definition with \verb|\AtBeginDocument| as well.
%
% However, \KOMAScript{} shouldn't delay the re-definition until
% |\begin{document}|.  It would be enough to delay until the package
% \textsf{longtable} has been loaded.  But unfortunately the basic
% \LaTeX{} does not define appropriate commands.  The package
% \textsf{scrlfile} provides redress here.
%  
% Likewise, it might be conceivable that before a package is loaded one
% would like to save the definition of a macro in a help-macro, in order
% to restore its meaning after the package has been loaded.  The package
% \textsf{scrlfile} allows this too.
%  
% The employment of \textsf{scrlfile} is not limited to package
% dependencies only.  Even dependencies with any other file can be
% attended.  For example the user can be warned if the not uncritical
% file \texttt{french.ldf} has been loaded.
% 
% Though the package is particularly interesting for package authors,
% there are of course applications for normal \LaTeX{} users too.
% Therefore this chapter gives and explains examples for both groups of
% users.
%
%
% \DescribeMacro{\BeforeFile}
% \DescribeMacro{\AfterFile}
% The command \cs{BeforeFile}\marg{file}\marg{instructions} enables to
% execute \meta{instructions} the next time the \meta{file} is
% loaded.  In the same way works \cs{AfterFile}, but here the
% \meta{instructions} will be executed after the \meta{file} has
% been loaded.  If \meta{file} will never be loaded then the
% \meta{instructions} will never be executed.
%
% In order to implement those features \textsf{scrlfile} re-defines
% the well known \LaTeX{} command \cs{InputIfFileExists}.  If this
% macro has not the expected definition \textsf{scrlfile} gives a
% warning.  This is for the case that in future \LaTeX{} versions the
% macro can have a different definition or an other package has
% already re-defined it.
%
% The command \cs{InputIfFileExists} is used everytime \LaTeX{} has to
% load a file.  This is independent from whether the actual command
% was \cs{LoadClass}, \cs{documentclass}, \cs{usepackage},
% \cs{RequiresPackage}, or \cs{include}. Exclusively the command
% \begin{verbatim}
%   \input foo
% \end{verbatim}\vspace{-\baselineskip}%
% loads the file \meta{foo} without to utilize
% \cs{InputIfFileExists}. Therefore one should always use 
% \begin{verbatim}
%   \input{foo}
% \end{verbatim}\vspace{-\baselineskip}%
% instead. Notice the parentheses surrounding the file name!
%
% \DescribeMacro{\BeforeClass}
% \DescribeMacro{\BeforePackage}
% The command \cs{BeforeClass}\marg{class}\marg{instructions} and the
% command \cs{BeforePackage}\marg{package}\marg{instructions} work
% the same way like the above described \cs{BeforeFile}.  The only
% difference is that the document \meta{class} and the \LaTeX{}
% \meta{package} are specified with their names and not with their
% file names.  That means the file extensions ``\texttt{.cls}'' and
% ``\texttt{.sty}'' have to be omitted.
%
% \DescribeMacro{\AfterClass}
% \DescribeMacro{\AfterClass*}
% \DescribeMacro{\AfterClass+}
% \DescribeMacro{\AfterClass!}
% \DescribeMacro{\AfterPackage}
% \DescribeMacro{\AfterPackage*}
% \DescribeMacro{\AfterPackage+}
% \DescribeMacro{\AfterPackage!}
% The command \cs{AfterClass}\marg{class}\marg{instructions} and the
% command \cs{AfterPackage}\marg{package}\marg{instructions} work the
% same way like command \cs{AfterFile}.  The only difference is that
% the document \meta{class} and the \LaTeX{} \meta{package} are
% specified with their names and not with their file names.  That
% means the file extensions ``\texttt{.cls}'' and ``\texttt{.sty}''
% have to be omitted.  The starred versions execute the
% \meta{instructions} not only next time the class or package is
% loaded, but also immediately if the class or package has been loaded
% already. The plus versions differ from the starred versions by execution
% first if loading of class of package has been finished. The difference is
% only valid if A loads B and B uses one of the after commands for A. In all
% cases the \meta{instructions} will be executed before \cs{AtEndOfClass} or
% \cs{AtEndOfPackage} calls of the class or package if loading of the class or
% package was finished not yet. To even execute the \marg{instructions} after
% those, use the exclamation mark version.
%
% \DescribeMacro{\AfterAtEndOfClass}
% \DescribeMacro{\AfterAtEndOfPackage}
% The command \cs{AfterAtEndOfClass}\marg{class}\marg{instructions} and the
% command \cs{AfterAtEndOfPackage}\marg{package}\marg{instructions} work like
% \cs{AfterClass} and \cs{AfterPackage} but execute the \meta{instructions}
% after \cs{AtEndOfClass} or \cs{AtEndOfPackage} instructions outside the
% context of the class or package. There are no star, plus or exclamation mark
% versions of these commands. Just use \cs{AfterClass!} or \cs{AfterPackage!}
% if you want to execute the \meta{instructions} if the class or package has
% been loaded already.
%
% \DescribeMacro{\ReplaceInput}
% The command \cs{ReplaceInput}\marg{name of file to be replaced}\marg{name of
% replacement file} sets up an replacement. Whenever \LaTeX{} is told to input
% the file with \meta{name of file to be replaced} it will input the file with
% \meta{name of replacement file} instead. With this you may even teill \LaTeX
% to input e.g. ``\texttt{\cs{jobname}.xua}'' instead of
% ``\texttt{\cs{jobname.aux}}'' using:
% \begin{verbatim}
%   \ReplaceInput{\jobname.aux}{\jobname.xua}
% \end{verbatim}\vspace{-\baselineskip}
% If you replace a replacement file both, the first replaced file and the
% replacement file will be replaced by the new replacement file. So
% \begin{verbatim}
%   \ReplaceInput{\jobname.aux}{\jobname.xua}
%   \ReplaceInput{\jobname.xua}{\jobname.uxa}
% \end{verbatim}\vspace{-\baselineskip}
% will replace ``\texttt{\cs{jobname}.aux}'' and ``\texttt{\cs{jobname}.xua}''
% by ``\texttt{\cs{jobname}.uxa}''. But ring replacement like
% \begin{verbatim}
%   \ReplaceInput{\jobname.aux}{\jobname.xua}
%   \ReplaceInput{\jobname.xua}{\jobname.aux}
% \end{verbatim}\vspace{-\baselineskip}
% would result in an stack size error. So you cannot input an already replaced
% file using \LaTeX{} commands.
%
% \DescribeMacro{\ReplaceClass}
% \DescribeMacro{\ReplacePackage}
% You should not replace a class or package using \cs{ReplaceInput}. If you do
% so, you'll get errors because of not matching class names. But you may use
% \cs{ReplaceClass}\marg{name of class to be replaced}\marg{name of
% replacement class} and \cs{ReplacePackage}\marg{name of package to be
% replaced}\marg{name of replacement package} instead. With this commands like
% \cs{documentclass}\marg{name of class to be replaced} would work like
% \cs{documentclass}\marg{name of replacement class}. Effected commands are
% \cs{LoadClass}, \cs{LoadClassWithOptions}, \cs{documentclass},
% \cs{RequirePackage}, \cs{RequirePackageWithOptions}, \cs{usepackage}.
%
% Note: The replacement class or package will be loaded with the same option
% list the replaced class or package would have been. If you replace a
% class or package with a class or package that does not know the options of
% the replaced class or package, you may declare the missing options using
% \cs{BeforeClass} and \cs{BeforePackage}.
%
% If you e.g. want to load package \texttt{newfoo} instead of package
% \texttt{oldfoo} you may use:
% \begin{verbatim}
%   \ReplacePackage{oldfoo}{newfoo}
% \end{verbatim}\vspace{-\baselineskip}
% And if the old package had an option \texttt{oldopt} but the new package
% does not you may use
% \begin{verbatim}
%   \BeforePackage{newfoo}{%
%     \DeclareOption{oldopt}{%
%       \PackageInfo{newfoo}{option ``oldopt'' not supported}%
%     }%
%   }
% \end{verbatim}\vspace{-\baselineskip}
% If new option \texttt{newopt} should be used instead of \texttt{oldopt} you
% may use:
% \begin{verbatim}
%   \BeforePackage{newfoo}{%
%     \DeclareOption{oldopt}{%
%       \ExecuteOption{newopt}%
%     }%
%   }
% \end{verbatim}\vspace{-\baselineskip}
% You may also set new default options using:
% \begin{verbatim}
%   \BeforePackage{newfoo}{%
%     \DeclareOption{oldopt}{%
%       \ExecuteOption{newopt}%
%     }%
%     \PassOptionsToPackage{newdefoptA,newdefoptB}{newfoo}%
%   }
% \end{verbatim}\vspace{-\baselineskip}
% or simply
% \begin{verbatim}
%   \BeforePackage{newfoo}{%
%     \DeclareOption{oldopt}{%
%       \ExecuteOption{newopt}%
%     }%
%   }
%   \PassOptionsToPackage{newdefoptA,newdefoptB}{newfoo}%
% \end{verbatim}\vspace{-\baselineskip}
% 
% Note: To replace classes you have to load \textsf{scrlfile} using
% \cs{RequirePackage} before loading the class.
%
% \DescribeMacro{\PreventPackageFromLoading}
% \DescribeMacro{\ResetPreventPackageFromLoading}
% \DescribeMacro{\StorePreventPackageFromLoading}
% The command \cs{PreventPackageFromLoading}\marg{package list}
% does not replace a package by another but prevents packages from beeing
% loaded even if they should be loaded using \cs{RequirePackage} or
% \cs{usepackage}. The \meta{package list} is a comma seperated list of
% packages, that should never be loaded. If you use the command several times,
% the later \meta{package lists} will be added to the already existing. You
% may use \cs{ResetPreventPackageFromLoading} to clean the \meta{package
% list}. If you need to know the packages at the \meta{package list}, you may
% use \cs{StorePackageFromLoading}\marg{command} to store the current list at
% macro \meta{command}.
%
% \DescribeMacro{\BeforeClosingMainAux}
% The command \cs{BeforeClosingMainAux}\marg{instructions}
% works different from all the commands above. Is isn't a
% load-file-hook. Package authors often have the problem, that they
% need to write something to \texttt{aux}-file after output of the
% last page. This is often done with:
% \begin{flushleft}
% |  \AtEndDocument{\if@filesw|\\
% |      \write\@auxout{%|\\
% |        |\texttt{\emph{Write this to aux.}}\\
% |      }%|\\
% |    \fi}|
% \end{flushleft}
% But this fails, if the last \cs{shipout} was already done
% e.g. because of someone used a different solution:
% \begin{flushleft}
% |  \AtEndDocument{\if@filesw\clearpage|\\
% |      \immediate\write\@auxout{%|\\
% |        |\texttt{\emph{Write this to aux.}}\\
% |      }%|\\
% |    \fi}|
% \end{flushleft}
% The best solution would be to immediate write to \texttt{aux}-file
% just after the \cs{clearpage} and before closing \texttt{aux}-file
% at \cs{end\{document\}}. That's the goal of
% \cs{BeforeClosingMainAux}:
% \begin{flushleft}
% |  \BeforeClosingMainAux{\if@filesw|\\
% |      \immediate\write\@auxout{%|\\
% |        |\texttt{\emph{Write this to aux.}}\\
% |      }%|\\
% |    \fi}|
% \end{flushleft}
% This even works, if \cs{clearpage} at \cs{end\{document\}} will not
% result in \cs{shipout} or if typessetting code\,---\,even
% \cs{clearpage}\,---\,has been used at \cs{AtEndDocument}.
%
% The \cs{BeforeClosingMainAux} hook should not be used for code that
% does any typesetting since the result of \cs{BeforeClosingMainAux}
% would be unpredictable.
%
% \DescribeMacro{\AfterReadingMainAux}
% The command \cs{AfterReadingfMainAux}\marg{instructions} works similar to
% \cs{BeforeClosingMainAux}, but instead of processing instructions before
% closing the main aux-file, they will be processed after reading the main
% aux-file at \cs{begin\{document\}}.
%
% The \cs{AfterReadingMainAux} hook should not be used for code that does any
% typesetting since the result of \cs{AfterReadingMainAux} would be
% unprecitable.
%
%
% \StopEventually{\PrintIndex\PrintChanges}
%
% \iffalse
%<*scrlfile>
% \fi
%
% \subsection{Preamble}
%
% First of all we show the package and version at terminal and
% log-file:
%    \begin{macrocode}
\typeout{Package scrlfile, \csname ver@scrlfile.sty\endcsname%
  ^^J\@spaces\@spaces\@spaces\@spaces\space\space 
  Copyright (C) Markus Kohm^^J}
%    \end{macrocode}
%
%
% \subsection{Options}
%
% Currently there are no options.
%    \begin{macrocode}
\ExecuteOptions{}
\ProcessOptions\relax
%    \end{macrocode}
%
%
% \subsection{The macros}
%
%  \begin{macro}{\InputIfFileExists}
%    \changes{v2.96}{2006/07/19}{replacement code added}
% \LaTeX{} uses this macro for loading files with
% \cs{input}\marg{filename}, \cs{include}, \cs{LoadClass},
% \cs{LoadClassWithOptions}, \cs{documentclass}, \cs{documentstyle},
% \cs{RequirePackage}, \cs{usepackage}. Only
% \cs{input}~\meta{filename} loads \meta{filename} without using
% \cs{InputIfFileExists}.
%
% Because of this, it's very easy to add stuff before and after
% loading a file. We simply change this macro and add to
% macros\,---\,one before loading the file and one after loading the
% file. But before we redefine the macro, we test, if the macro was
% defined like we expected. \LaTeX{} will warn, if not.
%    \begin{macrocode}
\CheckCommand{\InputIfFileExists}[2]{%
  \IfFileExists{#1}%
    {#2\@addtofilelist{#1}\@@input \@filef@und}}
%    \end{macrocode}
% Now we can redefine the macro like described above:
%    \begin{macrocode}
\renewcommand{\InputIfFileExists}[2]{%
  \begingroup\expandafter\expandafter\expandafter\endgroup
  \expandafter\ifx\csname #1-@alias\endcsname\relax
    \expandafter\@secondoftwo
  \else
    \scr@replacefile@msg{\csname #1-@alias\endcsname}{#1}%
    \expandafter\@firstoftwo
  \fi
  {%
    \expandafter\InputIfFileExists\expandafter{\csname
      #1-@alias\endcsname}{#2}%
  }%
  {\IfFileExists{#1}{%
      \scr@load@hook{before}{#1}%
      #2\@addtofilelist{#1}%
      \@@input \@filef@und
      \scr@load@hook{after}{#1}%
    }}%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@loadwithoptions}
%    \changes{v2.96}{2006/07/19}{new redefinition}
%  \begin{macro}{\scr@loadwithoptions}
%    \changes{v2.96}{2006/07/19}{new helper macro}
%  \begin{macro}{\scr@@loadwithoptions}
%    \changes{v2.97a}{2007/03/07}{new helper macro}
% \LaTeX{} uses this macro for loading classes and packages using
% \cs{LoadClassWithOptions} or \cs{RequirePackageWithOptions}. We simply say
% now: if the class or package should be replaced by another, try it again
% with the replacement name. The stack is used. This will result in an
% error if the replacements are nested too deep. This should be, because it
% will also result in an error using ring replacements.
%    \begin{macrocode}
\newcommand*{\scr@@loadwithoptions}{}
\newcommand*{\scr@loadwithoptions}{}
\let\scr@loadwithoptions\@loadwithoptions
\renewcommand*{\@loadwithoptions}[3]{%
  \begingroup\expandafter\expandafter\expandafter\endgroup
  \expandafter\ifx\csname #3.#1-@aliasname\endcsname\relax
    \def\scr@@loadwithoptions{\scr@loadwithoptions{#1}{#2}{#3}}%
  \else
    \scr@replacefile@msg{\csname #3.#1-@aliasname\endcsname.#1}{#3.#1}% 
    \def\scr@@loadwithoptions{%
      \@loadwithoptions{#1}{#2}{\csname #3.#1-@aliasname\endcsname}%
    }%
  \fi
  \scr@@loadwithoptions
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\@onefilewithoption}
%    \changes{v2.96}{2006/07/19}{new redefinition}
%  \begin{macro}{\scr@onefilewithoption}
%    \changes{v2.96}{2006/07/19}{new helper macro}
%  \begin{macro}{\scr@@onefilewithoption}
%    \changes{v2.98}{2007/12/18}{new helper macro}
% \LaTeX{} uses this macro for loading classes and packages using
% \cs{LoadClass}, \cs{documentclass}, \cs{RequirePackage}, and
% \cs{usepackage}. We simply say now: if the class or package should be
% replaced by another, try it again with the replacement name. The stack is
% used. This will result in an error if the replacements are nested too
% deep. This should be, because it will also result in an error using ring
% replacements.
%    \begin{macrocode}
\newcommand*{\scr@onefilewithoptions}{}
\let\scr@onefilewithoptions\@onefilewithoptions
\def\@onefilewithoptions#1[#2][#3]#4{%
  \begingroup\expandafter\expandafter\expandafter\endgroup
  \expandafter\ifx\csname #1.#4-@aliasname\endcsname\relax
%    \end{macrocode}
% Do this ridiculous definition and call outside of \cs{ifx}\dots\cs{fi}
% because of some errornous packages like some versions of
% \textsf{breakurl}. This does not avoid an error, but the message about
% unclosed \cs{if} will be outside of \textsf{scrlfile}.
%    \begin{macrocode}
    \def\scr@@onefilewithoptions{\scr@onefilewithoptions{#1}}%
  \else
    \scr@replacefile@msg{\csname #1.#4-@aliasname\endcsname.#4}{#1.#4}%
    \edef\scr@@onefilewithoptions{%
      \noexpand\@onefilewithoptions{\csname #1.#4-@aliasname\endcsname}}%
  \fi
  \scr@@onefilewithoptions[{#2}][{#3}]{#4}%
  \scr@load@hook{lateafter}{#1.#4}%
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ReplaceInput}
%    \changes{v2.96}{2006/07/19}{new command}
% Defining the replacement by definition of \cs{\#1-@alias}.
%    \begin{macrocode}
\newcommand*{\ReplaceFile}[2]{%
  \expandafter\edef\csname #1-@alias\endcsname{#2}%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ReplacePackage}
%    \changes{v2.96}{2006/07/19}{new command}
%  \begin{macro}{\ReplaceClass}
%    \changes{v2.96}{2006/07/19}{new command}
%  \begin{macro}{\@replacefilewithext}
%    \changes{v2.96}{2006/07/19}{new helper command}
% Note that replacing a package or class will not replace the input of the
% file of the package or class but only the input of package or class.
%    \begin{macrocode}
\newcommand*{\@replacefilewithext}[3]{%
  \expandafter\edef\csname #1.#3-@aliasname\endcsname{#2}%
}
\newcommand*{\ReplacePackage}[2]{%
  \@replacefilewithext{#1}{#2}\@pkgextension
}
\newcommand*{\ReplaceClass}[2]{%
  \@replacefilewithext{#1}{#2}\@clsextension
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\scr@replacefile@msg}
%    \changes{v2.96}{2006/07/19}{new helper command}
%    \changes{v2.98}{2007/12/18}{spellfix}
% Last but not least \textsf{scrlfile} will write a message to the log file at
% every replacement.
%    \begin{macrocode}
\newcommand*{\scr@replacefile@msg}[2]{%
  \PackageInfo{scrlfile}{inputing `#1' instead of `#2'}%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\scr@load@hook}
% This macro simply calls a load-file-hook, either the \emph{before}
% or the \emph{after} one, if the hook exists. After calling the hook
% it will be deleted. First argument is the type of hook
% (\meta{before} or \meta{after}), second argument is a filename. 
%    \begin{macrocode}
\newcommand*{\scr@load@hook}[2]{%
  \@ifundefined{#2-@#1}{}{%
    \@nameuse{#2-@#1}%
    \expandafter\let\csname #2-@#1\endcsname=\relax}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\scr@set@load@hook}
% This command adds stuff to a load-file-hook, either the
% \emph{before} or the \emph{after} one. First argument is the type of
% hook (\meta{before} or \meta{after}), second is a filename. There's
% a third argument not parsed by the macro itself but
% \cs{g@addto@macro}. This third argument is the stuff, which will be
% added to the hook. Because of using \cs{g@addto@macro} the hook must
% be defined. So we define it, if it isn't.
%    \begin{macrocode}
\newcommand*{\scr@set@load@hook}[2]{%
  \@ifundefined{#2-@#1}{\@namedef{#2-@#1}{}}{}%
  \expandafter\g@addto@macro\csname #2-@#1\endcsname}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\BeforeFile}
%  \begin{macro}{\AfterFile}
%  \begin{macro}{\BeforeClass}
%  \begin{macro}{\AfterClass}
%  \begin{macro}{\AfterAtEndOfClass}
%  \begin{macro}{\@AfterClass}
%  \begin{macro}{\@@AfterClass}
%    \changes{v3.09}{2011/03/08}{new (internal)}
%  \begin{macro}{\@@@AfterClass}
%    \changes{v3.09}{2011/03/09}{new (internal)}
%  \begin{macro}{\@sAfterClass}
%  \begin{macro}{\BeforePackage}
%  \begin{macro}{\AfterPackage}
%  \begin{macro}{\AfterAtEndOfPackage}
%  \begin{macro}{\@AfterPackage}
%  \begin{macro}{\@@AfterPackage}
%    \changes{v3.09}{2011/03/08}{new (internal)}
%  \begin{macro}{\@@@AfterPackage}
%    \changes{v3.09}{2011/03/09}{new (internal)}
%  \begin{macro}{\@sAfterPackage}
% These macros add stuff to a load-file-hook of a file, class or
% package. First argument is the name of the file (with extension),
% class (without extension) or package (without extension). There's a
% second argument parsed by wether the macros themself nor
% \cs{scr@set@load@hook} but \cs{g@addto@macro}. See
% \cs{scr@set@load@hook} for more information. The star-forms
% \cs{AfterClass*} and \cs{AfterPackage*} does the action immediate,
% if the class or package was already loaded.
%    \begin{macrocode}
\newcommand*{\BeforeFile}{\scr@set@load@hook{before}}
\newcommand*{\AfterFile}{\scr@set@load@hook{after}}
\newcommand*{\BeforeClass}[1]{%
  \scr@set@load@hook{before}{#1.\@clsextension}}
\newcommand*{\AfterClass}{%
  \@ifstar {\@sAfterClass}{%
    \@ifnextchar +\@@AfterClass{%
      \@ifnextchar !\@@@AfterClass\@AfterClass
    }%
  }%
}
\newcommand*{\@@@AfterClass}[2]{%
  \begingroup\ifx\csname #2.\@clsextension-h@@k\endcsname\relax
    \aftergroup\@sAfterClass
  \else
    \aftergroup\AfterAtEndOfClass
  \fi
  \endgroup{#2}%
}
\newcommand*{\AfterAtEndOfClass}[1]{%
  \scr@set@load@hook{lateafter}{#1.\@clsextension}}
\newcommand*{\@@AfterClass}[2]{%
  \begingroup
    \expandafter\ifx\csname #2.\@clsextension-h@@k\endcsname\relax
      \aftergroup\@sAfterClass
    \else
      \aftergroup\@AfterClass
    \fi
  \endgroup{#2}%
}
\newcommand*{\@AfterClass}[1]{%
  \scr@set@load@hook{after}{#1.\@clsextension}}
\newcommand*{\@sAfterClass}[1]{%
  \begingroup
    \@ifclassloaded{#1}{%
      \aftergroup\@secondoftwo
    }{%
      \aftergroup\@AfterClass
    }%
  \endgroup
  {#1}%
}
\newcommand*{\BeforePackage}[1]{%
  \scr@set@load@hook{before}{#1.\@pkgextension}}
\newcommand*{\AfterPackage}{%
  \@ifstar {\@sAfterPackage}{%
    \@ifnextchar +\@@AfterPackage{%
      \@ifnextchar !\@@@AfterPackage\@AfterPackage
    }%
  }%
}
\newcommand*{\@@@AfterPackage}[2]{%
  \begingroup\ifx\csname #2.\@pkgextension-h@@k\endcsname\relax
    \aftergroup\@sAfterPackage
  \else
    \aftergroup\AfterAtEndOfPackage
  \fi
  \endgroup{#2}%
}
\newcommand*{\AfterAtEndOfPackage}[1]{%
  \scr@set@load@hook{lateafter}{#1.\@pkgextension}}
\newcommand*{\@@AfterPackage}[2]{%
  \begingroup
    \expandafter\ifx\csname #2.\@pkgextension-h@@k\endcsname\relax
      \aftergroup\@sAfterPackage
    \else
      \aftergroup\@AfterPackage
    \fi
  \endgroup{#2}%
}
\newcommand*{\@AfterPackage}[1]{%
  \scr@set@load@hook{after}{#1.\@pkgextension}}
\newcommand*{\@sAfterPackage}[1]{%
  \begingroup
    \@ifpackageloaded{#1}{%
      \aftergroup\@secondoftwo
    }{%
      \aftergroup\@AfterPackage
    }%
  \endgroup
  {#1}%
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\PreventPackageFromLoading}
%  \changes{v3.08}{2010/11/04}{New}
% \begin{macro}{\scrlfile@excludedpackages}
%  \changes{v3.08}{2010/11/04}{New (internal)}
% \begin{macro}{\scrlfile@saved@RequirePackage}
%  \changes{v3.08}{2010/11/04}{New (internal)}
%    \begin{macrocode}
\newcommand*{\scrlfile@excludedpackages}{}
\let\scrlfile@excludedpackages\@empty
\newcommand*{\scrlfile@saved@RequirePackage}{}
\newcommand*{\PreventPackageFromLoading}[1]{%
%    \end{macrocode}
% We do nothing, if the argument was empty:
%    \begin{macrocode}
  \edef\reserved@b{#1}%
  \ifx \reserved@b\@empty
    \PackageWarning{scrlfile}{%
      \string\PreventPackageFromLoading\space with empty argument\MesageBreak
      ignored%
    }%
  \else
%    \end{macrocode}
% If the argument was not empty we first need to patch \cs{RequirePackage} and
% maybe \cs{usepackage} too.
%    \begin{macrocode}
    \ifx\scrlfile@excludedpackages\@empty
      \let\scrlfile@saved@RequirePackage\RequirePackage
      \let\RequirePackage\scrlfile@RequirePackage
      \def\reserved@a#1{%  
        \@latex@error
        {\noexpand \usepackage before \string\documentclass}%
        {\noexpand \usepackage may only appear in the document
          preamble, i.e.,\MessageBreak
          between \noexpand\documentclass and
          \string\begin{document}.}%
        \@gobble}%
      \ifx\reserved@a\usepackage\else
        \ifx\usepackage\scrlfile@saved@RequirePackage\else
          \PackageWarning{scrlfile}{%
            Maybe serious problem: unexpected definition of\MessageBreak
            \string\usepackage
          }%
        \fi
        \let\usepackage\RequirePackage
      \fi
    \fi
%    \end{macrocode}
% We have to test, if a package was already loaded. Only not yet loaded
% packages will be added to the exclusion list. Empty arguments will be
% ignored.
%    \begin{macrocode}
    \expandafter\@for \expandafter\reserved@a\expandafter:\expandafter=%
    \reserved@b\do {%
      \ifx\reserved@a\@empty\else
        \expandafter\@ifpackageloaded\expandafter{\reserved@a}{%
          \PackageWarning{scrlfile}{%
            package `\reserved@a' already loaded.\MessageBreak
            Cannot prevent it from beeing loaded%
          }%
        }{%
          \edef\scrlfile@excludedpackages{,\reserved@a}%
        }%
      \fi
    }%
%    \end{macrocode}
% If the exclusion list is still empty (because all packages has been loaded
% already), remove the patch:
%    \begin{macrocode}
    \ifx\scrlfile@excludedpackages\@empty
      \ResetPreventPackageFromLoading
    \fi
  \fi
}
\@onlypreamble\PreventPackageFromLoading
%    \end{macrocode}
% \begin{macro}{\ResetPreventPackageFromLoading}
%  \changes{v3.08}{2010/11/04}{New}
% \begin{macro}{\StorePreventPackageFromLoading}
%  \changes{v3.08}{2010/11/04}{New}
% These two are very simple
%    \begin{macrocode}
\newcommand*{\ResetPreventPackageFromLoading}{%
  \let\scrlfile@excludedpackages\@empty
  \ifx\RequirePackage\scrlfile@RequirePackage
    \ifx\usepackage\RequirePackage
      \let\usepackage\scrlfile@saved@RequirePackage
    \fi
    \let\RequirePackage\scrlfile@saved@RequirePackage
  \fi
}
\@onlypreamble\ResetPreventPackageFromLoading
\newcommand*{\StorePreventPackageFromLoading}[1]{%
  \let#1\scrlfile@excludedpackages
}
\@onlypreamble\StorePreventPackageFromLoading
%    \end{macrocode}
% \begin{macro}{\scrlfile@RequirePackage}
%   \changes{v3.08}{2010/11/04}{New (internal)}
% This macro will replace \cs{RequirePackage} whenever the exlude list is not
% empty
%    \begin{macrocode}
\newcommand*{\scrlfile@RequirePackage}[2][]{%
  \let\reserved@c\@empty
  \@for\reserved@b:=#2\do {%
    \begingroup
      \@tempswatrue
      \@for\reserved@a:=\scrlfile@excludedpackages\do {%
        \ifx\reserved@a\reserved@b
          \PackageInfo{scrlfile}{Excluding package `\reserved@b'\MessageBreak
            from loading}%
          \@tempswafalse
        \fi
      }%
      \if@tempswa
        \xdef\reserved@c{\reserved@c,\reserved@b}%
      \fi
    \endgroup
  }%
  \ifx\reserved@c\@empty
    \let\reserved@a\scr@gobbleopt
  \else
    \edef\reserved@a{\noexpand\scrlfile@saved@RequirePackage[#1]{%
        \expandafter\@gobble\reserved@c\@empty}}%
  \fi
  \reserved@a
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\scr@gobbleopt}
%   \changes{v3.08}{2010/11/04}{New (internal)}
%   \changes{v3.08a}{2011/02/11}{\cs{@gobbleopt} renamed due to compaibility
%     problems with \texttt{ntheorem}}
% Eat the optional argument if it exists.
%    \begin{macrocode}
\newcommand{\scr@gobbleopt}[1][]{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\BeforeClosingMainAux}
%   \changes{v2.95}{2002/09/03}{new}
% \begin{macro}{\AfterReadingMainAux}
%   \changes{v3.03}{2009/03/25}{new}
% These are completly different. First we have to establish a new hook
% at \cs{end\{document\}}, just after closing the group and after the
% final \cs{clearpage}.
%    \begin{macrocode}
\AtEndDocument{%
  \let\scr@saved@checkend=\@checkend
  \renewcommand*{\@checkend}[1]{%
    \def\reserved@a{#1}\def\reserved@b{document}%
    \scr@saved@checkend{#1}%
    \ifx\reserved@a\reserved@b
      \let\scr@saved@clearpage=\clearpage
      \renewcommand*{\clearpage}{\scr@saved@clearpage
        \scr@hook@bcma
        \scr@restore@newpage
        \let\clearpage=\scr@saved@clearpage}%
    \fi%
    \let\scr@saved@dofilelist\@dofilelist
    \def\@dofilelist{%
      \scr@hook@acma
      \let\@dofilelist\scr@saved@dofilelist
      \scr@saved@dofilelist
    }%
  }%
}
%    \end{macrocode}
% \begin{macro}{\scr@saved@checkend}
%   \changes{v2.95}{2002/09/03}{new (internal)}
% \begin{macro}{\scr@saved@dofilelist}
%   \changes{v3.03}{2009/03/25}{new}
% You may see above, that we need save-to macros.
%    \begin{macrocode}
\newcommand*{\scr@saved@checkend}{}
\newcommand*{\scr@saved@dofilelist}{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\scr@redefine@newpage}
%   \changes{v3.00}{2008/07/09}{new (internal)}
%   Some classes (e.g. \textsf{letter}) write output to the aux file.
%   Because of this, redefinition of \cs{newpage} will only be done, if
%   \cs{BeforeClosingMainAux} is used.
% \begin{macro}{\scr@saved@newpage}
%   \changes{v3.00}{2008/07/09}{new (internal)}
%   And \cs{newpage} will be restored after the hook.
% \begin{macro}{\scr@restore@newpage}
%    \begin{macrocode}
\newcommand*{\scr@redefine@newpage}{%
  \let\scr@saved@newpage\newpage
  \def\scr@restore@newpage{%
    \renewcommand*{\newpage}{%
      \PackageWarningNoLine{%
        scrlfile%
      }{%
        \string\newpage\space at main aux file!\MessageBreak
        You have output material at the main aux file.\MessageBreak
        Note, that the \string\BeforeClosingMainAux\space commands\MessageBreak
        are processed before the output from aux file%
      }%
      \let\newpage\scr@saved@newpage
      \newpage
    }%
  }%
  \renewcommand*{\newpage}{%
    \PackageError{%
      scrlfile%
    }{%
      \string\newpage\space at \string\BeforeClosingMainAux
    }{%
      You should never use \string\newpage\space or
      \string\clear(double)page or other output material at the\MessageBreak
      argument of \string\BeforeClosingMainAux!\MessageBreak
      If you'll continue, the \string\newpage\space will be ignored to
      avoid corruption of\MessageBreak
      every prior use of \string\BeforeClosingMainAux.
    }%
  }%
}
\newcommand*{\scr@restore@newpage}{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \begin{macro}{\scr@hook@bcma}
%   \changes{v2.95}{2002/09/03}{new (internal)}
% \begin{macro}{\scr@hook@acma}
%   \changes{v3.03}{2009/03/25}{new (internal)}
% We also need macros, that saves the commands at the hooks and are
% extendable using \cs{g@addto@macro}.
%    \begin{macrocode}
\newcommand*{\scr@hook@bcma}{}
\newcommand*{\scr@hook@acma}{}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
% Now we are able to write the user command. Here we also warn, if we detect
% one more \cs{newpage}\,---\,maybe at a \cs{clearpage} or
% \cs{cleardoublepage}.
%    \begin{macrocode}
\newcommand*{\BeforeClosingMainAux}{%
  \ifx\scr@hook@bcma\@empty
    \gdef\scr@hook@bcma{%
      \renewcommand*{\BeforeClosingMainAux}[1]{####1}%
      \let\protected@write\protected@immediate@write
      \scr@redefine@newpage
    }%
  \fi
  \g@addto@macro\scr@hook@bcma%
}
\newcommand*{\AfterReadingMainAux}{%
  \ifx\scr@hook@acma\@empty
    \gdef\scr@hook@acma{%
      \renewcommand*{\AfterReadingMainAux}[1]{####1}%
      \let\protected@write\protected@immediate@write
    }%
  \fi
  \g@addto@macro\scr@hook@acma%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\protected@immediate@write}
% Like \LaTeX{} kernel's |\protected@write| but using |\immediate\write|. In
% this case it is even not a good idea to protect |\thepage|!
%    \begin{macrocode}
\long\def\protected@immediate@write#1#2#3{%
  \begingroup
    #2%
    \let\protect\@unexpandable@protect
    \edef\reserved@a{\immediate\write#1{#3}}%
    \reserved@a
  \endgroup
  \if@nobreak\ifvmode\nobreak\fi\fi
}
%    \end{macrocode}
% \end{macro}
%
% \Finale
%
% \iffalse
%</scrlfile>
%<*load>
% Used at \KOMAScript{} classes.
%    \begin{macrocode}
\edef\@tempa{\noexpand\RequirePackage{scrlfile}[\scrlfileversion]}
\@tempa
%    \end{macrocode}
%</load>
% \fi
%
\endinput
%
% end of file `scrlfile.dtx'

%%% Local Variables:
%%% mode: doctex
%%% TeX-master: t
%%% End:
