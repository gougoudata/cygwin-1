% \CheckSum{1382}
% \iffalse meta-comment
% ======================================================================
% scrkbase.dtx
% Copyright (c) Markus Kohm, 2002-2012
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrkbase.dtx
% Copyright (c) Markus Kohm, 2002-2012
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse
%%% From File: scrkbase.dtx
%<*driver>
% \fi
\ProvidesFile{scrkbase.dtx}[2011/10/26 v3.10 KOMA-Script (basics)]
% \iffalse
%</driver>
%<package&option>\ProvidesPackage{%
%<package&option&base>  scrbase%
%<package&option&koma>  scrkbase%
%<package&option>}[%
%<package&option>  \KOMAScriptVersion\space package 
%<package&option&base>  (KOMA-Script-independent basics and keyval usage)]
%<package&option&koma>  (KOMA-Script-dependent basics and keyval usage)]
%<*driver>
\documentclass{scrdoc}
\usepackage[english,ngerman]{babel}
\usepackage[latin1]{inputenc}
\CodelineIndex
\RecordChanges
\GetFileInfo{scrkbase.dtx}
\title{\KOMAScript{} \partname\ \texttt{\filename}%
  \footnote{Dies ist Version \fileversion\ von Datei
    \texttt{\filename}.}}
\date{\filedate}
\author{Markus Kohm}

\begin{document}
  \maketitle
  \tableofcontents
  \DocInput{\filename}
\end{document}
%</driver>
% \fi
%
% \selectlanguage{ngerman}
%
% \changes{v1.0}{2002/07/06}{Beginn der ersten Version}
%
% \section{Grundlegenden \KOMAScript-Erweiterungen}
%
% Neue Versionen von \KOMAScript{} machen zunehmend Gebrauch vom
% \textsf{keyval}-Paket. Das \textsf{keyval}-Paket ist Bestandteil des
% \textsf{graphics}-Pakets und muss als solches auf allen
% \TeX-Systemen mit \LaTeX{} enthalten sein. Es genügt jedoch in
% einigen Punkten nicht den Anforderungen von \KOMAScript{}. Deshalb
% werden hier Erweiterungen vorgenommen, die von \KOMAScript-Klassen
% und \KOMAScript-Paketen verwendet werden können.
%
% Darüber hinaus werden immer mehr Teile von \KOMAScript{} von mehr als einem
% Paket oder von Paketen und Klassen verwendet. Diese grundlegenden Dinge
% wurden daher in zwei Pakete, \textsf{scrbase} (für Dinge, die auch von
% anderen Klassen und Paketen genutzt werden können) und \textsf{scrkbase}
% (für Dinge, die \KOMAScript vorbehalten bleiben), ausgegliedert. Dadurch
% werden die Pakete und Klassen selbst kleiner und die können trotzdem
% unabhängig voneinander verwendet werden. Selbstverständlich kann man dieses
% Paket auch ohne den Rest von \KOMAScript{} zum Einsatz bringen.
%
% \StopEventually{\PrintIndex\PrintChanges}
%
% \iffalse
%<*load>
% \fi
%
% \subsection{Laden des Pakets}
% Wer das Paket lädt, tut das allerdings in der Regel sogar bereits
% vor der Definition der Optionen mit:
%    \begin{macrocode}
\RequirePackage{scrkbase}[\KOMAScriptVersion]
%    \end{macrocode}
%
% \iffalse
%</load>
%<*option>
% \fi
%
% \subsection{\eTeX-Test}
% \changes{v3.02c}{2009/02/19}{Fehlermeldung, wenn nicht \eTeX{} verwendet
%   wird}
%
%    \begin{macrocode}
%<*base>
\begingroup
  \def\@tempb{}%
  \def\@tempa{%
    \PackageError{scrbase}{seems you are not running e-TeX\@tempb}{%
      Since 2004 the LaTeX team recommends to use e-TeX.\MessageBreak
      KOMA-Script since version 2.95 uses several e-TeX features.\MessageBreak
      At actual systems `latex' should already use e-TeX.\MessageBreak
      At deprecated systems it may be called `elatex'.\MessageBreak
      Use either unsupported KOMA-Script up to version 2.9u or\MessageBreak
      ask you administrator for LaTeX using e-TeX\@tempb.\MessageBreak
      Not using e-TeX\@tempb\space is a fatal error!\MessageBreak
      Processing cannot be continued!}%
    \endgroup
    \batchmode \errmessage{}\csname @@end\endcsname\end\relax
    \csname endinput\endcsname
  }%
  \expandafter\ifx\csname eTeXversion\endcsname\relax\else
    \ifnum\eTeXversion <2
      \def\@tempb{ V 2}%
    \else
      \let\@tempa\endgroup
    \fi
  \fi
\@tempa
%</base>
%    \end{macrocode}
%
% \subsection{Der abhängige Teil lädt den unabhängigen Teil}
%
%    \begin{macrocode}
%<koma>\RequirePackage{scrbase}[\KOMAScriptVersion]
%    \end{macrocode}
%
% \subsection{Laden von \textsf{keyval}}
%
% Hier wird nicht nur das Paket geladen, was ruckzuck mit:
%    \begin{macrocode}
%<base>\RequirePackage{keyval}
%    \end{macrocode}
% erledigt ist.
%
%
% \subsection{Test von Anweisungen}
%
% \begin{macro}{\scr@ifundefinedorrelax}
%   \changes{v2.95c}{2006/08/12}{neu (intern)}
%   \changes{v2.97b}{2007/03/08}{vermurkste Logik korrigiert}
%   \changes{v2.97c}{2007/04/18}{vermurkste Funktion korrigiert}
%   \changes{v2.97c}{2007/04/18}{von \cs{scr@ifundefined} umbenannt}
%   \changes{v3.02c}{2009/02/19}{Sonderbehandlung für nicht \eTeX entfernt}
% Dieses Makro arbeitet wie \cs{@ifundefined}, definiert dabei aber
% ein undefiniertes Makro nicht als \cs{relax}. Es muss bereits hier definiert
% werden, weil es gleich verwendet wird.
%    \begin{macrocode}
%<*base>
\newcommand{\scr@ifundefinedorrelax}[1]{%
  \ifcsname #1\endcsname
    \expandafter\ifx\csname #1\endcsname\relax
      \expandafter\expandafter\expandafter\@firstoftwo
    \else
      \expandafter\expandafter\expandafter\@secondoftwo
    \fi
  \else
    \expandafter\@firstoftwo
  \fi
}
%</base>
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{Definition von KOMA-\textsf{keyval}-Schlüsseln (Basis)}
%
% Üblicherweise verwendet \KOMAScript{} für alle
% \textsf{keyval}-Schlüssel die gleiche Bereichskennung
% "`\texttt{KOMA}"'. Dadurch ist es möglich, dass Pakete die Schlüssel
% der Klassen umdefinieren und dass jeder Teil von \KOMAScript{} die
% Schlüssel jedes anderen Teils ausführen kann -- sobald sie definiert
% sind.
%
% \begin{macro}{\DefineFamily}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% \begin{macro}{\DefineFamilyMember}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% \begin{macro}{\DefineFamilyKey}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% \begin{macro}{\scr@if@family}
%   \changes{v3.00}{2008/04/30}{Neu (intern)}
% \begin{macro}{\scr@if@familymember}
%   \changes{v3.00}{2008/04/30}{Neu (intern)}
% Familie, Familienmitglied und \textsf{keyval}-Schlüssel für ein
% Familienmitglied definieren. Dabei wird als Familienmitglied per Default der
% (Datei-)Name des aktuellen Pakets bzw. der aktuellen Klasse verwendet.
%    \begin{macrocode}
%<*base>
\newcommand*{\DefineFamily}[1]{%
  \scr@ifundefinedorrelax{#1@key@familylist}{%
    \@namedef{#1@key@familylist}{}%
  }{}%
}
\newcommand*{\scr@if@family}[2]{%
  \scr@ifundefinedorrelax{#1@key@familylist}{%
    \PackageError{scrbase}{%
      unknown family `#1'%
    }{%
      You've tried to #2 for family `#1'.\MessageBreak
      This my be done only for previous defined families.\MessageBreak
      You should call `\string\DefineFamily{#1}' first.%
    }%
  }%
}
\newcommand*{\DefineFamilyMember}[2][.\@currname.\@currext]{%
  \scr@if@family{#2}{define a family member}{%
    \edef\reserved@a{%
      \noexpand\in@{#2#1,}{\csname #2@key@familylist\endcsname}}%
    \reserved@a
    \ifin@\else
      \expandafter\edef\csname #2@key@familylist\endcsname{%
        \@nameuse{#2@key@familylist}#2#1,}%
    \fi
  }%
}
\newcommand*{\scr@if@familymember}[3]{%
  \scr@if@family{#2}{#3}{%
    \edef\reserved@a{%
      \noexpand\in@{#2#1,}{\csname #2@key@familylist\endcsname}}%
    \reserved@a
    \ifin@
      \expandafter\@firstofone
    \else
      \PackageError{scrbase}{%
        unknown member `#1' at family `#2'%
      }{%
        You've tried to #3 for member `#1' of family `#2'.\MessageBreak
        This my be done only for previous defined family members.\MessageBreak
        You should call `\string\DefineFamilyMember[{#1}]{#2}' first.%
      }%
      \expandafter\@gobble
    \fi
  }%
}
\newcommand*{\DefineFamilyKey}[2][.\@currname.\@currext]{%
  \scr@if@familymember{#1}{#2}{define a key}{%
    \define@key{#2#1}%
  }%
}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\KOMA@key}
%   \changes{v2.97c}{2007/04/19}{neues optionales Argument}
% \begin{macro}{\KOMA@key@familylist}
% \textsf{keyval}-Schlüssel für \KOMAScript{} werden mit \cs{KOMAkey}
% definiert, damit auch die Familie korrekt gesetzt und ggf. der Liste der
% Familien (\cs{KOMA@key@familylist}) hinzugefügt wird.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@key}[1][.\@currname.\@currext]{%
  \DefineFamilyMember{KOMA}%
  \DefineFamilyKey[#1]{KOMA}%
}
%</koma>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Optionen}
%
% Ab Version 2.97c sollen sowohl globale KOMA-Optionen als auch die
% KOMA-Optionen der jeweiligen Datei als auch die normalen Optionen in der
% Reihenfolge ausgeführt werden, in der sie angegeben wurden -- zuerst die
% globalen Optionen, dann die lokalen. Dabei werden nur die Optionen
% verwendet, die auch für das jeweilige Paket bzw. die jeweilige Klasse
% definiert wurden.
%
% \begin{macro}{\@globaloptionslist}
%   \changes{v2.96}{2006/11/26}{new}
%   \changes{v2.96}{2006/11/26}{Klassenoptionen durchsuchen}
% Die Lister der globalen Optionen wird teilweise benötigt. Weil
% \textsl{xkeyval} dämlicherweise glaubt, es müsse alle Optionen mit
% Gleichheitszeichen aus der Liste der Klassenoptionen entfernen
% (seltsamerweise aber nicht die (x)keyval-Optionen, die ohne Wert aufgerufen
% werden, weil ihr Defaultwert verwendet werden soll), wird hier ein eigenes
% Makro definiert.
%    \begin{macrocode}
%<*base>
\newcommand*{\@globaloptionslist}{}
\let\@globaloptionslist\@classoptionslist
\scr@ifundefinedorrelax{XKV@classoptionslist}{}{%
  \ifx\XKV@classoptionslist\@empty\else
    \let\@globaloptionslist\XKV@classoptionslist
  \fi
}
%</base>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FamilyProcessOptions}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}%
% \begin{macro}{\scr@removeunused}
%   \changes{v3.10}{2011/09/12}{neu (intern)}%
%   Diese Anweisung führt alle Optionen, sowohl normal deklarierte als auch
%   \textsf{keyval}-Optionen für eine angegebene Familie (2. Argument) und das
%   aktuelle Mitglied (1. optionales Argument) in der Reihenfolge, in der sie
%   verwendet wurden aus -- zuerst globale Optionen, dann lokale Optionen. Das
%   entspricht der Verwendung von \cs{ProcessOptions*} mit dem Unterschied,
%   dass eben auch die \textsf{keyval}-Optionen abgearbeitet
%   werden. \textsf{keyval}-Optionen, die keinem Mitglied zugeordnet, sondern
%   universell sind, werden dabei vor gleichnamigen \textsf{keyval}-Optionen
%   des aktuellen Mitglieds ausgeführt.
%    \begin{macrocode}
%<*base>
\newcommand*{\scr@removeunused}{}
\newcommand*{\FamilyProcessOptions}[2][.\@currname.\@currext]{%
  \let\ds@\@empty
  \edef\@curroptions{\@ptionlist{\@currname.\@currext}}%
  \ifx\@currext\@clsextension\else
    \@for\CurrentOption:=\@globaloptionslist\do{%
      \ifx\CurrentOption\@empty\else
        \@expandtwoargs\in@{,\CurrentOption,}{,\@declaredoptions,}%
        \ifin@
          \@use@ption
          \expandafter\let\csname ds@\CurrentOption\endcsname\@empty
        \else
          \expandafter\def\expandafter\scr@removeunused\expandafter{%
            \expandafter\def\expandafter\CurrentOption\expandafter{%
              \CurrentOption}\@use@ption}%
          \scr@optiontest{#2}\CurrentOption{}{%
            \@expandtwoargs\setkeys{#2}%
            \CurrentOption
            \scr@removeunused
          }%
          \scr@optiontest{#2#1}\CurrentOption{}{%
            \@expandtwoargs\setkeys{#2#1}%
            \CurrentOption
            \scr@removeunused
          }%
          \let\scr@removeunused\@empty
        \fi
      \fi
    }%
  \fi
  \@for\CurrentOption:=\@curroptions\do{%
    \@use@ption
    \scr@ifundefinedorrelax{ds@\CurrentOption}{%
      \scr@optiontest{#2}\CurrentOption{%
        \scr@optiontest{#2#1}\CurrentOption{%
          \default@ds
        }{%
          \edef\reserved@a{%
            \noexpand\setkeys{#2#1}{\CurrentOption}%
            \noexpand\def\noexpand\CurrentOption{\CurrentOption}%
          }\reserved@a
        }%
      }{%
        \@expandtwoargs\setkeys{#2}%
        \CurrentOption
        \scr@optiontest{#2#1}\CurrentOption{}{%
          \@expandtwoargs\setkeys{#2#1}%
          \CurrentOption
        }%
      }%
    }{%
    }%
  }%
  \@for\CurrentOption:=\@declaredoptions\do{%
    \expandafter\let\csname ds@\CurrentOption\endcsname\relax}%
  \let\CurrentOption\@empty
  \let\@fileswith@pti@ns\@@fileswith@pti@ns
  \AtEndOfPackage{\let\@unprocessedoptions\relax}%
}
\@onlypreamble\FamilyProcessOptions
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\scr@optiontest}
%   \changes{v2.97c}{2007/04/18}{neu (intern)}%
% \begin{macro}{\scr@pti@ntest}
%   \changes{v2.97c}{2007/04/18}{neu (intern)}%
%   Es werden zwei interne Makros benötigt, um zu testen, ob eine
%   entsprechende keyval-Option definiert ist. Grund der Übung ist, dass
%   sowohl das Familienargument als auch die Option selbst expandiert werden
%   muss.
%    \begin{macrocode}
\newcommand*{\scr@optiontest}[2]{%
  \edef\reserved@a{\noexpand\scr@pti@ntest{#1}#2=\noexpand\@nil}%
  \reserved@a
}
\newcommand*{\scr@pti@ntest}{}
\def\scr@pti@ntest#1#2=#3\@nil{\scr@ifundefinedorrelax{KV@#1@#2}}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\KOMAProcessOptions}
%   \changes{v2.97c}{2007/04/18}{neu}%
%   \changes{v3.00}{2008/04/30}{kein optionales Argument mehr}%
%   Diese Anweisung führt alle Optionen, sowohl normal deklarierte als auch
%   keyval-Optionen eines Pakets bzw. einer Klasse in der Reihenfolge, in der
%   sie verwendet wurden aus -- zuerst globale Optionen, dann lokale
%   Optionen. Das entspricht der Verwendung von \cs{ProcessOptions*} mit dem
%   Unterschied, dass eben auch die keyval-Optionen abgearbeitet
%   werden. keyval-Optionen, die keiner einzelnen Klasse und keinem einzelnen
%   Paket zugeordnet werden, werden dabei vor gleichnamigen eigenen
%   keyval-Optionen ausgeführt.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMAProcessOptions}{\FamilyProcessOptions{KOMA}}
\@onlypreamble\KOMAProcessOptions
%</koma>
%    \end{macrocode}
% \end{macro}
%
% \begin{option}{internalonly}
%   \changes{v2.96}{2006/11/26}{neu}
%   \changes{v2.97c}{2007/06/20}{geht auch ohne Argument}
% \begin{macro}{\dont@let@as@internal@defined}
%   \changes{v2.96}{2006/11/26}{neu (intern)}
% Anweisungen, die mit einem internen und einem Anwendername vorhanden sind,
% können vor dem Anwender optional verborgen werden. Wird kein Argument
% angegeben, so werden alle Anweisungen verborgen.
%    \begin{macrocode}
%<*base>
\newcommand*{\dont@let@as@internal@defined}{/}
\newif\if@let@as@internalonly@defined\@let@as@internalonly@definedfalse
\DefineFamily{KOMA}
\DefineFamilyMember{KOMA}
\DefineFamilyKey{KOMA}{internalonly}[\relax]{%
  \ifx\relax#1\relax
    \@let@as@internalonly@definedtrue
  \else
    \@let@as@internalonly@definedfalse
    \begingroup
      \@expandtwoargs\in@{#1}\dont@let@as@internal@defined
    \expandafter\endgroup
    \ifin@\else\g@addto@macro\dont@let@as@internal@defined{#1/}\fi
  \fi
}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{option}
%
% \changes{v2.96}{2006/08/20}{Optionen werden abgearbeitet}
% \changes{v2.97c}{2007/04/18}{Optionen werden mit \cs{KOMAProcessOptions}
%   abgearbeitet}
%    \begin{macrocode}
%<koma>\KOMAProcessOptions\relax
%<base>\FamilyProcessOptions{KOMA}\relax
%    \end{macrocode}
%
% \iffalse
%</option>
%<*body>
% \fi
%
% \subsection{Ein wenig zusätzliche Mathematik für \eTeX}
%
% \begin{macro}{\XdivY}
%   \changes{v3.05a}{2010/03/10}{Neu}
% Ergebnis ist erster Argument durch zweites abgerundet auf die nächst
% kleinere ganze Zahl.
%    \begin{macrocode}
%<*base>
\newcommand*{\XdivY}[2]{%
  \numexpr ( #1 + #2 / 2 ) / #2 - 1\relax
}
%</base>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\XmodY}
%   \changes{v3.05a}{2010/03/10}{Neu}
% Ergebnis ist erstes Argument modulo zweites Argument.
%    \begin{macrocode}
%<*base>
\newcommand*{\XmodY}[2]{%
  \numexpr #1 - #2 * \XdivY{#1}{#2}\relax
}
%</base>
%    \end{macrocode}
% \end{macro}
%
% \subsection{Häufig benötigte Befehle}
%
%  \begin{macro}{\if@atdocument}
%    \changes{v2.95}{2002/12/05}{neuer Schalter}
%  \begin{macro}{\@atdocumenttrue}
%  \begin{macro}{\@atdocumentfalse}
% Dieser Schalter wird bei \cs{begin}\texttt{\{document\}} wahr. Er
% wird von \KOMAScript{} für Befehle verwendet, die sich
% unterschiedlich verhalten, je nachdem, ob sie in der Präambel oder
% danach aufgerufen werden.
%    \begin{macrocode}
%<*base>
\newif\if@atdocument
\AtBeginDocument{\@atdocumenttrue}
\@onlypreamble\@atdocumentrue
\@onlypreamble\@atdocumentfalse
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\let@as@internal@defined}
%   \changes{v2.95}{2002/08/19}{neu (intern)}
%   \changes{v2.95c}{2006/08/12}{Warnung bei Umdefinierung}
%   \changes{v2.96}{2006/11/26}{Herausreichen von internen Makros als
%     Benutzermakros kann verhindert werden}
%   \changes{v2.97c}{2007/06/20}{Herausreichen von internen Makros kann
%     generell verhindert werden}
%   \changes{v3.10}{2010/10/26}{\cs{ignorespaces} beim \cs{document}-Patch
%     ergänzt} 
% Dieses Makro wird intern verwendet, um dokumentierte Makros mit der
% Definition von internen Makros zu versehen, falls sie nicht bereits
% definiert oder als nicht zu definieren markiert sind. Der Name des
% dokumentierten Makros wird als Parameter übergeben. Dies wird gleich
% benötigt.
%    \begin{macrocode}
%<*base>
\newcommand*{\let@as@internal@defined}[1]{%
  \begingroup
    \if@let@as@internalonly@defined
      \in@true
    \else
      \@expandtwoargs\in@{/#1/}\dont@let@as@internal@defined
    \fi
  \expandafter\endgroup
  \ifin@
    \PackageInfo{%
      scrbase%
    }{%
      \expandafter\string\csname #1\endcsname\space excluded from being
      defined%
    }%
  \else
    \@ifundefined{#1}{%
      \begingroup
        \expandafter\def\expandafter\@tempa
          \expandafter{\csname scr@#1\endcsname}
        \expandafter\def\expandafter\@tempb
          \expandafter{\csname #1\endcsname}
      \expandafter\expandafter\expandafter\endgroup
      \expandafter\expandafter\expandafter\let\expandafter\@tempb\@tempa
      \if@atdocument\else
        \g@addto@macro\document{%
          \expandafter\ifx\csname #1\expandafter\endcsname
          \csname scr@#1\endcsname
          \else
            \PackageWarning{scrbase}{%
              \expandafter\string\csname #1\endcsname\space was
              redefined\MessageBreak
              at the document preamble.\MessageBreak
              If you did not redefine it by yourself, have a\MessageBreak
              a look at the description of this command at\MessageBreak
              the manual of every package you are using\@gobble
            }%
          \fi
          \ignorespaces
        }%
      \fi
    }{%
      \PackageInfo{%
        scrbase%
      }{%
        \expandafter\string\csname #1\endcsname\space already
        defined.\MessageBreak
        If \expandafter\string\csname #1\endcsname\space does not behave
        like\MessageBreak
        it was described at the KOMA-Script manual, try to\MessageBreak
        load `scrbase.sty' earlier or find out at which\MessageBreak
        package or class \expandafter\string\csname #1\endcsname\space
        was defined before\@gobble
      }%
    }%
  \fi
}
%</base>
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifundefinedorrelax}
%    \changes{v2.95}{2002/08/21}{neu}
%    \changes{v2.95c}{2006/08/12}{über interne Anweisung definiert}
%    \changes{v2.97c}{2007/06/20}{umbenannt von \cs{ifundefined}}
% Dieses Makro arbeitet wie \cs{@ifundefined}, definiert dabei aber
% ein undefiniertes Makro nicht als \cs{relax}.
%    \begin{macrocode}
%<*base>
\let@as@internal@defined{ifundefinedorrelax}
%</base>
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\ifnotundefined}
%   \changes{v2.95}{2002/08/21}{neu}
%   \changes{v2.95c}{2006/08/12}{nutzt \eTeX{} wenn möglich}
%   \changes{v3.02c}{2009/02/19}{\eTeX{} ist zwingend}
% Dieses Makro arbeitet genau umgekehrt zu \cs{ifundefined}. Manchmal
% ist es ganz nützlich, auch das zu haben. Dieses Makro heißt nicht
% \cs{ifdefined}, weil \eTeX\ bereits ein solches Primitiv bietet.
%    \begin{macrocode}
%<*base>
\newcommand{\ifnotundefined}[1]{%
  \ifcsname #1\endcsname
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
}
%</base>
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifstr}
%    \changes{v2.95}{2004/07/20}{if- und then-Teil werden nicht gefressen}
%    \changes{v3.04b}{2010/01/29}{\cs{edef} durch \cs{protected@edef} ersetzt}
% Dieses Makro vergleicht zwei Tokenfolgen. Eigentlich müsste es also
% eher \cs{ifequal} oder ähnlich heißen.
%    \begin{macrocode}
%<*base>
\newcommand\ifstr[2]{%
  \begingroup\protected@edef\@tempa{#1}\protected@edef\@tempb{#2}%
  \ifx\@tempa\@tempb
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%</base>
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifnumber}
% Dieses Makro testet, ob ein übergebener Parameter eine positive,
% ganze Zahl ist. Ist dies der Fall, wird der zweite Parameter
% ausgeführt, sonst der dritte.
%    \begin{macrocode}
%<*base>
\newcommand\ifnumber[1]{%
  \begingroup\@tempswafalse\let\scr@next\test@number
  \expandafter\scr@next#1\scr@next
  \if@tempswa
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \begin{macro}{\test@number}
% Für den eigentlichen Test wird der erste Parameter Token für Token
% gescannt und beurteilt.
%    \begin{macrocode}
\newcommand*{\test@number}[1]{%
  \ifx \scr@next#1
    \let\scr@next\relax
  \else
%    \end{macrocode}
% Dabei wird für einen schnelleren Vergleich die Tatsache genutzt, dass
% Ziffernzeichen immer im selben durchgängigen Bereich liegen
%    \begin{macrocode}
    \@tempcnta=\expandafter\expandafter\expandafter\number
    \expandafter`#1\relax
    \ifnum \@tempcnta>47
      \ifnum \@tempcnta<58
        \@tempswatrue
      \else\@tempswafalse\fi
    \else\@tempswafalse\fi
%    \end{macrocode}
% Das zeichenweise Scannen und Parsen kann natürlich nicht einfach
% abgebrochen werden. Stattdessen ist der Parameterrest noch zu
%  entfernen.
%    \begin{macrocode}
    \if@tempswa\else\let\scr@next\gobble@till@scr@next\fi
  \fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\gobble@tillscr@@next}
% Das geschieht mit einem einzigen "`Leermacro"'.
%    \begin{macrocode}
\newcommand*{\gobble@till@scr@next}{}
\def\gobble@till@scr@next#1\scr@next{}
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifdimen}
% Dieses Makro testet, ob ein übergebener Parameter eine Dimension
% ist und führt in Abhängigkeit davon den zweiten oder dritten
% Parameter aus.
%    \begin{macrocode}
%<*base>
\newcommand{\ifdimen}[1]{%
  \begingroup\@tempswatrue\let\scr@next\test@posdimen
  \expandafter\test@dimen#1\scr@next
  \if@tempswa
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \begin{macro}{\test@dimen}
% Als erste muss ein Vorzeichen entfernt werden.
%    \begin{macrocode}
\newcommand*{\test@dimen}[1]{%
  \ifx -#1\else\ifx +#1\else
      \def\scr@next{\let\scr@next\test@posdimen\scr@next#1}\fi\fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\test@posdimen}
% Dann muss getestet werden, ob es sich beim Rest um eine Dimension
% handelt. Dabei werden der Einfachheit halber mehrere Dezimalkomma
% und -punkte erlaubt. Natürlich könnte man es auch wirklich richtig
% machen, aber das wäre nochmal etwas aufwendiger. Ist das wirklich
% notwendig? 
%    \begin{macrocode}
\newcommand*{\test@posdimen}[1]{%
  \ifx \scr@next#1%
    \@tempswafalse\let\scr@next\relax
  \else
    \if .#1\else\if ,#1\else
        \@tempcnta=%
        \expandafter\expandafter\expandafter\number\expandafter`#1\relax
        \ifnum \@tempcnta>47
          \ifnum \@tempcnta<58
          \else\def\scr@next{\test@dimunt#1}\fi
        \else\def\scr@next{\test@dimunt#1}\fi
    \fi\fi
  \fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\testdimunt}
%  \begin{macro}{\test@trueunt}
% Außer einer Gleitkomma- bzw. Gleitpunktzahl muss auch noch die Einheit
% behandelt werden. Dabei sind sowohl die neun Standardeinheiten als auch
% deren "`true"'-Variante zu berücksichtigen. Deshalb wird zuerst ein
% eventuelles "`\texttt{true}"' weggeworfen.
%    \begin{macrocode}
\newcommand*{\test@dimunt}{}
\def\test@dimunt#1\scr@next{%
  \expandafter\test@trueunt#1truetrue\test@trueunt
}
\newcommand*{\test@trueunt}{}
\def\test@trueunt#1true#2true#3\test@trueunt{%
  \edef\@tempa{#1}
  \ifx\@tempa\@empty\test@@ifdimunt{#2}\else\test@@ifdimunt{#1}\fi
}
%    \end{macrocode}
%  \begin{macro}{\test@@ifdimunt}
% Anschließend wird dann getestet, ob es sich um eine der neun üblichen
% Einheiten handelt.
%    \begin{macrocode}
\newcommand*\test@@ifdimunt[1]{%
  \@tempswafalse
  \ifstr{#1}{pt}{\@tempswatrue}{%
    \ifstr{#1}{pc}{\@tempswatrue}{%
      \ifstr{#1}{in}{\@tempswatrue}{%
        \ifstr{#1}{bp}{\@tempswatrue}{%
          \ifstr{#1}{cm}{\@tempswatrue}{%
            \ifstr{#1}{mm}{\@tempswatrue}{%
              \ifstr{#1}{dd}{\@tempswatrue}{%
                \ifstr{#1}{cc}{\@tempswatrue}{%
                  \ifstr{#1}{sp}{\@tempswatrue}{}%
                }%
              }%
            }%
          }%
        }%
      }%
    }%
  }%
}
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\ifpdftex}
%    \changes{v2.95}{2002/08/19}{neu}
%  \begin{macro}{\scr@ifpdftex}
%    \changes{v2.95}{2002/08/19}{neu (intern)}
% If-then-else-Konstrukt, um zu testen, ob pdf\TeX{} verwendet wird.
%    \begin{macrocode}
%<*base>
\newcommand{\scr@ifpdftex}{\ifnotundefined{pdftexversion}}
\let@as@internal@defined{ifpdftex}
\BeforePackage{pdfcprot}{\let\ifpdftex\relax}
\AfterPackage{pdfcprot}{\let@as@internal@defined{ifpdftex}}
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  
% \begin{macro}{\ifVTeX}
%   \changes{v2.95}{2002/08/19}{neu}
%   \changes{v2.97c}{2007/06/20}{umdefiniert von \cs{ifvtex}}
% \begin{macro}{\scr@ifVTeX}
%   \changes{v2.95}{2002/08/19}{neu}
%   \changes{v2.97c}{2007/06/20}{umdefiniert von \cs{scr@ifvtex}}
% If-then-else-Konstrukt, um zu testen, ob V\TeX{} verwendet wird.
%    \begin{macrocode}
%<*base>
\newcommand{\scr@ifVTeX}{\ifnotundefined{VTeXversion}}
\let@as@internal@defined{ifVTeX}
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifpdfoutput}
%    \changes{v2.7g}{2001/04/17}{neu}
%    \changes{v2.8q}{2001/10/19}{\cs{pdfoutput} wird nicht mehr zu
%      \cs{relax}, wenn zuvor undefiniert}
%    \changes{v2.8q}{2001/10/19}{darf bereits definiert sein}
%    \changes{v2.8q}{2001/10/19}{Verwendung von \cs{scr@ifpdfoutput}}
%  \begin{macro}{\scr@ifpdfoutput}
%    \changes{v2.8q}{2001/10/19}{neu (intern)}
%    \changes{v2.8q}{2001/11/13}{funktioniert}
%    \changes{v2.95}{2002/08/21}{berücksichtigt V\TeX}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob als \texttt{pdf}
% ausgegeben wird oder nicht, Befehle auszuführen. Dieses Makro wird
% für die Deklaration der Option \texttt{pagesize} benötigt.
%    \begin{macrocode}
%<*base>
\newcommand{\scr@ifpdfoutput}{%
  \scr@ifundefinedorrelax{pdfoutput}{%
    \scr@ifundefinedorrelax{OpMode}{%
      \expandafter\@secondoftwo%
    }{%
      \ifnum\OpMode=1
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }%
  }{%
    \ifnum\pdfoutput>0 
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}%
\let@as@internal@defined{ifpdfoutput}
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifpsoutput}
%    \changes{v2.95}{2002/08/21}{neu}
%  \begin{macro}{\scr@ifpsoutput}
%    \changes{v2.95}{2002/08/21}{neu (intern)}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob früher oder später
% \texttt{ps} ausgegeben wird oder nicht, Befehle auszuführen.
%    \begin{macrocode}
%<*base>
\newcommand*{\scr@ifpsoutput}{%
  \ifnotundefined{if@dvips}{%
    \if@dvips 
      \expandafter\@firstoftwo
    \else 
      \expandafter\@secondoftwo
    \fi
  }{%
    \ifnotundefined{OpMode}{%
      \ifnum\OpMode=2
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }{%
      \expandafter\@secondoftwo
    }%
  }%
}
\let@as@internal@defined{ifpsoutput}
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifdvioutput}
%    \changes{v2.95}{2002/08/21}{neu}
%  \begin{macro}{\scr@ifdvioutput}
%    \changes{v2.95}{2002/08/21}{neu (intern)}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob \texttt{dvi}
% ausgegeben wird oder nicht, Befehle auszuführen.
%    \begin{macrocode}
%<*base>
\newcommand*{\scr@ifdvioutput}{%
  \scr@ifundefinedorrelax{pdfoutput}{%
    \scr@ifundefinedorrelax{OpMode}{%
      \expandafter\@firstoftwo
    }{%
      \ifnum\OpMode=0
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }%
  }{%
    \ifnum\pdfoutput=0
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}
\let@as@internal@defined{ifdvioutput}
%</base>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\scr@smashdp}
%   \changes{v2.97c}{2007/09/17}{neu (intern)}
%   \changes{v3.02a}{2009/01/23}{\cs{smash} nicht direkt verwenden, weil
%     \textsf{amsmath} das inkompatibel umdefiniert}
% Gibt Material aus, erzeugt dabei aber nur Höhe und Breite, jedoch keine
% Tiefe.
%    \begin{macrocode}
%<*base>
\newcommand*{\scr@smashdp}[1]{%
  \begingroup
    \def\finsm@sh{\dp\z@\z@\box\z@}%
    \ifmmode
      \expandafter\mathpalette\expandafter\mathsm@sh
    \else
      \expandafter\makesm@sh
    \fi
    {#1}%
  \endgroup
}
%</base>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\PackageInfoNoLine}
%   \changes{v2.97d}{2007/10/03}{neu}
% Arbeitet wie \cs{PackageInfo} aber ohne Ausgabe der Zeilennummer.
%    \begin{macrocode}
%<*base>
\providecommand*{\PackageInfoNoLine}[2]{%
  \PackageInfo{#1}{#2\@gobble}%
}
%</base>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ClassInfoNoLine}
%   \changes{v2.98c}{2008/02/15}{neu}
% Arbeitet wie \cs{ClassInfo} aber ohne Ausgabe der Zeilennummer.
%    \begin{macrocode}
%<*base>
\providecommand*{\ClassInfoNoLine}[2]{%
  \ClassInfo{#1}{#2\@gobble}%
}
%</base>
%    \end{macrocode}
% \end{macro}
%
% \subsection{Definition von KOMA-\textsf{keyval}-Schlüsseln (Hauptteil)}
%
% \begin{macro}{\FamilyExecuteOptions}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
%   \changes{v3.04b}{2010/01/29}{\cs{edef} durch \cs{protected@edef} ersetzt}
%   \changes{v3.04b}{2010/02/02}{\cs{scr@key@atlist} und \cs{scr@key@name}
%     vor Überschreiben in \cs{serkeys} geschützt}
% Entspriche \cs{ExecuteOptions} jedoch \textsf{keyval}-Optionen.
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyExecuteOptions}[3][.\@currname.\@currext]{%
  \def\reserved@a##1\@nil{%
    \@for\scr@key@atlist:=#3\do{%
      \expandafter\scr@key@split@name@value\scr@key@atlist==\@nil
      \scr@ifundefinedorrelax{KV@#2@\scr@key@name}{}{%
        \protected@edef\reserved@a{\noexpand\setkeys{#2}{\scr@key@atlist}%
          \noexpand\def\noexpand\scr@key@atlist{\scr@key@atlist}%
          \noexpand\def\noexpand\scr@key@name{\scr@key@name}%
        }%
        \reserved@a
      }%
      \scr@ifundefinedorrelax{KV@#2#1@\scr@key@name}{}{%
        \protected@edef\reserved@a{%
          \noexpand\setkeys{#2#1}{\scr@key@atlist}%
          \noexpand\def\noexpand\scr@key@atlist{\scr@key@atlist}%
          \noexpand\def\noexpand\scr@key@name{\scr@key@name}%
        }%
        \reserved@a
      }%
      \let\CurrentOption\scr@key@atlist
      \csname ds@\CurrentOption\endcsname
    }%
    \edef\CurrentOption{##1}%
  }%
  \expandafter\reserved@a\CurrentOption\@nil
}
\@onlypreamble\FamilyExecuteOptions
%</base>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KOMAExecuteOptions}
%   \changes{v2.97c}{2007/04/19}{Neue Anweisung}
%   \changes{v3.00}{2008/04/30}{Kein optionales Argument mehr}
% Liste von Optionen ausführen
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMAExecuteOptions}{\FamilyExecuteOptions{KOMA}}
\@onlypreamble\KOMAExecuteOptions
%</koma>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FamilyOptions}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% Es werden Schlüssel einer Familie verwendet. Existiert ein Schlüssel nicht,
% so wird eine Fehlermeldung ausgegeben.
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyOptions}[2]{%
  \Family@Options{#1}{#2}{%
    \PackageError{scrbase}{%
      option `\scr@key@name' unknown at family `#1'%
    }{%
      You have used \string\FamilyOptions{#1} to set
      `\scr@key@atlist',\MessageBreak
      but family `#1' does not know any option named
      `\scr@key@name'.\MessageBreak
      See the manual for the package or class using family `#1' for
      more\MessageBreak
      informations about options and their values.%
    }%
  }%
}
% \begin{macro}{\Family@Options}
%   \changes{v3.00}{2008/04/30}{Neues Makro (intern)}%
%   Das interne Macro \cs{Family@Options} macht die eigentliche Arbeit. Das
%   erste Argument ist dabei die Familie. Das zweite Argument ist die Liste
%   der Optionen, das zweite Code, der im Fehlerfall ausgeführt werden
%   soll. Dabei sind die Makros \cs{scr@key@atlist}, \cs{scr@key@name} und
%   \cs{scr@key@value} gültig und können verwendet werden.
%
%   Anmerkung: Es wird nicht auf \textsf{xkeyval} und den dortigen Befehl
%   \cs{setkeys+} gesetzt, weil dieser die Optionen nicht in der Reihenfolge
%   der Optionen, sondern in der Reihenfolge der Familien ausführt. Das passt
%   mir aber hier gar nicht.
%
%   In einer Schleife über alle Optionen werden die Optionen zunächst in
%   Option und Wert aufgespaltet.
%    \begin{macrocode}
\newcommand*{\Family@Options}[3]{%
  \@for\scr@key@atlist:=#2\do{%
%    \end{macrocode}
%   \changes{v3.08}{2010/11/05}{leere Argumente in der Optionenliste}%
%   Auf vielfachen Wunsch und entgegen meiner Überzeugung, sind auch leere
%   Argumente in der Optionenliste erlaubt. Die erste Form wäre, wenn zwei
%   Kommas diret aufeinander folgen:
%    \begin{macrocode}
    \ifx\scr@key@atlist\@empty\else
%    \end{macrocode}
%   Die zweite Möglichkeit wäre, dass noch Leerzeichen zwischen den Komma
%   übrig bleiben:
%    \begin{macrocode}
      \ifx\scr@key@atlist\space\else
        \expandafter\scr@key@split@name@value\scr@key@atlist==\@nil
%    \end{macrocode}
%   Die dritte Möglichkeit, dass auch noch ein Gleichheitszeichen übrig
%   gelassen wurde, werde ich aber nicht abfangen. Irgendwann müssen die
%   Anwender auch mal ihre Fehler einsehen und korrigieren!
%
%   Dann wird in einer Schleife über alle Familien festgestellt, ob die Option
%   in einer Familie bekannt ist und ggf. ausgeführt.
%   \changes{v3.04b}{2010/01/29}{\cs{edef} durch \cs{protected@edef} ersetzt}
%   \changes{v3.09a}{2011/06/07}{weniger Expansion durch sinnvollen Gebrauch
%     von \cs{unexpanded}}
%    \begin{macrocode}
        \scr@key@found@false
        \edef\@tempa{\csname #1@key@familylist\endcsname}%
        \@for\@tempa:=\@tempa\do{%
          \scr@ifundefinedorrelax{KV@\@tempa @\scr@key@name}{}{%
            \scr@key@found@true
            \protected@edef\reserved@a{%
              \noexpand\setkeys{\@tempa}{%
                \unexpanded\expandafter{\scr@key@atlist}}%
              \noexpand\def\noexpand\@tempa{%
                \unexpanded\expandafter{\@tempa}}%
              \noexpand\def\noexpand\scr@key@atlist{%
                \unexpanded\expandafter{\scr@key@atlist}}%
              \noexpand\def\noexpand\scr@key@name{%
                \unexpanded\expandafter{\scr@key@name}}%
              \noexpand\def\noexpand\scr@key@value{%
                \unexpanded\expandafter{\scr@key@value}}%
            }%
            \reserved@a
          }%
        }%
        \ifscr@key@found@\else#3\fi
      \fi
    \fi
  }%
}
%    \end{macrocode}
% \begin{macro}{\ifscr@key@found@}
%   \changes{v2.97c}{2007/04/19}{Neuer Schalter (intern)}
%   \changes{v3.00}{2008/04/30}{umbenannt von \cs{ifKOMA@key@found}}
% \begin{macro}{\scr@key@atlist}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
%   \changes{v3.00}{2008/04/30}{umbenannt von \cs{KOMA@key@atlist}}
% \begin{macro}{\scr@key@name}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
%   \changes{v3.00}{2008/04/30}{umbenannt von \cs{KOMA@key@name}}
% \begin{macro}{\scr@key@value}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
%   \changes{v3.00}{2008/04/30}{umbenannt von \cs{KOMA@key@value}}
% \begin{macro}{\scr@key@split@name@value}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
%   \changes{v2.97e}{2007/11/10}{verwendet \cs{KV@@sp@def} zur Entsorgung von
%     Leerzeichen}
%   \changes{v3.00}{2008/04/30}{umbenannt von \cs{KOMA@key@split@name@value}}
%    \begin{macrocode}
\newif\ifscr@key@found@
\newcommand*{\scr@key@atlist}{}
\newcommand*{\scr@key@name}{}
\newcommand*{\scr@key@value}{}
\newcommand*{\scr@key@split@name@value}{}
\def\scr@key@split@name@value#1=#2=#3\@nil{%
  \KV@@sp@def\scr@key@name{#1}%
  \KV@@sp@def\scr@key@value{#2}%
}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\FamilyOption}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% \begin{macro}{\Family@Option}
%   \changes{v3.00}{2008/04/30}{Neu (intern)}
%   \changes{v3.04b}{2010/01/29}{\cs{edef} durch \cs{protected@edef} ersetzt}
% Im Gegensatz zu \cs{FamilyOptions} kann man mit dieser Anweisung nur eine
% einzige Option setzen. Dafür kann man gleich mehrere durch Komma getrennte
% Argumente für diese Option setzen. Das erste obligatorische Argument ist
% wieder die Familie, das zweite obligatorische Argument ist die Option, das
% dritte, obligatorische Argument ist die Liste der Werte für diese Option.
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyOption}[3]{%
  \Family@Option{#1}{#2}{#3}{%
    \PackageError{scrbase}{%
      unknown option `\scr@key@name' for familie `#1'%
    }{%
      You have used \string\FamilyOption{#1} to set
      `\scr@key@name',\MessageBreak
      but family '#1' does not know any option named
      `\scr@key@name'.\MessageBreak
      See the the manual of the class or package, that provides
      family\MessageBreak
      `#1' for more informations about options and their values.%
    }%
  }%
}
\newcommand*{\Family@Option}[4]{%
  \expandafter\KV@@sp@def\expandafter\scr@key@name\expandafter{#2}%
  \scr@key@found@false
  \edef\@tempa{\csname #1@key@familylist\endcsname}%
  \@for\@tempa:=\@tempa\do{%
    \scr@ifundefinedorrelax{KV@\@tempa @\scr@key@name}{}{%
      \scr@key@found@true
      \let\@tempb\@tempa
    }%
  }%
  \ifscr@key@found@
    \let\reserved@a\@empty
    \@for\@tempa:=#3\do{%
      \expandafter\KV@@sp@def\expandafter\@tempa\expandafter{\@tempa}%
%    \end{macrocode}
%   \changes{v3.08}{2010/11/05}{leere Argumente in der Werteliste}
%   Auf vielfachen Wunsch und entgegen meiner Überzeugung, sind auch leere
%   Argumente in der Werteliste erlaubt:
%    \begin{macrocode}
      \ifx\@tempa\@empty\else
        \protected@edef\reserved@a{\reserved@a,\scr@key@name=\@tempa}%
      \fi
    }%
    \ifx\reserved@a\@empty
      \protected@edef\reserved@a{\noexpand\setkeys{\@tempb}{\scr@key@name}}%
    \else
      \protected@edef\reserved@a{%
        \noexpand\setkeys{\@tempb}{\expandafter\@gobble\reserved@a}}%
    \fi
    \reserved@a
  \else
    #4
  \fi
}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\KOMAoptions}
%   \changes{v2.96}{2006/08/20}{Neuer Hook nach den Optionen}
%   \changes{v2.97c}{2007/04/19}{Optionen aller KOMA-Familien abarbeiten}
% Es werden Schlüssel verwendet und ggf. danach noch Dinge ausgeführt.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMAoptions}[1]{%
  \let\post@kopt@hook\@empty
  \KOMA@options{#1}{%
%    \end{macrocode}
% Wenn der Schlüssel für keines der bekannten Familienmitglieder definiert
% ist, wird ein Fehler ausgegeben.
%    \begin{macrocode}
    \PackageError{scrkbase}{%
      unknown KOMA option `\scr@key@name'%
    }{%
      You have used \string\KOMAoptions\space to set
      `\scr@key@atlist',\MessageBreak
      but KOMA-Script does not know any option named
      `\scr@key@name'.\MessageBreak
      See the KOMA-Script manual for more informations about options
      and\MessageBreak
      their values.%
    }%
  }%
  \post@kopt@hook\let\post@kopt@hook\relax
}
%    \end{macrocode}
% \begin{macro}{\KOMA@options}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
% Das interne Macro \cs{KOMA@options} macht die eigentliche Arbeit. Das erste
% Argument ist dabei die Liste der Optionen, das zweite Code, der im
% Fehlerfall ausgeführt werden soll. Dabei sind die Makros
% \cs{KOMA@key@atlist}, \cs{KOMA@key@name} und \cs{KOMA@key@value} gültig und
% können verwendet werden.
%
% Anmerkung: Es wird nicht auf \textsf{ykeyval} und den dortigen Befehl
% \cs{setkeys+} gesetzt, weil dieser die Optionen nicht in der Reihenfolge der
% Optionen, sondern in der Reihenfolge der Familien ausführt. Das passt mir
% aber hier gar nicht.
%
% In einer Schleife über alle Optionen werden die Optionen zunächst in Option
% und Wert aufgespaltet.
%    \begin{macrocode}
\newcommand*{\KOMA@options}{\Family@Options{KOMA}}
%</koma>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\post@kopt@hook}
% \begin{macro}{\AfterKOMAoptions}
% Eine Option kann dafür sorgen, dass nach den Optionen noch etwas passiert.
%    \begin{macrocode}
%<*koma>
\newcommand*{\post@kopt@hook}{}
\let\post@kopt@hook\relax
\newcommand*{\AfterKOMAoptions}{%
  \ifx\post@kopt@hook\relax
    \PackageWarning{scrkbase}{%
      \string\AfterKOMAoptions\space can only be used inside a\MessageBreak
      KOMA-Script option that is called using \string\KOMAoptions.\MessageBreak
      Because of this, command will be ignored%
    }%
    \expandafter\@gobbletwo
  \else
    \expandafter\l@addto@macro
  \fi
  \post@kopt@hook
}
%</koma>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\l@addto@macro}
%   \changes{v2.8p}{2001/09/22}{neu (intern)} 
%   Damit \cs{AfterKOMAoptions} lokal möglich ist, wird eine lokal arbeitende
%   Variante von \cs{g@addto@macro} benötigt, wie sie hier vorgestellt wird.
%   \changes{v2.95}{2006/06/02}{korrigiert, damit es sich bezüglich
%     Erweiterung um Makrodefinitonen mit Argumenten wie \cs{g@addto@macro}
%     verhält}
%    \begin{macrocode}
%<*base>
\scr@ifundefinedorrelax{unexpanded}{%
  \newcommand*{\g@addto@macro@temp}{}%
  \newcommand{\l@addto@macro}[2]{%
    \begingroup%
      \toks@\expandafter{#1#2}%
      \xdef\g@addto@macro@temp{\the\toks@}%
    \endgroup
    \let#1\g@addto@macro@temp
  }%
}{%
  \newcommand{\l@addto@macro}[2]{%
    \edef#1{\unexpanded\expandafter{#1#2}}%
  }%
}
%</base>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KOMAoption}
%   \changes{v2.98c}{2008/03/12}{Neue Anweisung}
% Im Gegensatz zu \cs{KOMAoptions} kann man mit dieser Anweisung nur eine
% einzige Option setzen. Dafür kann man gleich mehrere durch Komma getrennte
% Argumente für diese Option setzen. Das erste obligatorische Argument ist die
% Option, das zweite, obligatorische Argument ist die Liste der Werte für
% diese Option.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMAoption}[2]{%
  \let\post@kopt@hook\@empty
  \Family@Option{KOMA}{#1}{#2}{%
    \PackageError{scrkbase}{%
      unknown KOMA option `\scr@key@name'%
    }{%
      You have used \string\KOMAoption\space to set
      `\scr@key@name',\MessageBreak
      but KOMA-Script does not know any option named
      `\scr@key@name'.\MessageBreak
      See the KOMA-Script manual for more informations about options
      and\MessageBreak
      their values.%
    }%
  }%
  \post@kopt@hook\let\post@kopt@hook\relax
}
%</koma>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FamilyUnknownKeyValue}
%   \changes{v3.10}{2011/09/12}{no error while processing global options}%
%   Dieses Makro berichtet über Fehler wegen unbekannter Wertübergabe an einen
%   Schlüssel. Das erste Argument ist die Familie, das zweit der Schlüssel,
%   das dritte der Wert und das vierte die Liste der möglichen Werte.
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyUnknownKeyValue}[4]{%
  \ifx\scr@removeunused\@empty
    \PackageError{%
      scrbase%
    }{%
      option `#2' of family `#1' has no value `#3'%
    }{%
      You've tried to set option `#2' of family '#1' to value `#3'.\MessageBreak
      But allowed values are only:\MessageBreak
      #4\FamilyElseValues.\MessageBreak
      See the manual of the class or package, that provides family
      `#1'\MessageBreak
      for more information about options and their values.%
    }%
  \else
    \let\scr@removeunused\@empty
    \PackageInfo{%
      scrbase%
    }{%
      option `#2' of family `#1' has no value `#3'.\MessageBreak
      Allowed values for option `#2' of family `#1'\MessageBreak
      would be:\MessageBreak
      #4\FamilyElseValues.\MessageBreak
      Maybe another class or package provides this option.\MessageBreak
      Global option ignored
    }%
  \fi
}
%</base>
%    \end{macrocode}
% \begin{macro}{\FamilyElseValues}
%   \changes{v3.00}{2008/05/02}{Neue Anweisung}
% Diese Anweisung kann vor dem Setzen eines Wertes definiert werden, um bei
% einer etwaigen Fehlermeldung weitere Werte als erlaubt auszugeben. Am Ende
% von \cs{FamilySetBool} und \cs{FamilySetNumerical} wird die Anweisung
% automatisch zu \cs{@empty}. Es ist zu beachten, dass bei der Definition der
% Anweisung als erstes ein Komma und ein Leerzeichen zu setzen ist!
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyElseValues}{}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\FamilyBoolKey}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% Dieses Makro definiert einen Schlüssel für eine Familie. Dieser Schlüssel
% ist ein Schalter, der über diverse Werte geschaltet werden kann.
% Das erste, optionale Argument ist das Familienmitglied, das zweite,
% obligatorische Argument ist die Familie, das dritte der Name des Schlüssels,
% das vierte der Schalter.
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyBoolKey}[4][.\@currname.\@currext]{%
  \@ifundefined{if#4}{%
    \expandafter\newif\csname if#4\endcsname
  }{}%
  \DefineFamilyKey[{#1}]{#2}{#3}[true]{\FamilySetBool{#2}{#3}{#4}{##1}}%
}
%    \end{macrocode}
% \begin{macro}{\FamilySetBool}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% Über diese Anweisung wird der Wert dann gesetzt. Dabei ist das erste
% Argument die Familie, das zweite der Name des Schlüsselt, das dritte der
% Schalter und das vierte schließlich der gewünschte Wert.
%    \begin{macrocode}
\newcommand*{\FamilySetBool}[4]{%
  \ifstr{#4}{true}{\@nameuse{#3true}}{%
    \ifstr{#4}{on}{\@nameuse{#3true}}{%
      \ifstr{#4}{yes}{\@nameuse{#3true}}{%
        \ifstr{#4}{false}{\@nameuse{#3false}}{%
          \ifstr{#4}{off}{\@nameuse{#3false}}{%
            \ifstr{#4}{no}{\@nameuse{#3false}}{%
              \FamilyUnknownKeyValue{#1}{#2}{#3}{%
                `true', `on', `yes', `false', `off', `no'%
              }%
            }%
          }%
        }%
      }%
    }%
  }%
  \let\FamilyElseValues\@empty
}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%  \begin{macro}{\KOMA@unknown@keyval}
% Dieses Makro berichtet über Fehler wegen unbekannter Wertübergabe an
% einen Schlüssel. Das erste Argument ist der Schlüssel, das zweite
% der Wert und das dritte die Liste der möglichen Werte.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@unknown@keyval}{\FamilyUnknownKeyValue{KOMA}}
%</koma>
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\KOMA@ifkey}
%   \changes{v3.02c}{2009/02/04}{definiert ebenfalls das Familienmitglied}
% Dieses Makro definiert einen Schlüssel, der einen Schalter an Hand des
% Wertes setzt. Als Werte sind "`\texttt{true}"', "`\texttt{false}"',
% "`\texttt{on}"', "`\texttt{off}"', "`\texttt{yes}"' und
% "`\texttt{no}"' erlaubt. Der Default-Wert für den Schalter ist
% grundsätzlich "`false"', so dass der Default-Wert für die Verwendung
% des Schküssels grundsätzlich "`true"' ist. Das erste Argument ist
% der Name des Schlüssels, der zweite ist der Name des Schalters. 
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@ifkey}{%
  \DefineFamilyMember{KOMA}%
  \FamilyBoolKey{KOMA}%
}
%</koma>
%    \end{macrocode}
%  \begin{macro}{\KOMA@set@ifkey}
% Die eigentliche Arbeit bei der ganzen Sache wird von diesem internen
% Makro erledigt. Dabei wird der Name des Schlüssels zu Argument 1, der
% Name des Schalters zu Argument 2 und der Wert des Schlüssels wird
% Argument 3.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@set@ifkey}{\FamilySetBool{KOMA}}
%</koma>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\FamilyNumericalKey}
%   \changes{v3.00}{2008/04/30}{Neue Anweisung}
% \begin{macro}{\Family@Numerical@Key}
%   \changes{v3.00}{2008/05/28}{Neu (intern)}
%   \changes{v3.08b}{2011/03/31}{fehlendes Argument bei \cs{ifundefined}}
% Ein ähnliches Makro definiert einen Schlüssel, der ein nummerisches Makro
% auf einen bestimmten Wert setzt. Dabei können auch verschiedene symbolische
% Werte auf denselben nummerischen Wert abgebildet werden. Das erste,
% optionale Argument ist das Familienmitglied, das zweite, obligatorische
% Argument ist die Familie, das dritte, obligatorische Argument ist der Name
% der Option, das vierte, optionale Artument ist der Defaultwert für den
% Schlüssel, das fünfte, obligatorische Argument ist der Name des Makros, das
% (in der Voreinstellung als 0) definiert werden soll, das sechste,
% obligatorische Argument ist die Liste der symbolischen und nummerischen
% Werte. Die Liste hat die Form:
% \{\emph{Symbol}\}\{\emph{Wert}\},\{\emph{Symbol}\}\{\emph{Wert}\}\dots
% Das interne Makro wird benötigt, um das vierte, optionale Argument zu
% ermöglichen. Dabei ist dann das erste Argument nicht mehr optional, sondern
% obligatorisch.
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyNumericalKey}[3][.\@currname.\@currext]{%
  \@ifnextchar [%]
    {\Family@Numerical@Key{#1}{#2}{#3}}{\Family@Numerical@Key{#1}{#2}{#3}[]}%
}
\newcommand*{\Family@Numerical@Key}{}
\def\Family@Numerical@Key#1#2#3[#4]#5#6{%
  \@ifundefined{#5}{\@namedef{#5}{0}}{}%
  \ifx\relax#4\relax
    \DefineFamilyKey[{#1}]{#2}{#3}{\FamilySetNumerical{#2}{#3}{#5}{#6}{##1}}%
  \else
    \DefineFamilyKey[{#1}]{#2}{#3}[{#4}]{%
      \FamilySetNumerical{#2}{#3}{#5}{#6}{##1}}%
  \fi
}
%    \end{macrocode}
%  \begin{macro}{\FamilySetNumerical}
% Die eigentliche Arbeit dabei wird von diesem Makro erledigt. Dabei
% wird die Familie zu Argument 1, der Name des Schlüssels zu Argument 2, der
% Name des Makros, das definiert werden soll zu Argument 3, die Liste zu
% Argument 4 und der Wert, auf den gesetzt werden soll, zu Argument 5.
%    \begin{macrocode}
\newcommand*{\FamilySetNumerical}[5]{%
  \begingroup
    \edef\@searched{#5}%
    \let\@tempa=\@empty
    \let\@tempb=\@empty
    \@tempswafalse
    \@for\@valuelist:=#4\do{%
      \if@tempswa\else
        \edef\@tempc{\expandafter\@firstoftwo\@valuelist}%
        \edef\@tempa{\@tempa\@tempb`\@tempc'}%
        \edef\@tempb{, }%
        \ifx\@tempc\@searched
          \@tempswatrue
          \edef\@tempa{\expandafter\@secondoftwo\@valuelist}%
        \fi
      \fi
    }%
    \if@tempswa
      \edef\@tempa{\endgroup
        \noexpand\@namedef{#3}{\@tempa}%
      }%
    \else
      \FamilyUnknownKeyValue{#1}{#2}{#5}{\@tempa}%
      \let\@tempa=\endgroup
    \fi
  \@tempa
  \let\FamilyElseValues\@empty
}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\KOMA@ncmdkey}
%   \changes{v3.02c}{2009/02/04}{definiert ebenfalls das Familienmitglied}
% Ein ähnliches Makro definiert einen Schlüssel, der ein nummerisches
% Makro auf einen bestimmten Wert setzt. Dabei können auch
% verschiedene symbolische Werte auf denselben nummerischen Wert
% abgebildet werden. Das erste Argument ist obligatorisch und der Name
% des Schlüssels. Das zweite Argument ist optional und der Defaultwert
% für den Schlüssel. Das dritte Argument ist obligatorisch und der
% Name des Makros, das definiert werden soll. Der Defaultwert dafür
% ist 0. Das vierte Argument ist obligatorisch und die Liste der
% symbolischen und nummerischen Wert. Die Liste hat die Form: 
% \{\emph{Symbol}\}\{\emph{Wert}\},\{\emph{Symbol}\}\{\emph{Wert}\}\dots
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@ncmdkey}{%
  \DefineFamilyMember{KOMA}%
  \FamilyNumericalKey{KOMA}%
}
%</koma>
%    \end{macrocode}
%  \begin{macro}{\KOMA@set@ncmdkey}
% Die eigentliche Arbeit dabei wird wahlweise von diesem Makro erledigt. Dabei
% wird der Name des Schlüssels zu Argument 1, der Name des Makros,
% das definiert werden soll zu Argument 2, die Liste zu Argument 3 und
% der Wert, auf den gesetzt werden soll, zu Argument 4.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@set@ncmdkey}{\FamilySetNumerical{KOMA}}
%</koma>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
% \begin{macro}{\FamilyStringKey}
%   \changes{v3.08}{2010/11/05}{Neue Anweisung}
%   \changes{v3.08b}{2011/03/31}{\cs{Family@String@Key} und
%     \cs{Family@@String@@Key} vertauscht}
% \begin{macro}{\Family@String@Key}
%   \changes{v3.08}{2010/11/05}{Neu (intern)}
% \begin{macro}{\Family@@String@@Key}
%   \changes{v3.08}{2010/11/05}{Neu (intern)}
% Ein ähnliches Makro definiert einen Schlüssel, der ein Makro auf einen
% beliegigen Wert setzt. Das erste, optionale Argument ist das
% Familienmitglied, das zweite, obligatorische Argument ist die Familie, das
% dritte, obligatorische Argument ist der Name der Option, das vierte,
% optionale Artument ist der Defaultwert für den Schlüssel, das fünfte,
% obligatorische Argument ist der Name des Makros, das (in der Voreinstellung
% als leer) definiert werden soll. Die internen Makro werden benötigt, um das
% vierte, optionale Argument zu ermöglichen. Dabei ist dann das erste Argument
% nicht mehr optional, sondern obligatorisch.
%    \begin{macrocode}
%<*base>
\newcommand*{\FamilyStringKey}[3][.\@currname.\@currext]{%
  \@ifnextchar [%]
    {\Family@@String@@Key{#1}{#2}{#3}}{\Family@String@Key{#1}{#2}{#3}}%
}
\newcommand*{\Family@@String@@Key}{}
\long\def\Family@@String@@Key#1#2#3[#4]#5{%
  \DefineFamilyKey[{#1}]{#2}{#3}[{#4}]{\def#5{##1}}%
}
\newcommand{\Family@String@Key}[4]{%
  \DefineFamilyKey[{#1}]{#2}{#3}{\def#4{##1}}%
}
%</base>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\KOMA@DeclareDeprecatedOption}
%   \changes{v3.01a}{2008/11/20}{neu (intern)}
% \begin{macro}{\KOMA@@DeclareDeprecatedOption}
%   \changes{v3.01a}{2008/11/20}{neu (intern)}
% \begin{macro}{\KOMA@@@DeclareDeprecatedOption}
%   \changes{v3.01a}{2008/11/20}{neu (intern)}
% Mit Hilfe dieses Makros kann eine Option definiert werden, die
% eigentlich obsolete ist. Statt dieser Option wird dann ein Schlüssel
% verwendet. Das erste Argument ist optional und muss dann der Paketname
% sein. Ist es nicht gesetzt, so wird stattdessen die Klasse
% \cs{KOMAClassName} angenommen. Das zweite Argument ist der Name der
% Option. Das vierte Argument ist das Setzen des gewünschten Schlüssels.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@DeclareDeprecatedOption}{%
  \@ifnextchar [%]
  {\KOMA@@DeclareDeprecatedOption}%
  {\KOMA@@@DeclareDeprecatedOption{\ClassWarningNoLine{\KOMAClassName}}}%
}
\newcommand*{\KOMA@@DeclareDeprecatedOption}[1][]{%
  \KOMA@@@DeclareDeprecatedOption{\PackageWarningNoLine{#1}}%
}
\newcommand*{\KOMA@@@DeclareDeprecatedOption}[3]{%
  \DeclareOption{#2}{\KOMA@UseDeprecatedOption{#1}{#2}{#3}}%
}
%    \end{macrocode}
% \begin{macro}{\KOMA@UseDeprecatedOption}
%   \changes{v3.01a}{2008/11/20}{neu (intern)}
% Die eigentliche Arbeit wird von diesem Makro erledigt. Die Argumente sind
% 1. Meldungsbefehl, 2. obsolete Option, 3. Setzen des Schlüssels.
%    \begin{macrocode}
\newcommand*{\KOMA@UseDeprecatedOption}[3]{%
  \let\scr@sr@co\CurrentOption
  #1{%
    You've used obsolete option `#2'.\MessageBreak
    Usage of this option indicates an old document and\MessageBreak
    changes compatibility level using\MessageBreak
    `#3,version=first'.\MessageBreak
    If you don't want this, you should simply replace\MessageBreak
    usage of option `#2' by `#3'%
  }%
  \KOMAExecuteOptions{#3,version=first}%
  \let\CurrentOption\scr@sr@co
}
%</koma>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\KOMA@DeclareStandardOption}
%   \changes{v3.01a}{2008/11/21}{neu (intern)}
% \begin{macro}{\KOMA@@DeclareStandardOption}
%   \changes{v3.01a}{2008/11/21}{neu (intern)}
% \begin{macro}{\KOMA@@@DeclareStandardOption}
%   \changes{v3.01a}{2008/11/21}{neu (intern)}
% Mit Hilfe dieses Makros kann eine Option definiert werden, die
% eigentlich obsolete ist. Statt dieser Option wird dann ein Schlüssel
% verwendet. Das erste Argument ist optional und muss dann der Paketname
% sein. Ist es nicht gesetzt, so wird stattdessen die Klasse
% \cs{KOMAClassName} angenommen. Das zweite Argument ist der Name der
% Option. Das vierte Argument ist das Setzen des gewünschten Schlüssels.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@DeclareStandardOption}{%
  \@ifnextchar [%]
  {\KOMA@@DeclareStandardOption}%
  {\KOMA@@@DeclareStandardOption{\ClassInfoNoLine{\KOMAClassName}}}%
}
\newcommand*{\KOMA@@DeclareStandardOption}[1][]{%
  \KOMA@@@DeclareStandardOption{\PackageInfoNoLine{#1}}%
}
\newcommand*{\KOMA@@@DeclareStandardOption}[3]{%
  \DeclareOption{#2}{\KOMA@UseStandardOption{#1}{#2}{#3}}%
}
%    \end{macrocode}
% \begin{macro}{\KOMA@UseStandardOption}
%   \changes{v3.01a}{2008/11/21}{neu (intern)}
% Die eigentliche Arbeit wird von diesem Makro erledigt. Die Argumente sind
% 1. Meldungsbefehl, 2. obsolete Option, 3. Setzen des Schlüssels.
%    \begin{macrocode}
\newcommand*{\KOMA@UseStandardOption}[3]{%
  \let\scr@sr@co\CurrentOption
  #1{%
    You've used standard option `#2'.\MessageBreak
    This is correct!\MessageBreak
    Internally I'm using `#3'.\MessageBreak
    If you'd like to set the option with \string\KOMAoptions,\MessageBreak
    you'd have to use `#3' there\MessageBreak
    instead of `#2', too%
  }%
  \KOMAExecuteOptions{#3}%
  \let\CurrentOption\scr@sr@co
}
%</koma>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\KOMA@DeclareObsoleteOption}
%   \changes{v2.96}{2006/08/20}{\cs{CurrentOption wir geschützt}}
% \begin{macro}{\KOMA@@DeclareObsoleteOption}
%   \changes{v2.98c}{2008/02/18}{neu (intern)}
% \begin{macro}{\KOMA@@@DeclareObsoleteOption}
%   \changes{v2.98c}{2008/02/18}{neu (intern)}
% \begin{macro}{\KOMA@iv@DeclareObsoleteOption}
%   \changes{v2.98c}{2008/02/18}{neu (intern)}
% Mit Hilfe dieses Makros kann eine Option definiert werden, die
% eigentlich obsolete ist. Statt dieser Option wird dann ein Schlüssel
% verwendet. Das erste Argument ist optional und muss dann entweder
% \cs{PackageInfo}, \cs{PackageInfoNoLine}, \cs{PackageWarning},
% \cs{PackageWarningNoLine} oder das gleiche für Klassen sein. Das zweite
% Argument ist ebenfalls optional und der Name des Pakets oder der Klasse. Das
% dritte Argument ist der Name der Option. Das vierte Argument ist das Setzen
% des gewünschten Schlüssels.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@DeclareObsoleteOption}{%
  \@ifnextchar [%]
  {\KOMA@@DeclareObsoleteOption}%
  {\KOMA@@DeclareObsoleteOption[\@gobbletwo]}%
}
\newcommand*{\KOMA@@DeclareObsoleteOption}{}
\def\KOMA@@DeclareObsoleteOption[#1]{%
  \@ifnextchar [%]
  {\KOMA@@@DeclareObsoleteOption{#1}}%
  {\KOMA@@@DeclareObsoleteOption{#1}[]}%
}
\newcommand*{\KOMA@@@DeclareObsoleteOption}{}
\def\KOMA@@@DeclareObsoleteOption#1[#2]#3#4{%
  \ifstr{#2}{}{%
    \KOMA@iv@DeclareObsoleteOption{#1}{\@currname}{#3}{#4}%
  }{%
    \KOMA@UseObsoleteOption{#1}{#2}{#3}{#4}%
  }%
}
\newcommand*{\KOMA@iv@DeclareObsoleteOption}[4]{%
  \DeclareOption{#3}{\KOMA@UseObsoleteOption{#1{#2}}{#3}{#4}}%
}
%    \end{macrocode}
% \begin{macro}{\KOMA@UseObsoleteOption}
%   \changes{v2.97c}{2007/04/19}{neu (intern)}
% Die eigentliche Arbeit wird von diesem Makro erledigt. Die Argumente sind
% 1. Meldungsbefehl, 2. obsolete Option, 3. Setzen des Schlüssels.
%    \begin{macrocode}
\newcommand*{\KOMA@UseObsoleteOption}[3]{%
  \let\scr@sr@co\CurrentOption
  #1{%
    You've used obsolete option `#2'.\MessageBreak
    \protect\KOMAExecuteOptions{#3} will be\MessageBreak
    used instead.\MessageBreak
    You may simply replace `#2'\MessageBreak
    by `#3'%
  }%
  \KOMAExecuteOptions{#3}%
  \let\CurrentOption\scr@sr@co
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%  \begin{macro}{\scr@sr@co}
%    \changes{v2.96}{2006/08/20}{neu (intern)}
% Da das \texttt{xkeyval}-Paket leider \cs{CurrentOption} vernichtet, das aber
% innerhalb von \cs{ProcessOptions} und \cs{KOMAProcessOptions} nach dem
% Ausführen der Option noch benötigt wird, muss die Anweisung gesichert
% werden. Dafür wird ein Hilfsmakro benötigt.
%    \begin{macrocode}
\newcommand*{\scr@sr@co}{}
%</koma>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KOMA@newobsoletecommand}
% Mit Hilfe dieses Makros kann ein Makro definiert werden, das
% eigentlich obsolete ist. Das Makro verwendet dann schlicht einen
% Schlüssel. Das erste Argument ist optional und muss dann entweder
% \cs{PackageInfo}, \cs{PackageInfoNoLine}, \cs{PackageWarning} oder
% \cs{PackageWarningNoLine} sein. Das zweite Argument ist das Makro.
% Das dritte Argument ist das Setzen des gewünschten Schlüssels. Das
% definierte Makro selbst hat Schaltercharakter, ist also nicht
% \cs{long} und versteht auch keine Argumente.
%    \begin{macrocode}
%<*koma>
\newcommand*{\KOMA@newobsoletecommand}[3][\@gobbletwo]{%
  \newcommand*{#2}{\KOMA@UseObsoleteCommand{#1}{\string#2}{#3}}%
}
%    \end{macrocode}
% \begin{macro}{\KOMA@UseObsoleteCommand}
%   \changes{v2.97c}{2007/04/19}{neu (intern)}
% Die eigentliche Arbeit wird von diesem Makro erledigt. Die Argumente sind
% dieselben.
%    \begin{macrocode}
\newcommand*{\KOMA@UseObsoleteCommand}[3]{%
  #1{%
    scrkbase%
  }{%
    You've used the obsolete command `#2'.\MessageBreak
    \protect\KOMAoptions{#3} will be used instead.\MessageBreak
    You should also replace `#2' by `\protect\KOMAoptions{#3}'%
  }%
  \KOMAoptions{#3}%
}
%</koma>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \iffalse
%</body>
% \fi
%
% \Finale
%
\endinput
%
% end of file `scrkbase.dtx'
%%% Local Variables:
%%% mode: doctex
%%% TeX-master: t
%%% End:
