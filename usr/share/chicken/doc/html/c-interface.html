<html><head><title>CHICKEN User's Manual - C interface</title></head><body>
<p> </p><a name="c-interface"></a><h1>C interface</h1><p>The following functions and macros are available for C code that invokes Scheme or foreign procedures that are called by Scheme:</p><a name="c-save"></a><h2>C_save</h2><pre>[C macro] void C_save (C_word x) :</pre><p>Saves the Scheme data object <tt>x</tt> on the temporary stack.</p><a name="c-restore"></a><h2>C_restore</h2><pre>[C macro] void C_restore</pre><p>Pops and returns the topmost value from the temporary stack.</p><a name="c-fix"></a><h2>C_fix</h2><pre>[C macro] C_word C_fix (int integer)</pre><a name="c-make-character"></a><h2>C_make_character</h2><pre>[C macro] C_word C_make_character (int char_code)</pre><a name="c-scheme-end-of-list"></a><h2>C_SCHEME_END_OF_LIST</h2><pre>[C macro] C_SCHEME_END_OF_LIST</pre><a name="c-word-c-scheme-end-of-file"></a><h2>C_word C_SCHEME_END_OF_FILE</h2><pre>[C macro] C_SCHEME_END_OF_FILE</pre><a name="c-word-c-scheme-false"></a><h2>C_word C_SCHEME_FALSE</h2><pre>[C macro] C_SCHEME_FALSE</pre><a name="c-word-c-scheme-true"></a><h2>C_word C_SCHEME_TRUE</h2><pre>[C macro] C_SCHEME_TRUE</pre><p>These macros return immediate Scheme data objects.</p><a name="c-string"></a><h2>C_string</h2><pre>[C function] C_word C_string (C_word **ptr, int length, char *string)</pre><a name="c-string2"></a><h2>C_string2</h2><pre>[C function] C_word C_string2 (C_word **ptr, char *zero_terminated_string)</pre><a name="c-intern2"></a><h2>C_intern2</h2><pre>[C function] C_word C_intern2 (C_word **ptr, char *zero_terminated_string)</pre><a name="c-intern3"></a><h2>C_intern3</h2><pre>[C function] C_word C_intern3 (C_word **ptr, char *zero_terminated_string, C_word initial_value)</pre><a name="c-pair"></a><h2>C_pair</h2><pre>[C function] C_word C_pair (C_word **ptr, C_word car, C_word cdr)</pre><a name="c-flonum"></a><h2>C_flonum</h2><pre>[C function] C_word C_flonum (C_word **ptr, double number)</pre><a name="c-int-to-num"></a><h2>C_int_to_num</h2><pre>[C function] C_word C_int_to_num (C_word **ptr, int integer)</pre><a name="c-mpointer"></a><h2>C_mpointer</h2><pre>[C function] C_word C_mpointer (C_word **ptr, void *pointer)</pre><a name="c-vector"></a><h2>C_vector</h2><pre>[C function] C_word C_vector (C_word **ptr, int length, ...)</pre><a name="c-list"></a><h2>C_list</h2><pre>[C function] C_word C_list (C_word **ptr, int length, ...)</pre><p>These functions allocate memory from <tt>ptr</tt> and initialize a fresh data object. The new data object is returned. <tt>ptr</tt> should be the <strong>address</strong> of an allocation pointer created with <tt>C_alloc</tt>.</p><a name="c-alloc"></a><h2>C_alloc</h2><pre>[C macro] C_word* C_alloc (int words)</pre><p>Allocates memory from the C stack (<tt>C_alloc</tt>) and returns a pointer to it. <tt>words</tt> should be the number of words needed for all data objects that are to be created in this function.  Note that stack-allocated data objects have to be passed to Scheme callback functions, or they will not be seen by the garbage collector. This is really only usable for callback procedure invocations, make sure not to use it in normal code, because the allocated memory will be re-used after the foreign procedure returns. When invoking Scheme callback procedures a minor garbage collection is performed, so data allocated with <tt>C_alloc</tt> will already have moved to a safe place.</p><p>Note that <tt>C_alloc</tt> is really just a wrapper around <tt>alloca</tt>, and can also be simulated by declaring a stack-allocated array of <tt>C_word</tt>s:</p><a name="c-sizeof-list"></a><h2>C_SIZEOF_LIST</h2><pre>[C macro] int C_SIZEOF_LIST (int length)</pre><a name="c-sizeof-string"></a><h2>C_SIZEOF_STRING</h2><pre>[C macro] int C_SIZEOF_STRING (int length)</pre><a name="c-sizeof-vector"></a><h2>C_SIZEOF_VECTOR</h2><pre>[C macro] int C_SIZEOF_VECTOR (int length)</pre><a name="c-sizeof-interned-symbol"></a><h2>C_SIZEOF_INTERNED_SYMBOL</h2><pre>[C macro] int C_SIZEOF_INTERNED_SYMBOL (int length)</pre><a name="c-sizeof-pair"></a><h2>C_SIZEOF_PAIR</h2><pre>[C macro] int C_SIZEOF_PAIR</pre><a name="c-sizeof-flonum"></a><h2>C_SIZEOF_FLONUM</h2><pre>[C macro] int C_SIZEOF_FLONUM</pre><a name="c-sizeof-pointer"></a><h2>C_SIZEOF_POINTER</h2><pre>[C macro] int C_SIZEOF_POINTER</pre><a name="c-sizeof-locative"></a><h2>C_SIZEOF_LOCATIVE</h2><pre>[C macro] int C_SIZEOF_LOCATIVE</pre><a name="c-sizeof-tagged-pointer"></a><h2>C_SIZEOF_TAGGED_POINTER</h2><pre>[C macro] int C_SIZEOF_TAGGED_POINTER</pre><p>These are macros that return the size in words needed for a data object of a given type.</p><a name="c-character-code"></a><h2>C_character_code</h2><pre>[C macro] int C_character_code (C_word character)</pre><a name="c-unfix"></a><h2>C_unfix</h2><pre>[C macro] int C_unfix (C_word fixnum)</pre><a name="c-flonum-magnitude"></a><h2>C_flonum_magnitude</h2><pre>[C macro] double C_flonum_magnitude (C_word flonum)</pre><a name="c-c-string"></a><h2>C_c_string</h2><pre>[C function] char* C_c_string (C_word string)</pre><a name="c-num-to-int"></a><h2>C_num_to_int</h2><pre>[C function] int C_num_to_int (C_word fixnum_or_flonum)</pre><a name="c-pointer-address"></a><h2>C_pointer_address</h2><pre>[C function] void* C_pointer_address (C_word pointer)</pre><p>These macros and functions can be used to convert Scheme data objects back to C data. Note that <tt>C_c_string()</tt> returns a pointer to the character buffer of the actual Scheme object and is not zero-terminated.</p><a name="c-header-size"></a><h2>C_header_size</h2><pre>[C macro] int C_header_size (C_word x)</pre><a name="c-header-bits"></a><h2>C_header_bits</h2><pre>[C macro] int C_header_bits (C_word x)</pre><p>Return the number of elements and the type-bits of the non-immediate Scheme data object <tt>x</tt>.</p><a name="c-block-item"></a><h2>C_block_item</h2><pre>[C macro] C_word C_block_item (C_word x, int index)</pre><p>This macro can be used to access slots of the non-immediate Scheme data object <tt>x</tt>.  <tt>index</tt> specifies the index of the slot to be fetched, starting at 0. Pairs have 2 slots, one for the <strong>car</strong> and one for the <strong>cdr</strong>. Vectors have one slot for each element.</p><a name="c-u-i-car"></a><h2>C_u_i_car</h2><pre>[C macro] C_word C_u_i_car (C_word x)</pre><a name="c-u-i-cdr"></a><h2>C_u_i_cdr</h2><pre>[C macro] C_word C_u_i_cdr (C_word x)</pre><p>Aliases for <tt>C_block_item(x, 0)</tt> and <tt>C_block_item(x, 1)</tt>, respectively.</p><a name="c-data-pointer"></a><h2>C_data_pointer</h2><pre>[C macro] void* C_data_pointer (C_word x)</pre><p>Returns a pointer to the data-section of a non-immediate Scheme object.</p><a name="c-make-header"></a><h2>C_make_header</h2><pre>[C macro] C_word C_make_header (C_word bits, C_word size)</pre><p>A macro to build a Scheme object header from its bits and size parts.</p><a name="c-mutate"></a><h2>C_mutate</h2><pre>[C function] C_word C_mutate (C_word *slot, C_word val)</pre><p>Assign the Scheme value <tt>val</tt> to the location specified by <tt>slot</tt>.  If the value points to data inside the nursery (the first heap-generation), then the garbage collector will remember to handle the data appropriately. Assigning nursery-pointers directly will otherwise result in lost data. Note that no copying takes place at the moment when <tt>C_mutate</tt> is called, but later - at the next (minor) garbage collection.</p><a name="c-symbol-value"></a><h2>C_symbol_value</h2><pre>[C macro] C_word C_symbol_value (C_word symbol)</pre><p>Returns the global value of the variable with the name <tt>symbol</tt>. If the variable is unbound <tt>C_SCHEME_UNBOUND</tt> is returned. You can set a variable's value with <tt>C_mutate(&amp;C_symbol_value(SYMBOL), VALUE)</tt>.</p><a name="c-gc-protect"></a><h2>C_gc_protect</h2><pre>[C function] void C_gc_protect (C_word *ptrs[], int n)</pre><p>Registers <tt>n</tt> variables at address <tt>ptrs</tt> to be garbage collection roots. The locations should not contain pointers to data allocated in the nursery, only immediate values or pointers to heap-data are valid. Any assignment of potential nursery data into a root-array should be done via <tt>C_mutate()</tt>. The variables have to be initialized to sensible values before the next garbage collection starts (when in doubt, set all locations in <tt>ptrs</tt> to <tt>C_SCHEME_UNDEFINED</tt>) <tt>C_gc_protect</tt> may not called before the runtime system has been initialized (either by <tt>CHICKEN_initialize</tt>, <tt>CHICKEN_run</tt> or <tt>CHICKEN_invoke</tt>.</p><p>For a slightly simpler interface to creating and using GC roots see <tt>CHICKEN_new_gc_root</tt>.</p><a name="c-gc-unprotect"></a><h2>C_gc_unprotect</h2><pre>[C function] void C_gc_unprotect (int n)</pre><p>Removes the last <tt>n</tt> registered variables from the set of root variables.</p><a name="c-pre-gc-hook"></a><h2>C_pre_gc_hook</h2><pre>[C Variable] void (*C_pre_gc_hook)(int mode)</pre><p>If not <tt>NULL</tt>, the function pointed to by this variable will be called before each garbage collection with a flag indicating what kind of collection was performed (either <tt>0</tt> for a minor collection or <tt>2</tt> for a resizing collection). A "resizing" collection means a secondary collection that moves all live data into a enlarged (or shrinked) heap-space. Minor collections happen very frequently, so the hook function should not consume too much time. The hook function may not invoke Scheme callbacks.</p><p>Note that resizing collections may be nested in normal major collections.</p><a name="c-post-gc-hook"></a><h2>C_post_gc_hook</h2><pre>[C Variable] void (*C_post_gc_hook)(int mode, long ms)</pre><p>If not <tt>NULL</tt>, the function pointed to by this variable will be called after each garbage collection with a flag indicating what kind of collection was performed (either <tt>0</tt> for a minor collection, <tt>1</tt> for a major collection or <tt>2</tt> for a resizing collection). Minor collections happen very frequently, so the hook function should not consume too much time. The hook function may not invoke Scheme callbacks. The <tt>ms</tt> argument records the number of milliseconds required for the garbage collection, if the collection was a major one. For minor collections the value of the <tt>ms</tt> argument is undefined.</p><a name="an-example-for-simple-calls-to-foreign-code-involving-callbacks"></a><h2>An example for simple calls to foreign code involving callbacks</h2><pre>% cat foo.scm
#&gt;
extern int callout(int, int, int);
&lt;#</pre><pre>(define callout (foreign-safe-lambda int "callout" int int int))</pre><pre>(define-external (callin (scheme-object xyz)) int
  (print "This is 'callin': " xyz)
  123)</pre><pre>(print (callout 1 2 3))</pre><pre>% cat bar.c
#include &lt;stdio.h&gt;
#include "chicken.h"</pre><pre>extern int callout(int, int, int);
extern int callin(C_word x);</pre><pre>int callout(int x, int y, int z)
{
  C_word *ptr = C_alloc(C_SIZEOF_LIST(3));
  C_word lst;</pre><pre>  printf("This is 'callout': %d, %d, %d\n", x, y, z);
  lst = C_list(&amp;ptr, 3, C_fix(x), C_fix(y), C_fix(z));
  return callin(lst);  /* Note: `callin' will have GC'd the data in `ptr' */
}</pre><pre>% csc foo.scm bar.c -o foo
% foo
This is 'callout': 1, 2, 3
This is 'callin': (1 2 3)
123</pre><a name="notes"></a><h2>Notes:</h2><p>Scheme procedures can call C functions, and C functions can call Scheme procedures, but for every pending C stack frame, the available size of the first heap generation (the <em>nursery</em>) will be decreased, because the C stack is identical to the nursery. On systems with a small nursery this might result in thrashing, since the C code between the invocation of C from Scheme and the actual calling back to Scheme might build up several stack-frames or allocates large amounts of stack data. To prevent this it is advisable to increase the default nursery size, either when compiling the file (using the <tt>-nursery</tt> option) or when running the executable (using the <tt>-:s</tt> runtime option).</p><p>Calls to Scheme/C may be nested arbitrarily, and Scheme continuations can be invoked as usual, but keep in mind that C stack frames will not be recovered, when a Scheme procedure call from C does not return normally.</p><p>When multiple threads are running concurrently, and control switches from one thread to another, then the continuation of the current thread is captured and saved. Any pending C stack frame still active from a callback will remain on the stack until the threads is re-activated again. This means that in a multithreading situation, when C callbacks are involved, the available nursery space can be smaller than expected. So doing many nested Scheme&rarr;C&rarr;Scheme calls can reduce the available memory up to the point of thrashing. It is advisable to have only a single thread with pending C stack-frames at any given time.</p><p>Pointers to Scheme data objects should not be stored in local or global variables while calling back to Scheme.  Any Scheme object not passed back to Scheme will be reclaimed or moved by the garbage collector.</p><p>Calls from C to Scheme are never tail-recursive.</p><p>Continuations captured via <tt>call-with-current-continuation</tt> and passed to C code can be invoked like any other Scheme procedure.</p><p>Previous: <a href="other-support-procedures.html" class="internal">Other support procedures</a></p><p>Next: <a href="chicken-setup.html" class="internal">chicken-setup</a></p>
</body></html>