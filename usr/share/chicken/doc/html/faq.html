<html><head><title>CHICKEN User's Manual - faq</title></head><body>
<p> </p><a name="faq"></a><h1>FAQ</h1><p>This is the list of Frequently Asked Questions about Chicken Scheme. If you have a question not answered here, feel free to post to the chicken-users mailing list; if you consider your question general enough, feel free to add it to this list.</p><a name="general"></a><h2>General</h2><a name="why-yet-another-scheme-implementation"></a><h3>Why yet another Scheme implementation?</h3><p>Since Scheme is a relatively simple language, a large number of implementations exist and each has its specific advantages and disadvantages. Some are fast, some provide a rich programming environment. Some are free, others are tailored to specific domains, and so on. The reasons for the existence of CHICKEN are:</p><ul><li>CHICKEN is portable because it generates C code that runs on a large number of platforms.</li><li>CHICKEN is extendable, since its code generation scheme and runtime system/garbage collector fits neatly into a C environment.</li><li>CHICKEN is free and can be freely distributed, including its source code.</li><li>CHICKEN offers better performance than nearly all interpreter based implementations, but still provides full Scheme semantics.</li><li>As far as we know, CHICKEN is the first implementation of Scheme that uses Henry Baker's <a href="http://home.pipeline.com/~hbaker1/CheneyMTA.html" class="external">Cheney on the M.T.A</a> concept.</li></ul><a name="why-call-it-chicken"></a><h3>Why call it 'Chicken'?</h3><p>According to <a href="http://chicken.wiki.br/felix winkelmann" class="external">felix</a>:</p><blockquote><p>Well, it's pretty boring, really: when I started the project and needed some name, the first thing that met my eyes was the "chicken" (actually a disguised penguin)  from the Wallace + Gromit movie... And then there is of course the ever occurring chicken-and-egg problem with bootstrapped compilers.</p></blockquote><a name="what-should-i-do-if-i-find-a-bug"></a><h3>What should I do if I find a bug?</h3><p>Send e-mail to <a href="mailto:felix@call-with-current-continuation.org" class="external">felix@call-with-current-continuation.org</a> with some hints about the problem, like version/build of the compiler, platform, system configuration, code that causes the bug, etc.</p><a name="why-are-values-defined-with-define-foreign-variable-or-define-constant-or-define-inline-not-seen-outside-of-the-containing-source-file"></a><h3>Why are values defined with <tt>define-foreign-variable</tt> or <tt>define-constant</tt> or <tt>define-inline</tt> not seen outside of the containing source file?</h3><p>Accesses to foreign variables are translated directly into C constructs that access the variable, so the Scheme name given to that variable does only exist during compile-time. The same goes for constant- and inline-definitions: The name is only there to tell the compiler that this reference is to be replaced with the actual value.</p><a name="how-does-cond-expand-know-which-features-are-registered-in-used-units"></a><h3>How does <tt>cond-expand</tt> know which features are registered in used units?</h3><p>Each unit used via <tt>(declare (uses ...))</tt> is registered as a feature and so a symbol with the unit-name can be tested by <tt>cond-expand</tt> during macro-expansion-time. Features registered using the <tt>register-feature!</tt> procedure are only available during run-time of the compiled file. You can use the <tt>eval-when</tt> form to register features at compile time.</p><a name="why-are-constants-defined-by-define-constant-not-honoured-in-case-constructs"></a><h3>Why are constants defined by <tt>define-constant</tt> not honoured in <tt>case</tt> constructs?</h3><p><tt>case</tt> expands into a cascaded <tt>if</tt> expression, where the first item in each arm is treated as a quoted list. So the <tt>case</tt> macro can not infer whether a symbol is to be treated as a constant-name (defined via <tt>define-constant</tt>) or a literal symbol.</p><a name="how-can-i-enable-case-sensitive-reading-writing-in-user-code"></a><h3>How can I enable case sensitive reading/writing in user code?</h3><p>To enable the <tt>read</tt> procedure to read symbols and identifiers case sensitive, you can set the parameter <tt>case-sensitivity</tt> to <tt>#t</tt>.</p><a name="how-can-i-change-match-error-control-during-compilation"></a><h3>How can I change <tt>match-error-control</tt> during compilation?</h3><p>Use <tt>eval-when</tt>, like this:</p><PRE>
(eval-when (compile)
(match-error-control #:unspecified) )
</PRE>
<a name="why-doesn-t-chicken-support-the-full-numeric-tower-by-default"></a><h3>Why doesn't CHICKEN support the full numeric tower by default?</h3><p>The short answer:</p><PRE>
% chicken-setup numbers
% csi -q
#<I><FONT COLOR="#B22222">;1&gt; (use numbers)
</FONT></I></PRE>
<p>The long answer:</p><p>There are a number of reasons for this:</p><p>- For most applications of Scheme fixnums (exact word-sized integers) and flonums (64-bit floating-point numbers) are more than sufficient;</p><p>- Interfacing to C is simpler;</p><p>- Dispatching of arithmetic operations is more efficient.</p><p>There is an extension based on the GNU Multiprecision Package that implements most of the full numeric tower, see <a href="http://chicken.wiki.br/numbers" class="external">numbers</a>.</p><a name="how-can-i-specialize-a-generic-function-method-to-match-instances-of-every-class"></a><h3>How can I specialize a generic function method to match instances of every class?</h3><p>Specializing a method on <tt>&lt;object&gt;</tt> doesn't work on primitive data objects like numbers, strings, etc. so for example</p><PRE>
(define-method (foo (x &lt;my-class&gt;)) ...)
(define-method (foo (x &lt;object&gt;)) ...)
(foo 123)
</PRE>
<p>will signal an error, because to applicable method can be found. To specialize a method for primitive objects, use <tt>&lt;top&gt;</tt>:</p><PRE>
(define-method (foo (x &lt;top&gt;)) ...)
</PRE>
<a name="does-chicken-support-native-threads"></a><h3>Does CHICKEN support native threads?</h3><p>Native threads are not supported for two reasons. One, the runtime system is not reentrant.  Two, concurrency implemented properly would require mandatory locking of every object that could be potentially shared between two threads. The garbage-collection algorithm would then become much more complex and inefficient, since the location of every object has to be accessed via a thread synchronization protocol. Such a design would make native threads in Chicken essentially equivalent to Unix processes and shared memory.</p><p>For a different approach to concurrency, please see the <a href="http://www.call-with-current-continuation.org/eggs/3/mpi.html" class="external">mpi</a> egg.</p><a name="does-chicken-support-unicode-strings"></a><h3>Does CHICKEN support Unicode strings?</h3><p>Yes, as an extension.</p><p>By default all string and character functions operate bytewise, so that characters with an iteger value greater than 255 don't make much sense and multibyte UTF-8 characters are seen and manipulated as separate bytes, analogous to what a C program would see.</p><p>You can enable UTF-8 support by placing the following two lines at the beginning of your source file (or in your ~/.csirc for interactive sessions) before any other code, including other use directives:</p><PRE>
(use iset syntax-case utf8)
(import utf8)
</PRE>
<p>This will replace all builtin string operators with UTF-8-aware versions, that will treat strings as sequences of multibyte UTF-8 characters, thus enabling you to represent and manipulate Unicode characters while remaining compatible with most C libraries and system interfaces.</p><p>Most eggs should work correctly in utf8 mode, including the regex extension, but you still have the option of working around incompatibilities of specific eggs by loading them before the (import utf8) directive. Keep in mind that some operations, such as string-length, are much more expensive in utf8 (multibyte) mode, and should be used with care. See the <a href="http://www.call-with-current-continuation.org/eggs/utf8.html" class="external">utf8 egg documentation</a> for details.</p><a name="why-do-i-get-an-error-invalid-syntax-using-match-and-syntax-case"></a><h3>Why do I get an "Error: invalid syntax: ..." using 'match' and 'syntax-case'?</h3><p>The built-in 'match' macro is incompatible with 'syntax-case'. Use the  <a href="http://www.call-with-current-continuation.org/eggs/matchable.html" class="external">matchable egg</a> instead.</p><a name="platform-specific"></a><h2>Platform specific</h2><a name="how-do-i-generate-a-dll-under-ms-windows-tm"></a><h3>How do I generate a DLL under MS Windows (tm) ?</h3><p>Use <tt>csc</tt> in combination with the <tt>-dll</tt> option:</p><p><tt>C:\&gt; csc foo.scm -dll</tt></p><a name="how-do-i-generate-a-gui-application-under-windows-tm"></a><h3>How do I generate a GUI application under Windows(tm)?</h3><p>Invoke <tt>csc</tt> with the <tt>-windows</tt> option. Or pass the <tt>-DC_WINDOWS_GUI</tt> option to the C compiler and link with the GUI version of the runtime system (that's <tt>libchicken-gui[-static].lib</tt>. The GUI runtime displays error messages in a message box and does some rudimentary command-line parsing.</p><a name="compiling-very-large-files-under-windows-with-the-microsoft-c-compiler-fails-with-a-message-indicating-insufficient-heap-space"></a><h3>Compiling very large files under Windows with the Microsoft C compiler fails with a message indicating insufficient heap space.</h3><p>It seems that the Microsoft C compiler can only handle files up to a certain size, and it doesn't utilize virtual memory as well as the GNU C compiler, for example. Try closing running applications. If that fails, try to break up the Scheme code into several library units.</p><a name="when-i-run-csi-inside-an-emacs-buffer-under-windows-nothing-happens"></a><h3>When I run <tt>csi</tt> inside an emacs buffer under Windows, nothing happens.</h3><p>Invoke <tt>csi</tt> with the <tt>-:c</tt> runtime option. Under Windows the interpreter thinks it is not running under control of a terminal and doesn't print the prompt and does not flush the output stream properly.</p><a name="i-load-compiled-code-dynamically-in-a-windows-gui-application-and-it-crashes"></a><h3>I load compiled code dynamically in a Windows GUI application and it crashes.</h3><p>Code compiled into a DLL to be loaded dynamically must be linked with the same runtime system as the loading application. That means that all dynamically loaded entities (including extensions built and installed with <tt>chicken-setup</tt>) must be compiled with the <tt>-windows</tt> <tt>csc</tt> option.</p><a name="on-windows-csc-exe-seems-to-be-doing-something-wrong"></a><h3>On Windows, <tt>csc.exe</tt> seems to be doing something wrong.</h3><p>The Windows development tools include a C# compiler with the same name. Either invoke <tt>csc.exe</tt> with a full pathname, or put the directory where you installed CHICKEN in front of the MS development tool path in the <tt>PATH</tt> environment variable.</p><a name="on-windows-source-and-or-output-filenames-with-embedded-whitespace-are-not-found"></a><h3>On Windows source and/or output filenames with embedded whitespace are not found.</h3><p>There is no current workaround. Do not use filenames with embedded whitespace for code. However, command names with embedded whitespace will work correctly.</p><a name="customization"></a><h2>Customization</h2><a name="how-do-i-run-custom-startup-code-before-the-runtime-system-is-invoked"></a><h3>How do I run custom startup code before the runtime-system is invoked?</h3><p>When you invoke the C compiler for your translated Scheme source program, add the C compiler option <tt>-DC_EMBEDDED</tt>, or pass <tt>-embedded</tt> to the <tt>csc</tt> driver program, so no entry-point function will be generated (<tt>main()</tt>). When your are finished with your startup processing, invoke:</p><PRE>
<B><FONT COLOR="#0000FF">CHICKEN_main</FONT></B>(argc, argv, C_toplevel);
</PRE>
<p>where <tt>C_toplevel</tt> is the entry-point into the compiled Scheme code. You should add the following  declarations at the head of your code:</p><PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;chicken.h&quot;</FONT></B>
<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">C_toplevel</FONT></B>(C_word,C_word,C_word) C_noret;
</PRE>
<a name="how-can-i-add-compiled-user-passes"></a><h3>How can I add compiled user passes?</h3><p>To add a compiled user pass instead of an interpreted one, create a library unit and recompile the main unit of the compiler (in the file <tt>chicken.scm</tt>) with an additional <tt>uses</tt> declaration. Then link all compiler modules and your (compiled) extension to create a new version of the compiler, like this (assuming all sources are in the current directory):</p><PRE>
% cat userpass.scm
<I><FONT COLOR="#B22222">;;;; userpass.scm - My very own compiler pass
</FONT></I>
(declare (unit userpass))

<I><FONT COLOR="#B22222">;; Perhaps more user passes/extensions are added:
</FONT></I>(<B><FONT COLOR="#A020F0">let</FONT></B> ([old (user-pass)])
(user-pass
(<B><FONT COLOR="#A020F0">lambda</FONT></B> (x)
(<B><FONT COLOR="#A020F0">let</FONT></B> ([x2 (do-something-with x)])
	  (<B><FONT COLOR="#A020F0">if</FONT></B> old
	      (old x2)
	      x2) ) ) ) )
</PRE>
<pre>% csc -c -x userpass.scm
% csc chicken.scm -c -o chicken-extended.o -uses userpass
% gcc chicken-extended.o support.o easyffi.o compiler.o optimizer.o batch-driver.o c-platform.o \
c-backend.o userpass.o `csc -ldflags -libs` -o chicken-extended</pre><p>On platforms that support it (Linux ELF, Solaris, Windows + VC++), compiled code can be loaded via <tt>-extend</tt> just like source files (see <tt>load</tt> in the User's Manual).</p><a name="compiled-macros"></a><h2>Compiled macros</h2><a name="why-is-define-macro-complaining-about-unbound-variables"></a><h3>Why is <tt>define-macro</tt> complaining about unbound variables?</h3><p>Macro bodies that are defined and used in a compiled source-file are evaluated during compilation and so have no access to anything created with <tt>define</tt>. Use <tt>define-for-syntax</tt> instead.</p><a name="why-isn-t-load-properly-loading-my-library-of-macros"></a><h3>Why isn't <tt>load</tt> properly loading my library of macros?</h3><p>During compile-time, macros are only available in the source file in which they are defined. Files included via <tt>include</tt> are considered part of the containing file.</p><a name="why-is-include-unable-to-load-my-hygienic-macros"></a><h3>Why is <tt>include</tt> unable to load my hygienic macros?</h3><p>It is not sufficient for the included file to require the <tt>syntax-case</tt> extension. Call <tt>(require-extension syntax-case)</tt> <em>before</em> calling <tt>include</tt>.</p><a name="why-are-macros-not-visible-outside-of-the-compilation-unit-in-which-they-are-defined"></a><h3>Why are macros not visible outside of the compilation unit in which they are defined?</h3><p>Macros are defined during compile time, so when a file has been compiled, the definitions are gone. An exception to this rule are macros defined with <tt>define-macro</tt>, which are also visible at run-time, i.e. in <tt>eval</tt>. To use macros defined in other files, use the <tt>include</tt> special form.</p><a name="warnings-and-errors"></a><h2>Warnings and errors</h2><a name="why-does-my-program-crash-when-i-use-callback-functions-from-scheme-to-c-and-back-to-scheme-again"></a><h3>Why does my program crash when I use callback functions (from Scheme to C and back to Scheme again)?</h3><p>There are two reasons why code involving callbacks can crash out of no apparent reason:</p><ol><li>It is important to use <tt>foreign-safe-lambda/foreign-safe-lambda*</tt> for the C code that is to call back into Scheme. If this is not done than sooner or later the available stack space will be exhausted.</li><li>If the C code uses a large amount of stack storage, or if Scheme-to-C-to-Scheme calls are nested deeply, then the available nursery space on the stack will run low. To avoid this it might be advisable to run the compiled code with a larger nursery setting, i.e. run the code with <tt>-:s...</tt> and a larger value than the default (for example <tt>-:s300k</tt>), or use the <tt>-nursery</tt> compiler option.  Note that this can decrease runtime performance on some platforms.</li></ol><a name="why-does-the-linker-complain-about-a-missing-function-c-toplevel"></a><h3>Why does the linker complain about a missing function <tt>_C_..._toplevel</tt>?</h3><p>This message indicates that your program uses a library-unit, but that the object-file or library was not supplied to the linker. If you have the unit <tt>foo</tt>, which is contained in <tt>foo.o</tt> than you have to supply it to the linker like this (assuming a GCC environment):</p><p><tt>% csc program.scm foo.o -o program</tt></p><a name="why-does-the-linker-complain-about-a-missing-function-c-toplevel"></a><h3>Why does the linker complain about a missing function <tt>_C_toplevel</tt>?</h3><p>This means you have compiled a library unit as an application. When a unit-declaration (as in <tt>(declare (unit ...))</tt>) is given, then this file has a specially named toplevel entry procedure. Just remove the declaration, or compile this file to an object-module and link it to your application code.</p><a name="why-does-my-program-crash-when-i-compile-a-file-with-unsafe-or-unsafe-declarations"></a><h3>Why does my program crash when I compile a file with <tt>-unsafe</tt> or unsafe declarations?</h3><p>The compiler option <tt>-unsafe</tt> or the declaration <tt>(declare (unsafe))</tt> disable certain safety-checks to improve performance, so code that would normally trigger an error will work unexpectedly or even crash the running application. It is advisable to develop and debug a program in safe mode (without unsafe declarations) and use this feature only if the application works properly.</p><a name="why-do-i-get-a-warning-when-i-define-a-global-variable-named-match"></a><h3>Why do I get a warning when I define a global variable named <tt>match</tt>?</h3><p>Even when the <tt>match</tt> unit is not used, the macros from that package are visible in the compiler. The reason for this is that macros can not be accessed from library units (only when explicitly evaluated in running code). To speed up macro-expansion time, the compiler and the interpreter both already provide the compiled  <tt>match-...</tt> macro definitions. Macros shadowed lexically are no problem, but global definitions of variables named identically to (global) macros are useless - the macro definition shadows the global variable.</p><p>This problem can be solved using a different name or undefining the macro, like this:</p><PRE>
(eval-when (compile eval) (undefine-macro! 'match))
</PRE>
<a name="why-don-t-toplevel-continuations-captured-in-interpreted-code-work"></a><h3>Why don't toplevel-continuations captured in interpreted code work?</h3><p>Consider the following piece of code:</p><PRE>
  
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">k</FONT></B> (call-with-current-continuation (<B><FONT COLOR="#A020F0">lambda</FONT></B> (k) k)))
(k k)
</PRE>
<p>When compiled, this will loop endlessly. But when interpreted, <tt>(k k)</tt> will return to the read-eval-print loop! This happens because the continuation captured will eventually read the next toplevel expression from the standard-input (or an input-file if loading from a file). At the moment <tt>k</tt> was defined, the next expression was <tt>(k k)</tt>. But when <tt>k</tt> is invoked, the next expression will be whatever follows after <tt>(k k)</tt>. In other words, invoking a captured continuation will not rewind the file-position of the input source. A solution is to wrap the whole code into a <tt>(begin ...)</tt> expression, so all toplevel expressions will be loaded together.</p><a name="why-does-define-reader-ctor-not-work-in-my-compiled-program"></a><h3>Why does <tt>define-reader-ctor</tt> not work in my compiled program?</h3><p>The following piece of code does not work as expected:</p><PRE>
(eval-when (compile)
(define-reader-ctor 'integer-&gt;char integer-&gt;char) )
(print #,(integer-&gt;char 33))
</PRE>
<p>The problem is that the compiler reads the complete source-file before doing any processing on it, so the sharp-comma form is encountered before the reader-ctor is defined. A possible solution is to include the file containing the sharp-comma form, like this:</p><PRE>
(eval-when (compile)
(define-reader-ctor 'integer-&gt;char integer-&gt;char) )

(include <B><FONT COLOR="#BC8F8F">&quot;other-file&quot;</FONT></B>)
</PRE>
<PRE>
<I><FONT COLOR="#B22222">;;; other-file.scm:
</FONT></I>(print #,(integer-&gt;char 33))
</PRE>
<a name="why-do-built-in-units-such-as-srfi-1-srfi-18-and-posix-fail-to-load"></a><h3>Why do built-in units, such as srfi-1, srfi-18, and posix fail to load?</h3><p>When you try to <tt>use</tt> a built-in unit such as <tt>srfi-18</tt>, you may get the following error:</p><PRE>
#<I><FONT COLOR="#B22222">;1&gt; (use srfi-18)
</FONT></I><I><FONT COLOR="#B22222">; loading library srfi-18 ...
</FONT></I>Error: (load-library) unable to load library
srfi-18
<B><FONT COLOR="#BC8F8F">&quot;dlopen(libchicken.dylib, 9): image not found&quot;</FONT></B>                <I><FONT COLOR="#B22222">;; on a Mac
</FONT></I><B><FONT COLOR="#BC8F8F">&quot;libchicken.so: cannot open shared object file: No such file or directory&quot;</FONT></B>  <I><FONT COLOR="#B22222">;; Linux
</FONT></I></PRE>
<p>Another symptom is that <tt>(require 'srfi-18)</tt> will silently fail.</p><p>This typically happens because the Chicken libraries have been installed in a non-standard location, such as your home directory.  The workaround is to explicitly tell the dynamic linker where to look for your libraries:</p><pre>export DYLD_LIBRARY_PATH=~/scheme/chicken/lib:$DYLD_LIBRARY_PATH ;; Mac
export LD_LIBRARY_PATH=~/scheme/chicken/lib:$LD_LIBRARY_PATH    ;; Linux</pre><a name="how-can-i-increase-the-size-of-the-trace-shown-when-runtime-errors-are-detected"></a><h3>How can I increase the size of the trace shown when runtime errors are detected?</h3><p>When a runtime error is detected, Chicken will print the last entries from the trace of functions called (unless your executable was compiled with the <tt>-no-trace</tt> option. By default, only 16 entries will be shown. To increase this number pass the <tt>-:aN</tt> parameter to your executable.</p><a name="optimizations"></a><h2>Optimizations</h2><a name="how-can-i-obtain-smaller-executables"></a><h3>How can I obtain smaller executables?</h3><p>If you don't need <tt>eval</tt> or the stuff in the <tt>extras</tt> library unit,  you can just use the <tt>library</tt> unit:</p><PRE>
	(declare (uses library))
	(display <B><FONT COLOR="#BC8F8F">&quot;Hello, world!\n&quot;</FONT></B>)
</PRE>
<p>(Don't forget to compile with the <tt>-explicit-use</tt> option) Compiled with Visual C++ this generates an executable of around 240 kilobytes. It is theoretically possible to compile something without the library, but a program would have to implement quite a lot of support code on its own.</p><a name="how-can-i-obtain-faster-executables"></a><h3>How can I obtain faster executables?</h3><p>There are a number of declaration specifiers that should be used to speed up compiled files: declaring <tt>(standard-bindings)</tt> is mandatory, since this enables most optimizations. Even if some standard procedures should be redefined, you can list untouched bindings in the declaration. Declaring <tt>(extended-bindings)</tt> lets the compiler choose faster versions of certain internal library functions. This might give another speedup. You can also use the the <tt>usual-integrations</tt> declaration, which is identical to declaring <tt>standard-bindings</tt> and <tt>extended-bindings</tt> (note that <tt>usual-integrations</tt> is set by default). Declaring <tt>(block)</tt> tells the compiler that global procedures are not changed outside the current compilation unit, this gives the compiler some more  opportunities for optimization. If no floating point arithmetic is required, then declaring <tt>(number-type fixnum)</tt> can give a big performance improvement, because the compiler can now inline most arithmetic operations.  Declaring <tt>(unsafe)</tt> will switch off most safety checks. If threads are not used, you can declare <tt>(disable-interrupts)</tt>. You should always use maximum optimizations settings for your C compiler. Good GCC compiler options on Pentium (and compatible) hardware are: <tt>-Os -fomit-frame-pointer -fno-strict-aliasing</tt> Some programs are very sensitive to the setting of the nursery (the first heap-generation). You should experiment with different nursery settings (either by compiling with the <tt>-nursery</tt> option or by using the <tt>-:s...</tt> runtime option).</p><a name="which-non-standard-procedures-are-treated-specially-when-the-extended-bindings-or-usual-integrations-declaration-or-compiler-option-is-used"></a><h3>Which non-standard procedures are treated specially when the <tt>extended-bindings</tt> or <tt>usual-integrations</tt> declaration or compiler option is used?</h3><p>The following standard bindings are handled specially, depending on optimization options and compiler settings:</p><pre><tt>+</tt> <tt>*</tt> <tt>-</tt> <tt>/</tt> <tt>quotient</tt> <tt>eq?</tt> <tt>eqv?</tt> <tt>equal?</tt> <tt>apply</tt> <tt>c...r</tt> <tt>values</tt> <tt>call-with-values</tt>
<tt>list-ref</tt> <tt>null?</tt> <tt>length</tt> <tt>not</tt> <tt>char?</tt> <tt>string?</tt> <tt>symbol?</tt> <tt>vector?</tt> <tt>pair?</tt> <tt>procedure?</tt>
<tt>boolean?</tt> <tt>number?</tt> <tt>complex?</tt> <tt>rational?</tt> <tt>real?</tt> <tt>exact?</tt> <tt>inexact?</tt> <tt>list?</tt> <tt>eof-object?</tt>
<tt>string-ref</tt> <tt>string-set!</tt> <tt>vector-ref</tt> <tt>vector-set!</tt> <tt>char=?</tt> <tt>char&lt;?</tt> <tt>char&gt;?</tt> <tt>char&lt;=?</tt> <tt>char&gt;=?</tt>
<tt>char-numeric?</tt> <tt>char-alphabetic?</tt> <tt>char-whitespace?</tt> <tt>char-upper-case?</tt>
<tt>char-lower-case?</tt> <tt>char-upcae</tt> <tt>char-downcase</tt> <tt>list-tail</tt> <tt>assv</tt> <tt>memv</tt> <tt>memq</tt> <tt>assoc</tt>
<tt>member</tt> <tt>set-car!</tt> <tt>set-cdr!</tt> <tt>abs</tt> <tt>exp</tt> <tt>sin</tt> <tt>cos</tt> <tt>tan</tt> <tt>log</tt> <tt>asin</tt> <tt>acos</tt> <tt>atan</tt> <tt>sqrt</tt>
<tt>zero?</tt> <tt>positive?</tt> <tt>negative?</tt> <tt>vector-length</tt> <tt>string-length</tt> <tt>char-&gt;integer</tt>
<tt>integer-&gt;char</tt> <tt>inexact-&gt;exact</tt> <tt>=</tt> <tt>&gt;</tt> <tt>&lt;</tt> <tt>&gt;=</tt> <tt>&lt;=</tt> <tt>for-each</tt> <tt>map</tt> <tt>substring</tt>
<tt>string-append</tt> <tt>gcd</tt> <tt>lcm</tt> <tt>list</tt> <tt>exact-&gt;inexact</tt> <tt>string-&gt;number</tt> <tt>number-&gt;string</tt>
<tt>even?</tt> <tt>odd?</tt> <tt>remainder</tt> <tt>floor</tt> <tt>ceiling</tt> <tt>truncate</tt> <tt>round</tt> <tt>cons</tt> <tt>vector</tt> <tt>string</tt>
<tt>string=?</tt> <tt>string-ci=?</tt> <tt>make-vector</tt> <tt>call-with-current-continuation</tt>
<tt>write-char</tt> <tt>read-string</tt> </pre><p>The following extended bindings are handled specially: </p><p><tt>bitwise-and</tt> <tt>bitwise-ior</tt> <tt>bitwise-xor</tt> <tt>bitwise-not</tt>  <tt>bit-set?</tt> <tt>add1</tt> <tt>sub1</tt> <tt>fx+</tt> <tt>fx-</tt> <tt>fx*</tt> <tt>fx/</tt> <tt>fxmod</tt> <tt>fx=</tt> <tt>fx&gt;</tt> <tt>fx&gt;=</tt> <tt>fixnum?</tt> <tt>fxneg</tt> <tt>fxmax</tt> <tt>fxmin</tt> <tt>fxand</tt> <tt>fxior</tt> <tt>fxxor</tt> <tt>fxnot</tt> <tt>fxshl</tt> <tt>fxshr</tt> <tt>flonum?</tt> <tt>fp+</tt> <tt>fp-</tt> <tt>fp*</tt> <tt>fp/</tt> <tt>atom?</tt> <tt>fp=</tt> <tt>fp&gt;</tt> <tt>fp&gt;=</tt> <tt>fpneg</tt> <tt>fpmax</tt> <tt>fpmin</tt> <tt>arithmetic-shift</tt> <tt>signum</tt> <tt>flush-output</tt> <tt>thread-specific</tt> <tt>thread-specific-set!</tt> <tt>not-pair?</tt> <tt>null-list?</tt> <tt>print</tt> <tt>print*</tt> <tt>u8vector-&gt;blob/shared</tt> <tt>s8vector-&gt;blob/shared</tt> <tt>u16vector-&gt;blob/shared</tt> <tt>s16vector-&gt;blob/shared</tt> <tt>u32vector-&gt;blob/shared</tt> <tt>s32vector-&gt;blob/shared</tt> <tt>f32vector-&gt;blob/shared</tt> <tt>f64vector-&gt;blob/shared</tt> <tt>block-ref</tt> <tt>blob-size</tt> <tt>u8vector-length</tt> <tt>s8vector-length</tt> <tt>u16vector-length</tt> <tt>s16vector-length</tt> <tt>u32vector-length</tt> <tt>s32vector-length</tt> <tt>f32vector-length</tt> <tt>f64vector-length</tt> <tt>u8vector-ref</tt> <tt>s8vector-ref</tt> <tt>u16vector-ref</tt> <tt>s16vector-ref</tt> <tt>u32vector-ref</tt> <tt>s32vector-ref</tt> <tt>f32vector-ref</tt> <tt>f64vector-ref</tt> <tt>u8vector-set!</tt> <tt>s8vector-set!</tt> <tt>u16vector-set!</tt> <tt>s16vector-set!</tt> <tt>u32vector-set!</tt> <tt>s32vector-set!</tt> <tt>hash-table-ref</tt> <tt>block-set!</tt> <tt>number-of-slots</tt> <tt>first</tt> <tt>second</tt> <tt>third</tt> <tt>fourth</tt> <tt>null-pointer?</tt> <tt>pointer-&gt;object</tt> <tt>make-record-instance</tt> <tt>locative-ref</tt> <tt>locative-set!</tt> <tt>locative?</tt> <tt>locative-&gt;object</tt> <tt>identity</tt> <tt>cpu-time</tt> <tt>error</tt> <tt>call/cc</tt> <tt>any?</tt> <tt>substring=?</tt> <tt>substring-ci=?</tt> <tt>substring-index</tt> <tt>substring-index-ci</tt></p><a name="can-i-load-compiled-code-at-runtime"></a><h3>Can I load compiled code at runtime?</h3><p>Yes. You can load compiled at code at runtime with <tt>load</tt> just as well as you can load Scheme source code. Compiled code will, of course, run faster.</p><p>To do this, pass to <tt>load</tt> a path for a shared object. Use a form such as <tt>(load "foo.so")</tt> and run <tt>csc -shared foo.scm</tt> to produce <tt>foo.so</tt> from <tt>foo.scm</tt> (at which point <tt>foo.scm</tt> will no longer be required).</p><a name="garbage-collection"></a><h2>Garbage collection</h2><a name="why-does-a-loop-that-doesn-t-cons-still-trigger-garbage-collections"></a><h3>Why does a loop that doesn't <tt>cons</tt> still trigger garbage collections?</h3><p>Under CHICKENs implementation policy, tail recursion is achieved simply by avoiding to return from a function call. Since the programs are CPS converted, a continuous  sequence of nested procedure calls is performed. At some stage the stack-space has to run out and the current procedure and its parameters (including the current continuation) are stored somewhere in the runtime system. Now a minor garbage collection occurs and rescues all live data from the stack (the first heap generation) and moves it into the the second heap generation. Then the stack is cleared (using a <tt>longjmp</tt>) and execution can continue from the saved state. With this method arbitrary recursion (in tail- or non-tail position) can happen,  provided the application doesn't run out of heap-space. (The difference between a tail- and a non-tail call is that the tail-call has no live data after it invokes its continuation - and so the amount of heap-space needed stays constant)</p><a name="why-do-finalizers-not-seem-to-work-in-simple-cases-in-the-interpeter"></a><h3>Why do finalizers not seem to work in simple cases in the interpeter?</h3><p>Consider the following interaction in CSI:</p><pre>#;1&gt; (define x '(1 2 3))
#;2&gt; (define (yammer x) (print x " is dead"))
#;3&gt; (set-finalizer! x yammer)
(1 2 3)
#;4&gt; (gc #t)
157812
#;5&gt; (define x #f)
#;6&gt; (gc #t)
157812
#;7&gt;</pre><p>While you might expect objects to be reclaimed and "<em>(1 2 3) is dead</em>" printed, it won't happen: the literal list gets held in the interpreter history, because it is the result value of the set-finalizer! call. Running this in a normal program will work fine.</p><p>When testing finalizers from the interpreter, you might want to define a trivial macro such as</p><pre>(define-macro (v x) `(begin (print ,x) (void)))</pre><p>and wrap calls to <tt>set-finalizer!</tt> in it.</p><a name="interpreter"></a><h2>Interpreter</h2><a name="does-csi-support-history-and-autocompletion"></a><h3>Does CSI support history and autocompletion?</h3><p>CSI doesn't support it natively but it can be activated with the <a href="http://www.call-with-current-continuation.org/eggs/readline.html" class="external">http://www.call-with-current-continuation.org/eggs/readline.html</a> egg. After installing the egg, add the following to your <tt>~/.csirc</tt> or equivalent file:</p><PRE>
(require-extension readline)
(current-input-port (make-gnu-readline-port))
(gnu-history-install-file-manager (string-append (<B><FONT COLOR="#A020F0">or</FONT></B> (getenv <B><FONT COLOR="#BC8F8F">&quot;HOME&quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;/.csi.history&quot;</FONT></B>))
</PRE>
<p>Users of *nix-like systems (including Cygwin), may also want to check out <a href="http://utopia.knoware.nl/~hlub/rlwrap/" class="external">rlwrap</a>.  This program lets you "wrap" another process (e.g. <tt>rlwrap csi</tt>) with the readline library, giving you history, autocompletion, and the ability to set the keystroke set. Vi fans can get vi keystrokes by adding "set editing-mode vi" to their <tt>.inputrc</tt> file.</p><a name="does-code-loaded-with-load-run-compiled-or-interpreted"></a><h3>Does code loaded with <tt>load</tt> run compiled or interpreted?</h3><p>If you compile a file with a call to <tt>load</tt>, the code will be loaded at runtime and, if the file loaded is a Scheme source code file (instead of a shared object), it will be interpreted (even if the caller program is compiled).</p><a name="extensions"></a><h2>Extensions</h2><a name="how-can-i-install-chicken-eggs-to-a-non-default-location"></a><h3>How can I install Chicken eggs to a non-default location?</h3><p>You can just set the <tt>CHICKEN_REPOSITORY</tt> environment variable. It should contain the path where you want eggs to be installed:</p><pre>$ export CHICKEN_REPOSITORY=~/chicken/
$ chicken-setup extensionname</pre><p>In order to make programs (including csi) see these eggs, you should set this variable when you run them. Alternatively, you can call the <tt>repository-path</tt> Scheme procedure before loading the eggs, as in:</p><PRE>
(repository-path <B><FONT COLOR="#BC8F8F">&quot;/home/azul/chicken&quot;</FONT></B>)
(use format-modular)
</PRE>
<p>Note, however, that using <tt>repository-path</tt> as above hard-codes the location of your eggs in your source files.  While this might not be an issue in your case, it might be safe to keep this configuration outside of the source code (that is, specifying it as an environment variable) to make it easier to maintain.</p><a name="can-i-install-chicken-eggs-as-a-non-root-user"></a><h3>Can I install chicken eggs as a non-root user?</h3><p>Yes, just <a href="http://galinha.ucpel.tche.br/FAQ#Extensions#How can I install Chicken eggs to a non-default location?" class="external">install them in a directory you can write</a>.</p><hr/><p>Previous: <a href="bugs-and-limitations.html" class="internal">Bugs and limitations</a></p><p>Next: <a href="acknowledgements.html" class="internal">Acknowledgements</a></p>
</body></html>