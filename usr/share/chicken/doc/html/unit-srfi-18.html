<html><head><title>CHICKEN User's Manual - Unit srfi-18</title></head><body>
<a name="unit-srfi-18"></a><h1>Unit srfi-18</h1><p>A simple multithreading package. This threading package follows largely the specification of SRFI-18. For more information see the documentation for <a href="http://srfi.schemers.org/srfi-18/srfi-18.html" class="external">SRFI-18</a>.</p><p><strong>Notes:</strong></p><ul><li><tt>thread-start!</tt> accepts a thunk (a zero argument procedure) as argument, which is equivalent to <tt>(thread-start! (make-thread THUNK))</tt>.</li><li><tt>thread-sleep!</tt> accepts a seconds real number value in addition to a time object.</li><li>When an uncaught exception (i.e. an error) is signalled in a thread other than the primordial thread and warnings are enabled (see: <tt>enable-warnings</tt>, then a warning message is written to the port that is the value of <tt>(current-error-port)</tt>.</li><li>Blocking I/O will block all threads, except for some socket operations (see the section about the <tt>tcp</tt> unit). An exception is the read-eval-print loop on UNIX platforms: waiting for input will not block other threads, provided the current input port reads input from a console.</li><li>It is generally not a good idea for one thread to call a continuation created by another thread, if <tt>dynamic-wind</tt> is involved.</li><li>When more than one thread compete for the current time-slice, the thread that was waiting first will become the next runnable thread.</li><li>The dynamic environment of a thread consists of the following state:<ul><li>The current input-, output- and error-port</li><li>The current exception handler</li><li>The values of all current parameters (created by <tt>make-parameter</tt>)</li><li>Any pending <tt>dynamic-wind</tt> thunks.</li></ul></li></ul><p>The following procedures are provided, in addition to the procedures defined in SRFI-18:</p><a name="thread-signal"></a><h2>thread-signal!</h2><pre>[procedure] (thread-signal! THREAD X)</pre><p>This will cause <tt>THREAD</tt> to signal the condition <tt>X</tt> once it is scheduled for execution. After signalling the condition, the thread continues with its normal execution.</p><a name="thread-quantum"></a><h2>thread-quantum</h2><pre>[procedure] (thread-quantum THREAD)</pre><p>Returns the quantum of <tt>THREAD</tt>, which is an exact integer specifying the approximate time-slice of the thread in milliseconds.</p><a name="thread-quantum-set"></a><h2>thread-quantum-set!</h2><pre>[procedure] (thread-quantum-set! THREAD QUANTUM)</pre><p>Sets the quantum of <tt>THREAD</tt> to <tt>QUANTUM</tt>.</p><a name="thread-suspend"></a><h2>thread-suspend!</h2><pre>[procedure] (thread-suspend! THREAD)</pre><p>Suspends the execution of <tt>THREAD</tt> until resumed.</p><a name="thread-resume"></a><h2>thread-resume!</h2><pre>[procedure] (thread-resume! THREAD)</pre><p>Readies the suspended thread <tt>THREAD</tt>.</p><a name="thread-wait-for-i-o"></a><h2>thread-wait-for-i/o!</h2><pre>[procedure] (thread-wait-for-i/o! FD [MODE])</pre><p>Suspends the current thread until input (<tt>MODE</tt> is <tt>#:input</tt>), output (<tt>MODE</tt> is <tt>#:output</tt>) or both (<tt>MODE</tt> is <tt>#:all</tt>) is available. <tt>FD</tt> should be a file-descriptor (not a port!) open for input or output, respectively.</p><a name="time-milliseconds"></a><h2>time&rarr;milliseconds</h2><pre>[procedure] (time-&gt;milliseconds TIME)</pre><p>Converts a time object (as created via <tt>current-time</tt>) into an exact integer representing the number of milliseconds since process startup.</p><a name="milliseconds-time"></a><h2>milliseconds&rarr;time</h2><pre>[procedure] (milliseconds-&gt;time ms)</pre><p>Converts into a time object an exact integer representing the number of milliseconds since process startup.</p><p>This procedure may be useful in combination with <tt>thread-sleep!</tt> when your compilation unit is using <tt>(declare fixnum-arithmetic)</tt>.  In that case you won't be able to pass an inexact value to <tt>thread-sleep!</tt>, but you can do the following:</p><pre>(define (thread-sleep!/ms ms)
  (thread-sleep!
   (milliseconds-&gt;time (+ ms (current-milliseconds)))))</pre><p>Previous: <a href="unit-regex.html" class="internal">Unit regex</a></p><p>Next: <a href="unit-posix.html" class="internal">Unit posix</a></p>
</body></html>