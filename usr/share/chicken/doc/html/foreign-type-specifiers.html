<html><head><title>CHICKEN User's Manual - Foreign type specifiers</title></head><body>
<a name="foreign-type-specifiers"></a><h1>Foreign type specifiers</h1><p>Here is a list of valid foreign type specifiers:</p><a name="scheme-object"></a><h2>scheme-object</h2><p>An arbitrary Scheme data object (immediate or non-immediate). </p><a name="bool"></a><h2>bool</h2><p>As argument: any value (<tt>#f</tt> is false, anything else is true).</p><p>As result: anything different from 0 and the <tt>NULL</tt> pointer is <tt>#t</tt>.</p><a name="byte-unsigned-byte"></a><h2>byte unsigned-byte</h2><p>A byte.</p><a name="char-unsigned-char"></a><h2>char unsigned-char</h2><p>A character.</p><a name="short-unsigned-short"></a><h2>short unsigned-short</h2><p>A short integer number.</p><a name="int-unsigned-int-int32-unsigned-int32"></a><h2>int unsigned-int int32 unsigned-int32</h2><p>An small integer number in fixnum range (at least 30 bit).</p><a name="integer-unsigned-integer-integer32-unsigned-integer32-integer64"></a><h2>integer unsigned-integer integer32 unsigned-integer32 integer64</h2><p>Either a fixnum or a flonum in the range of a (unsigned) machine <em>int</em> or with 32/64 bit width.</p><a name="long-unsigned-long"></a><h2>long unsigned-long</h2><p>Either a fixnum or a flonum in the range of a (unsigned) machine <em>long</em> or with 32 bit width.</p><a name="float-double"></a><h2>float double</h2><p>A floating-point number. If an exact integer is passed as an argument, then it is automatically converted to a float.</p><a name="number"></a><h2>number</h2><p>A floating-point number. Similar to <tt>double</tt>, but when used as a result type, then either an exact integer or a floating-point number is returned, depending on whether the result fits into an exact integer or not.</p><a name="symbol"></a><h2>symbol</h2><p>A symbol, which will be passed to foreign code as a zero-terminated string.</p><p>When declared as the result of foreign code, the result should be a string and a symbol with the same name will be interned in the symbol table (and returned to the caller).</p><a name="scheme-pointer"></a><h2>scheme-pointer</h2><p>An untyped pointer to the contents of a non-immediate Scheme object (not allowed as return type). The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer.</p><p>Don't confuse this type with <tt>(c-pointer ...)</tt> which means something different (a machine-pointer object).</p><a name="nonnull-scheme-pointer"></a><h2>nonnull-scheme-pointer</h2><p>As <tt>scheme-pointer</tt>, but guaranteed not to be <tt>#f</tt>.</p><p>Don't confuse this type with <tt>(nonnull-c-pointer ...)</tt> which means something different (a machine-pointer object).</p><a name="c-pointer"></a><h2>c-pointer</h2><p>An untyped operating-system pointer or a locative. The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer. If uses as the type of a return value, a <tt>NULL</tt> pointer will be returned as <tt>#f</tt>.</p><a name="nonnull-c-pointer"></a><h2>nonnull-c-pointer</h2><p>As <tt>c-pointer</tt>, but guaranteed not to be <tt>#f/NULL</tt>.</p><a name="blob"></a><h2>blob</h2><p>A blob object, passed as a pointer to its contents. Arguments of type <tt>blob</tt> may optionally be <tt>#f</tt>, which is passed as a NULL pointer.</p><p>This is not allowed as a return type.</p><a name="nonnull-blob"></a><h2>nonnull-blob</h2><p>As <tt>blob</tt>, but guaranteed not to be <tt>#f</tt>.</p><a name="u8vector-u16vector-u32vector-s8vector-s16vector-s32vector-f32vector-f64vector"></a><h2>u8vector u16vector u32vector s8vector s16vector s32vector f32vector f64vector</h2><p>A SRFI-4 number-vector object, passed as a pointer to its contents.</p><p>These type specifiers are not allowed as return types.</p><a name="nonnull-u8vector-nonnull-u16vector-nonnull-u32vector-nonnull-s8vector-nonnull-s16vector-nonnull-s32vector-nonnull-f32vector-nonnull-f64vector"></a><h2>nonnull-u8vector nonnull-u16vector nonnull-u32vector nonnull-s8vector nonnull-s16vector nonnull-s32vector nonnull-f32vector nonnull-f64vector</h2><p>As <tt>u8vector ...</tt>, but guaranteed not to be <tt>#f</tt>.</p><a name="c-string"></a><h2>c-string</h2><p>A C string (zero-terminated). The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer. If uses as the type of a return value, a <tt>NULL</tt> pointer will be returned as <tt>#f</tt>. Note that the string is copied (with a zero-byte appended) when passed as an argument to a foreign function. Also a return value of this type is copied into garbage collected memory.</p><a name="nonnull-c-string"></a><h2>nonnull-c-string</h2><p>As <tt>c-string</tt>, but guaranteed not to be <tt>#f/NULL</tt>.</p><a name="nonnull-c-string"></a><h2>[nonnull-] c-string*</h2><p>Similar to <tt>[nonnull-] c-string</tt>, but if used as a result-type, the pointer returned by the foreign code will be freed (using the C-libraries <tt>free(1)</tt>) after copying. This type specifier is not valid as a result type for callbacks defined with <tt>define-external</tt>.</p><a name="nonnull-unsigned-c-string"></a><h2>[nonnull-] unsigned-c-string[*]</h2><p>Same as <tt>c-string</tt>, but maps to the <tt>unsigned char *</tt> C type.</p><a name="c-string-list"></a><h2>c-string-list</h2><p>Expects a pointer to a list of C strings teminated by a <tt>NULL</tt> pointer and returns a list of strings.</p><p>Only valid as a result type of non-callback functions.</p><a name="c-string-list"></a><h2>c-string-list*</h2><p>Similar to <tt>c-string-list</tt> but releases the storage of each string and the pointer array using <tt>free(1)</tt>.</p><a name="void"></a><h2>void</h2><p>Specifies an undefined return value.</p><p>Not allowed as argument type.</p><a name="const-type"></a><h2>(const TYPE)</h2><p>The foreign type <tt>TYPE</tt> with an additional <tt>const</tt> specifier.</p><a name="enum-name"></a><h2>(enum NAME)</h2><p>An enumeration type. Handled internally as an <tt>integer</tt>.</p><a name="c-pointer-type"></a><h2>(c-pointer TYPE)</h2><p>An operating-system pointer or a locative to an object of <tt>TYPE</tt>.</p><a name="nonnull-c-pointer-type"></a><h2>(nonnull-c-pointer TYPE)</h2><p>As <tt>(c-pointer TYPE)</tt>, but guaranteed not to be <tt>#f/NULL</tt>.</p><a name="ref-type"></a><h2>(ref TYPE)</h2><p>A C++ reference type. Reference types are handled the same way as pointers inside Scheme code.</p><a name="struct-name"></a><h2>(struct NAME)</h2><p>A struct of the name <tt>NAME</tt>, which should be a string.</p><p>Structs cannot be directly passed as arguments to foreign function, neither can they be result values. Pointers to structs are allowed, though.</p><a name="template-type-argtype"></a><h2>(template TYPE ARGTYPE ...)</h2><p>A C++ template type. For example <tt>vector&lt;int&gt;</tt> would be specified as <tt>(template "vector" int)</tt>.</p><p>Template types cannot be directly passed as arguments or returned as results.</p><a name="union-name"></a><h2>(union NAME)</h2><p>A union of the name <tt>NAME</tt>, which should be a string.</p><p>Unions cannot be directly passed as arguments to foreign function, neither can they be result values. Pointers to unions are allowed, though.</p><a name="instance-cname-schemeclass"></a><h2>(instance CNAME SCHEMECLASS)</h2><p>A pointer to a C++ class instance. <tt>CNAME</tt> should designate the name of the C++ class, and <tt>SCHEMECLASS</tt> should be the class that wraps the instance pointer. Normally <tt>SCHEMECLASS</tt> should be a subclass of <tt>&lt;c++-object&gt;</tt>.</p><a name="instance-ref-cname-schemeclass"></a><h2>(instance-ref CNAME SCHEMECLASS)</h2><p>A reference to a C++ class instance. </p><a name="function-resulttype-argumenttype1-callconv"></a><h2>(function RESULTTYPE (ARGUMENTTYPE1 ... [...]) [CALLCONV])</h2><p>A function pointer. <tt>CALLCONV</tt> specifies an optional calling convention and should be a string. The meaning of this string is entirely platform dependent. The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer.</p><a name="mappings"></a><h2>Mappings</h2><p>Foreign types are mapped to C types in the following manner:</p><table><tr><td><p>bool</p></td><td><p>int</p></td></tr><tr><td><p>[unsigned-]char</p></td><td><p>[unsigned] char</p></td></tr><tr><td><p>[unsigned-]short</p></td><td><p>[unsigned] short</p></td></tr><tr><td><p>[unsigned-]int</p></td><td><p>[unsigned] int</p></td></tr><tr><td><p>[unsigned-]integer</p></td><td><p>[unsigned] int</p></td></tr><tr><td><p>[unsigned-]long</p></td><td><p>[unsigned] long</p></td></tr><tr><td><p>float</p></td><td><p>float</p></td></tr><tr><td><p>double</p></td><td><p>double</p></td></tr><tr><td><p>number</p></td><td><p>double</p></td></tr><tr><td><p>[nonnull-]c-pointer</p></td><td><p>void *</p></td></tr><tr><td><p>[nonnull-]blob</p></td><td><p>unsigned char *</p></td></tr><tr><td><p>[nonnull-]u8vector</p></td><td><p>unsigned char *</p></td></tr><tr><td><p>[nonnull-]s8vector</p></td><td><p>char *</p></td></tr><tr><td><p>[nonnull-]u16vector</p></td><td><p>unsigned short *</p></td></tr><tr><td><p>[nonnull-]s16vector</p></td><td><p>short *</p></td></tr><tr><td><p>[nonnull-]u32vector</p></td><td><p>uint32_t *</p></td></tr><tr><td><p>[nonnull-]s32vector</p></td><td><p>int32_t *</p></td></tr><tr><td><p>[nonnull-]f32vector</p></td><td><p>float *</p></td></tr><tr><td><p>[nonnull-]f64vector</p></td><td><p>double *</p></td></tr><tr><td><p>[nonnull-]c-string</p></td><td><p>char *</p></td></tr><tr><td><p>[nonnull-]unsigned-c-string</p></td><td><p>unsigned char *</p></td></tr><tr><td><p>c-string-list</p></td><td><p>char **</p></td></tr><tr><td><p>symbol</p></td><td><p>char *</p></td></tr><tr><td><p>void</p></td><td><p>void</p></td></tr><tr><td><p>([nonnull-]c-pointer TYPE)</p></td><td><p>TYPE *</p></td></tr><tr><td><p>(enum NAME)</p></td><td><p>enum NAME</p></td></tr><tr><td><p>(struct NAME)</p></td><td><p>struct NAME</p></td></tr><tr><td><p>(ref TYPE)</p></td><td><p>TYPE &amp;</p></td></tr><tr><td><p>(template T1 T2 ...)</p></td><td><p>T1&lt;T2, ...&gt;</p></td></tr><tr><td><p>(union NAME)</p></td><td><p>union NAME</p></td></tr><tr><td><p>(function RTYPE (ATYPE ...) [CALLCONV])</p></td><td><p>[CALLCONV] RTYPE (*)(ATYPE, ...)</p></td></tr><tr><td><p>(instance CNAME SNAME)</p></td><td><p>CNAME *</p></td></tr><tr><td><p>(instance-ref CNAME SNAME)</p></td><td><p>CNAME &amp;</p></td></tr></table><p>Previous: <a href="accessing-external-objects.html" class="internal">Accessing external objects</a></p><p>Next: <a href="embedding.html" class="internal">Embedding</a></p>
</body></html>