<html><head><title>CHICKEN User's Manual - Unit srfi-4</title></head><body>
<p> </p><a name="unit-srfi-4"></a><h1>Unit srfi-4</h1><p>Homogeneous numeric vectors, see the documentation for <a href="http://srfi.schemers.org/srfi-4/srfi-4.html" class="external">SRFI-4</a> 64-bit integer vectors (<tt>u64vector</tt> and <tt>s64vector</tt> are not supported.</p><p>The basic constructor procedures for number vectors are extended to allow allocating the storage in non garbage collected memory:</p><a name="make-xxxvector"></a><h2>make-XXXvector</h2><pre>[procedure] (make-XXXvector SIZE [INIT NONGC FINALIZE])</pre><p>Creates a SRFI-4 homogenous number vector of length <tt>SIZE</tt>. If <tt>INIT</tt> is given, it specifies the initial value for each slot in the vector. The optional arguments <tt>NONGC</tt> and <tt>FINALIZE</tt> define whether the vector should be allocated in a memory area not subject to garbage collection and whether the associated storage should be automatically freed (using finalization) when there are no references from Scheme variables and data. <tt>NONGC</tt> defaults to <tt>#f</tt> (the vector will be located in normal garbage collected memory) and <tt>FINALIZE</tt> defaults to  <tt>#t</tt>. Note that the <tt>FINALIZE</tt> argument is only used when <tt>NONGC</tt> is true.</p><p>Additionally, the following procedures are provided:</p><a name="u8vector-blob"></a><h2>u8vector&rarr;blob</h2><a name="s8vector-blob"></a><h2>s8vector&rarr;blob</h2><a name="u16vector-blob"></a><h2>u16vector&rarr;blob</h2><a name="s16vector-blob"></a><h2>s16vector&rarr;blob</h2><a name="u32vector-blob"></a><h2>u32vector&rarr;blob</h2><a name="s32vector-blob"></a><h2>s32vector&rarr;blob</h2><a name="f32vector-blob"></a><h2>f32vector&rarr;blob</h2><a name="f64vector-blob"></a><h2>f64vector&rarr;blob</h2><a name="u8vector-blob-shared"></a><h2>u8vector&rarr;blob/shared</h2><a name="s8vector-blob-shared"></a><h2>s8vector&rarr;blob/shared</h2><a name="u16vector-blob-shared"></a><h2>u16vector&rarr;blob/shared</h2><a name="s16vector-blob-shared"></a><h2>s16vector&rarr;blob/shared</h2><a name="u32vector-blob-shared"></a><h2>u32vector&rarr;blob/shared</h2><a name="s32vector-blob-shared"></a><h2>s32vector&rarr;blob/shared</h2><a name="f32vector-blob-shared"></a><h2>f32vector&rarr;blob/shared</h2><a name="f64vector-blob-shared"></a><h2>f64vector&rarr;blob/shared</h2><pre>[procedure] (u8vector-&gt;blob U8VECTOR)
[procedure] (s8vector-&gt;blob S8VECTOR)
[procedure] (u16vector-&gt;blob U16VECTOR)
[procedure] (s16vector-&gt;blob S16VECTOR)
[procedure] (u32vector-&gt;blob U32VECTOR)
[procedure] (s32vector-&gt;blob S32VECTOR)
[procedure] (f32vector-&gt;blob F32VECTOR)
[procedure] (f64vector-&gt;blob F64VECTOR)
[procedure] (u8vector-&gt;blob/shared U8VECTOR)
[procedure] (s8vector-&gt;blob/shared S8VECTOR)
[procedure] (u16vector-&gt;blob/shared U16VECTOR)
[procedure] (s16vector-&gt;blob/shared S16VECTOR)
[procedure] (u32vector-&gt;blob/shared U32VECTOR)
[procedure] (s32vector-&gt;blob/shared S32VECTOR)
[procedure] (f32vector-&gt;blob/shared F32VECTOR)
[procedure] (f64vector-&gt;blob/shared F64VECTOR)</pre><p>Each of these procedures return the contents of the given vector as a 'packed' blob. The byte order in that vector is platform-dependent (for example little-endian on an <strong>Intel</strong> processor). The <tt>/shared</tt> variants return a blob that shares memory with the contents of the vector.</p><a name="blob-u8vector"></a><h2>blob&rarr;u8vector</h2><a name="blob-s8vector"></a><h2>blob&rarr;s8vector</h2><a name="blob-u16vector"></a><h2>blob&rarr;u16vector</h2><a name="blob-s16vector"></a><h2>blob&rarr;s16vector</h2><a name="blob-u32vector"></a><h2>blob&rarr;u32vector</h2><a name="blob-s32vector"></a><h2>blob&rarr;s32vector</h2><a name="blob-f32vector"></a><h2>blob&rarr;f32vector</h2><a name="blob-f64vector"></a><h2>blob&rarr;f64vector</h2><a name="blob-u8vector-shared"></a><h2>blob&rarr;u8vector/shared</h2><a name="blob-s8vector-shared"></a><h2>blob&rarr;s8vector/shared</h2><a name="blob-u16vector-shared"></a><h2>blob&rarr;u16vector/shared</h2><a name="blob-s16vector-shared"></a><h2>blob&rarr;s16vector/shared</h2><a name="blob-u32vector-shared"></a><h2>blob&rarr;u32vector/shared</h2><a name="blob-s32vector-shared"></a><h2>blob&rarr;s32vector/shared</h2><a name="blob-f32vector-shared"></a><h2>blob&rarr;f32vector/shared</h2><a name="blob-f64vector-shared"></a><h2>blob&rarr;f64vector/shared</h2><pre>[procedure] (blob-&gt;u8vector BLOB)
[procedure] (blob-&gt;s8vector BLOB)
[procedure] (blob-&gt;u16vector BLOB)
[procedure] (blob-&gt;s16vector BLOB)
[procedure] (blob-&gt;u32vector BLOB)
[procedure] (blob-&gt;s32vector BLOB)
[procedure] (blob-&gt;f32vector BLOB)
[procedure] (blob-&gt;f64vector BLOB)
[procedure] (blob-&gt;u8vector/shared BLOB)
[procedure] (blob-&gt;s8vector/shared BLOB)
[procedure] (blob-&gt;u16vector/shared BLOB)
[procedure] (blob-&gt;s16vector/shared BLOB)
[procedure] (blob-&gt;u32vector/shared BLOB)
[procedure] (blob-&gt;s32vector/shared BLOB)
[procedure] (blob-&gt;f32vector/shared BLOB)
[procedure] (blob-&gt;f64vector/shared BLOB)</pre><p>Each of these procedures return a vector where the argument <tt>BLOB</tt> is taken as a 'packed' representation of the contents of the vector. The <tt>/shared</tt> variants return a vector that shares memory with the contents of the blob.</p><a name="subu8vector"></a><h2>subu8vector</h2><a name="subu16vector"></a><h2>subu16vector</h2><a name="subu32vector"></a><h2>subu32vector</h2><a name="subs8vector"></a><h2>subs8vector</h2><a name="subs16vector"></a><h2>subs16vector</h2><a name="subs32vector"></a><h2>subs32vector</h2><a name="subf32vector"></a><h2>subf32vector</h2><a name="subf64vector"></a><h2>subf64vector</h2><pre>[procedure] (subu8vector U8VECTOR FROM TO)
[procedure] (subu16vector U16VECTOR FROM TO)
[procedure] (subu32vector U32VECTOR FROM TO)
[procedure] (subs8vector S8VECTOR FROM TO)
[procedure] (subs16vector S16VECTOR FROM TO)
[procedure] (subs32vector S32VECTOR FROM TO)
[procedure] (subf32vector F32VECTOR FROM TO)
[procedure] (subf64vector F64VECTOR FROM TO)</pre><p>Creates a number vector of the same type as the argument vector with the elements at the positions <tt>FROM</tt> up to but not including <tt>TO</tt>.</p><p>SRFI-17 Setters for <tt>XXXvector-ref</tt> are defined.</p><a name="read-u8vector"></a><h2>read-u8vector</h2><pre>[procedure] (read-u8vector LENGTH [PORT])</pre><p>Reads <tt>LENGTH</tt> bytes from the <tt>PORT</tt> and returns a fresh <tt>u8vector</tt> or less if end-of-file is encountered. <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt>. If <tt>LENGTH</tt> is <tt>#f</tt>, the vector will be filled completely until end-of-file is reached.</p><a name="read-u8vector"></a><h2>read-u8vector!</h2><pre>[procedure] (read-u8vector! LENGTH U8VECTOR [PORT [START]])</pre><p>Reads <tt>LENGTH</tt> bytes from the <tt>PORT</tt> writing the read input into <tt>U8VECTOR</tt> beginning at <tt>START</tt> (or 0 if not given). <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt>. If <tt>LENGTH</tt> is <tt>#f</tt>, the vector will be filled completely until end-of-file is reached. This procedure returns the number of bytes read.</p><a name="write-u8vector"></a><h2>write-u8vector</h2><pre>[procedure] (write-u8vector U8VECTOR [PORT [START [END]]])</pre><p>Writes the bytes <tt>U8VECTOR</tt> between the indices <tt>START</tt> (inclusive) and <tt>END</tt> (exclusive) to <tt>PORT</tt>. <tt>PORT</tt> defaults to the value of <tt>(current-output-port)</tt>.</p><p>Previous: <a href="unit-srfi-1.html" class="internal">Unit srfi-1</a></p><p>Next: <a href="unit-srfi-13.html" class="internal">Unit srfi-13</a></p>
</body></html>