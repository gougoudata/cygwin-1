<html><head><title>CHICKEN User's Manual - Unit lolevel</title></head><body>
<p> </p><a name="unit-lolevel"></a><h1>Unit lolevel</h1><p>This unit provides a number of handy low-level operations. <strong>Use at your own risk.</strong></p><p>This unit uses the <tt>srfi-4</tt> and <tt>extras</tt> units.</p><a name="foreign-pointers"></a><h2>Foreign pointers</h2><a name="address-pointer"></a><h3>address&rarr;pointer</h3><pre>[procedure] (address-&gt;pointer ADDRESS)</pre><p>Creates a new foreign pointer object initialized to point to the address given in the integer <tt>ADDRESS</tt>.</p><a name="allocate"></a><h3>allocate</h3><pre>[procedure] (allocate BYTES)</pre><p>Returns a pointer to a freshly allocated region of static memory. This procedure could be defined as follows:</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">allocate</FONT></B> (foreign-lambda c-pointer <B><FONT COLOR="#BC8F8F">&quot;malloc&quot;</FONT></B> integer))
</PRE>
<a name="free"></a><h3>free</h3><pre>[procedure] (free POINTER)</pre><p>Frees the memory pointed to by <tt>POINTER</tt>.  This procedure could be defined as follows:</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">free</FONT></B> (foreign-lambda c-pointer <B><FONT COLOR="#BC8F8F">&quot;free&quot;</FONT></B> integer))
</PRE>
<a name="null-pointer"></a><h3>null-pointer</h3><pre>[procedure] (null-pointer)</pre><p>Another way to say <tt>(address-&gt;pointer 0)</tt>.</p><a name="null-pointer"></a><h3>null-pointer?</h3><pre>[procedure] (null-pointer? PTR)</pre><p>Returns <tt>#t</tt> if <tt>PTR</tt> contains a <tt>NULL</tt> pointer, or <tt>#f</tt> otherwise.</p><a name="object-pointer"></a><h3>object&rarr;pointer</h3><pre>[procedure] (object-&gt;pointer X)</pre><p>Returns a pointer pointing to the Scheme object X, which should be a non-immediate object.  Note that data in the garbage collected heap moves during garbage collection.</p><a name="pointer"></a><h3>pointer?</h3><pre>[procedure] (pointer? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a foreign pointer object, and <tt>#f</tt> otherwise.</p><a name="pointer"></a><h3>pointer=?</h3><pre>[procedure] (pointer=? PTR1 PTR2)</pre><p>Returns <tt>#t</tt> if the pointer-like objects <tt>PTR1</tt> and <tt>PTR2</tt> point to the same address.</p><a name="pointer-address"></a><h3>pointer&rarr;address</h3><pre>[procedure] (pointer-&gt;address PTR)</pre><p>Returns the address, to which the pointer <tt>PTR</tt> points.</p><a name="pointer-object"></a><h3>pointer&rarr;object</h3><pre>[procedure] (pointer-&gt;object PTR)</pre><p>Returns the Scheme object pointed to by the pointer <tt>PTR</tt>.</p><a name="pointer-offset"></a><h3>pointer-offset</h3><pre>[procedure] (pointer-offset PTR N)</pre><p>Returns a new pointer representing the pointer <tt>PTR</tt> increased by <tt>N</tt>.</p><a name="pointer-u8-ref"></a><h3>pointer-u8-ref</h3><pre>[procedure] (pointer-u8-ref PTR)</pre><p>Returns the unsigned byte at the address designated by <tt>PTR</tt>.</p><a name="pointer-s8-ref"></a><h3>pointer-s8-ref</h3><pre>[procedure] (pointer-s8-ref PTR)</pre><p>Returns the signed byte at the address designated by <tt>PTR</tt>.</p><a name="pointer-u16-ref"></a><h3>pointer-u16-ref</h3><pre>[procedure] (pointer-u16-ref PTR)</pre><p>Returns the unsigned 16-bit integer at the address designated by <tt>PTR</tt>.</p><a name="pointer-s16-ref"></a><h3>pointer-s16-ref</h3><pre>[procedure] (pointer-s16-ref PTR)</pre><p>Returns the signed 16-bit integer at the address designated by <tt>PTR</tt>.</p><a name="pointer-u32-ref"></a><h3>pointer-u32-ref</h3><pre>[procedure] (pointer-u32-ref PTR)</pre><p>Returns the unsigned 32-bit integer at the address designated by <tt>PTR</tt>.</p><a name="pointer-s32-ref"></a><h3>pointer-s32-ref</h3><pre>[procedure] (pointer-s32-ref PTR)</pre><p>Returns the signed 32-bit integer at the address designated by <tt>PTR</tt>.</p><a name="pointer-f32-ref"></a><h3>pointer-f32-ref</h3><pre>[procedure] (pointer-f32-ref PTR)</pre><p>Returns the 32-bit float at the address designated by <tt>PTR</tt>.</p><a name="pointer-f64-ref"></a><h3>pointer-f64-ref</h3><pre>[procedure] (pointer-f64-ref PTR)</pre><p>Returns the 64-bit double at the address designated by <tt>PTR</tt>.</p><a name="pointer-u8-set"></a><h3>pointer-u8-set!</h3><pre>[procedure] (pointer-u8-set! PTR N)
[procedure] (set! (pointer-u8-ref PTR) N)</pre><p>Stores the unsigned byte <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="pointer-s8-set"></a><h3>pointer-s8-set!</h3><pre>[procedure] (pointer-s8-set! PTR N)
[procedure] (set! (pointer-s8-ref PTR) N)</pre><p>Stores the signed byte <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="pointer-u16-set"></a><h3>pointer-u16-set!</h3><pre>[procedure] (pointer-u16-set! PTR N)
[procedure] (set! (pointer-u16-ref PTR) N)</pre><p>Stores the unsigned 16-bit integer <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="pointer-s16-set"></a><h3>pointer-s16-set!</h3><pre>[procedure] (pointer-s16-set! PTR N)
[procedure] (set! (pointer-s16-ref PTR) N)</pre><p>Stores the signed 16-bit integer <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="pointer-u32-set"></a><h3>pointer-u32-set!</h3><pre>[procedure] (pointer-u32-set! PTR N)
[procedure] (set! (pointer-u32-ref PTR) N)</pre><p>Stores the unsigned 32-bit integer <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="pointer-s32-set"></a><h3>pointer-s32-set!</h3><pre>[procedure] (pointer-s32-set! PTR N)
[procedure] (set! (pointer-s32-ref PTR) N)</pre><p>Stores the 32-bit integer <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="pointer-f32-set"></a><h3>pointer-f32-set!</h3><pre>[procedure] (pointer-f32-set! PTR N)
[procedure] (set! (pointer-f32-ref PTR) N)</pre><p>Stores the 32-bit floating-point number <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="pointer-f64-set"></a><h3>pointer-f64-set!</h3><pre>[procedure] (pointer-f64-set! PTR N)
[procedure] (set! (pointer-f64-ref PTR) N)</pre><p>Stores the 64-bit floating-point number <tt>N</tt> at the address designated by <tt>PTR</tt>.</p><a name="align-to-word"></a><h3>align-to-word</h3><pre>[procedure] (align-to-word PTR-OR-INT)</pre><p>Accepts either a machine pointer or an integer as argument and returns a new pointer or integer aligned to the native word size of the host platform.</p><a name="tagged-pointers"></a><h2>Tagged pointers</h2><p><em>Tagged</em> pointers are foreign pointer objects with an extra tag object.</p><a name="tag-pointer"></a><h3>tag-pointer</h3><pre>[procedure] (tag-pointer PTR TAG)</pre><p>Creates a new tagged pointer object from the foreign pointer <tt>PTR</tt> with the tag <tt>TAG</tt>, which may an arbitrary Scheme object.</p><a name="tagged-pointer"></a><h3>tagged-pointer?</h3><pre>[procedure] (tagged-pointer? X TAG)</pre><p>Returns <tt>#t</tt>, if <tt>X</tt> is a tagged pointer object with the tag <tt>TAG</tt> (using an <tt>eq?</tt> comparison), or <tt>#f</tt> otherwise.</p><a name="pointer-tag"></a><h3>pointer-tag</h3><pre>[procedure] (pointer-tag PTR)</pre><p>If <tt>PTR</tt> is a tagged pointer object, its tag is returned. If <tt>PTR</tt> is a normal, untagged foreign pointer object <tt>#f</tt> is returned. Otherwise an error is signalled.</p><a name="extending-procedures-with-data"></a><h2>Extending procedures with data</h2><a name="extend-procedure"></a><h3>extend-procedure</h3><pre>[procedure] (extend-procedure PROCEDURE X)</pre><p>Returns a copy of the procedure <tt>PROCEDURE</tt> which contains an additional data slot initialized to <tt>X</tt>. If <tt>PROCEDURE</tt> is already an extended procedure, then its data slot is changed to contain <tt>X</tt> and the same procedure is returned.</p><a name="extended-procedure"></a><h3>extended-procedure?</h3><pre>[procedure] (extended-procedure? PROCEDURE)</pre><p>Returns <tt>#t</tt> if <tt>PROCEDURE</tt> is an extended procedure, or <tt>#f</tt> otherwise.</p><a name="procedure-data"></a><h3>procedure-data</h3><pre>[procedure] (procedure-data PROCEDURE)</pre><p>Returns the data object contained in the extended procedure <tt>PROCEDURE</tt>, or <tt>#f</tt> if it is not an extended procedure.</p><a name="set-procedure-data"></a><h3>set-procedure-data!</h3><pre>[procedure] (set-procedure-data! PROCEDURE X)</pre><p>Changes the data object contained in the extended procedure <tt>PROCEDURE</tt> to <tt>X</tt>.</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">foo</FONT></B>
  (<B><FONT COLOR="#A020F0">letrec</FONT></B> ((f (<B><FONT COLOR="#A020F0">lambda</FONT></B> () (procedure-data x)))
           (x #f) )
    (<B><FONT COLOR="#A020F0">set!</FONT></B> x (extend-procedure f 123))
    x) )
(foo)                                         =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 123
(set-procedure-data! foo 'hello)
(foo)                                         =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> hello
</PRE>
<a name="data-in-unmanaged-memory"></a><h2>Data in unmanaged memory</h2><a name="object-evict"></a><h3>object-evict</h3><pre>[procedure] (object-evict X [ALLOCATOR])</pre><p>Copies the object <tt>X</tt> recursively into the memory pointed to by the foreign pointer object returned by <tt>ALLOCATOR</tt>, which should be a procedure of a single argument (the number of bytes to allocate). The freshly copied object is returned.  This facility allows moving arbitrary objects into static memory, but care should be taken when mutating evicted data: setting slots in evicted vector-like objects to non-evicted data is not allowed. It <strong>is</strong> possible to set characters/bytes in evicted strings or byte-vectors, though.  It is advisable <strong>not</strong> to evict ports, because they might be mutated by certain file-operations.  <tt>object-evict</tt> is able to handle circular and shared structures, but evicted symbols are no longer unique: a fresh copy of the symbol is created, so</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">x</FONT></B> 'foo)
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">y</FONT></B> (object-evict 'foo))
y                              =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> foo
(eq? x y)                      =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #f
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">z</FONT></B> (object-evict '(bar bar)))
(eq? (car z) (cadr z))         =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #t
</PRE>
<p>The <tt>ALLOCATOR</tt> defaults to <tt>allocate</tt>.</p><a name="object-evict-to-location"></a><h3>object-evict-to-location</h3><pre>[procedure] (object-evict-to-location X PTR [LIMIT])</pre><p>As <tt>object-evict</tt> but moves the object at the address pointed to by the machine pointer <tt>PTR</tt>. If the number of copied bytes exceeds the optional <tt>LIMIT</tt> then an error is signalled (specifically a composite condition of types <tt>exn</tt> and <tt>evict</tt>. The latter provides a <tt>limit</tt> property which holds the exceeded limit. Two values are returned: the evicted object and a new pointer pointing to the first free address after the evicted object.</p><a name="object-evicted"></a><h3>object-evicted?</h3><pre>[procedure] (object-evicted? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a non-immediate evicted data object, or <tt>#f</tt> otherwise.</p><a name="object-size"></a><h3>object-size</h3><pre>[procedure] (object-size X)</pre><p>Returns the number of bytes that would be needed to evict the data object <tt>X</tt>.</p><a name="object-release"></a><h3>object-release</h3><pre>[procedure] (object-release X [RELEASER])</pre><p>Frees memory occupied by the evicted object <tt>X</tt> recursively. <tt>RELEASER</tt> should be a procedure of a single argument (a foreign pointer object to the static memory to be freed) and defaults to <tt>free</tt>.</p><a name="object-unevict"></a><h3>object-unevict</h3><pre>[procedure] (object-unevict X [FULL])</pre><p>Copies the object <tt>X</tt> and nested objects back into the normal Scheme heap.  Symbols are re-interned into the symbol table. Strings and byte-vectors are <strong>not</strong> copied, unless <tt>FULL</tt> is given and not <tt>#f</tt>.</p><a name="locatives"></a><h2>Locatives</h2><p>A <em>locative</em> is an object that points to an element of a containing object, much like a <em>pointer</em> in low-level, imperative programming languages like <em>C</em>. The element can be accessed and changed indirectly, by performing access or change operations on the locative. The container object can be computed by calling the <tt>location-&gt;object</tt> procedure.</p><p>Locatives may be passed to foreign procedures that expect pointer arguments. The effect of creating locatives for evicted data (see <tt>object-evict</tt>) is undefined.</p><a name="make-locative"></a><h3>make-locative</h3><pre>[procedure] (make-locative EXP [INDEX])</pre><p>Creates a locative that refers to the element of the non-immediate object <tt>EXP</tt> at position <tt>INDEX</tt>. <tt>EXP</tt> may be a vector, pair, string, blob, SRFI-4 number-vector, or record. <tt>INDEX</tt> should be a fixnum. <tt>INDEX</tt> defaults to 0.</p><a name="make-weak-locative"></a><h3>make-weak-locative</h3><pre>[procedure] (make-weak-locative EXP [INDEX])</pre><p>Creates a <em>weak</em> locative. Even though the locative refers to an element of a container object, the container object will still be reclaimed by garbage collection if no other references to it exist.</p><a name="locative"></a><h3>locative?</h3><pre>[procedure] (locative? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a locative, or <tt>#f</tt> otherwise.</p><a name="locative-ref"></a><h3>locative-ref</h3><pre>[procedure] (locative-ref LOC)</pre><p>Returns the element to which the locative <tt>LOC</tt> refers. If the containing object has been reclaimed by garbage collection, an error is signalled.</p><a name="locative-set"></a><h3>locative-set!</h3><pre>[procedure] (locative-set! LOC X)
[procedure] (set! (locative-ref LOC) X)</pre><p>Changes the element to which the locative <tt>LOC</tt> refers to <tt>X</tt>. If the containing object has been reclaimed by garbage collection, an error is signalled.</p><a name="locative-object"></a><h3>locative&rarr;object</h3><pre>[procedure] (locative-&gt;object LOC)</pre><p>Returns the object that contains the element referred to by <tt>LOC</tt> or <tt>#f</tt> if the container has been reclaimed by garbage collection.</p><a name="accessing-toplevel-variables"></a><h2>Accessing toplevel variables</h2><a name="global-bound"></a><h3>global-bound?</h3><pre>[procedure] (global-bound? SYMBOL)</pre><p>Returns <tt>#t</tt>, if the global (<em>toplevel</em>) variable with the name <tt>SYMBOL</tt> is bound to a value, or <tt>#f</tt> otherwise.</p><a name="global-ref"></a><h3>global-ref</h3><pre>[procedure] (global-ref SYMBOL)</pre><p>Returns the value of the global variable <tt>SYMBOL</tt>. If no variable under that name is bound, an error is signalled.</p><p>Note that it is not possible to access a toplevel binding with <tt>global-ref</tt> or <tt>global-set!</tt> if it has been hidden in compiled code via <tt>(declare (hide ...))</tt>, or if the code has been compiled in <tt>block</tt> mode.</p><a name="global-set"></a><h3>global-set!</h3><pre>[procedure] (global-set! SYMBOL X)
[procedure] (set! (global-ref SYMBOL) X)</pre><p>Sets the global variable named <tt>SYMBOL</tt> to the value <tt>X</tt>.</p><a name="low-level-data-access"></a><h2>Low-level data access</h2><a name="block-ref"></a><h3>block-ref</h3><pre>[procedure] (block-ref BLOCK INDEX)</pre><p>Returns the contents of the <tt>INDEX</tt>th slot of the object <tt>BLOCK</tt>.  <tt>BLOCK</tt> may be a vector, record structure, pair or symbol.</p><a name="block-set"></a><h3>block-set!</h3><pre>[procedure] (block-set! BLOCK INDEX X)
[procedure] (set! (block-ref BLOCK INDEX) X)</pre><p>Sets the contents of the <tt>INDEX</tt>th slot of the object <tt>BLOCK</tt> to the value of <tt>X</tt>.  <tt>BLOCK</tt> may be a vector, record structure, pair or symbol.</p><a name="object-copy"></a><h3>object-copy</h3><pre>[procedure] (object-copy X)</pre><p>Copies <tt>X</tt> recursively and returns the fresh copy. Objects allocated in static memory are copied back into garbage collected storage.</p><a name="make-record-instance"></a><h3>make-record-instance</h3><pre>[procedure] (make-record-instance SYMBOL ARG1 ...)</pre><p>Returns a new instance of the record type <tt>SYMBOL</tt>, with its slots initialized to <tt>ARG1 ...</tt>.  To illustrate:</p><PRE>
(define-record point x y)
</PRE>
<p>expands into something quite similar to:</p><PRE>
(<B><FONT COLOR="#A020F0">begin</FONT></B>
  (<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">make-point</FONT></B> x y)
    (make-record-instance 'point x y) )
  (<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">point?</FONT></B> x)
    (<B><FONT COLOR="#A020F0">and</FONT></B> (record-instance? x)
         (eq? 'point (block-ref x 0)) ) )
  (<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">point-x</FONT></B> p) (block-ref p 1))
  (<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">point-x-set!</FONT></B> p x) (block-set! p 1 x))
  (<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">point-y</FONT></B> p) (block-ref p 2))
  (<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">point-y-set!</FONT></B> p y) (block-set! p 1 y)) )
</PRE>
<a name="move-memory"></a><h3>move-memory!</h3><pre>[procedure] (move-memory! FROM TO [BYTES [FROM-OFFSET [TO-OFFSET]])</pre><p>Copies <tt>BYTES</tt> bytes of memory from <tt>FROM</tt> to <tt>TO</tt>. <tt>FROM</tt> and <tt>TO</tt> may be strings, primitive byte-vectors, SRFI-4 byte-vectors (see: @ref{Unit srfi-4}), memory mapped files, foreign pointers (as obtained from a call to <tt>foreign-lambda</tt>, for example) or locatives. if <tt>BYTES</tt> is not given and the size of the source or destination operand is known then the maximal number of bytes will be copied. Moving memory to the storage returned by locatives will cause havoc,  if the locative refers to containers of non-immediate data, like vectors or pairs.</p><p>The additional fourth and fifth argument specify starting offsets  (in bytes) for the source and destination arguments.</p><a name="number-of-bytes"></a><h3>number-of-bytes</h3><pre>[procedure] (number-of-bytes BLOCK)</pre><p>Returns the number of bytes that the object <tt>BLOCK</tt> contains. <tt>BLOCK</tt> may be any non-immediate value.</p><a name="number-of-slots"></a><h3>number-of-slots</h3><pre>[procedure] (number-of-slots BLOCK)</pre><p>Returns the number of slots that the object <tt>BLOCK</tt> contains. <tt>BLOCK</tt> may be a vector, record structure, pair or symbol.</p><a name="record-instance"></a><h3>record-instance?</h3><pre>[procedure] (record-instance? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is an instance of a record type. See also: <tt>make-record-instance</tt>.</p><a name="record-vector"></a><h3>record&rarr;vector</h3><pre>[procedure] (record-&gt;vector BLOCK)</pre><p>Returns a new vector with the type and the elements of the record <tt>BLOCK</tt>.</p><a name="procedure-call-and-variable-reference-hooks"></a><h2>Procedure-call- and variable reference hooks</h2><a name="set-invalid-procedure-call-handler"></a><h3>set-invalid-procedure-call-handler!</h3><pre>[procedure] (set-invalid-procedure-call-handler! PROC)</pre><p>Sets an internal hook that is invoked when a call to an object other than a procedure is executed at runtime. The procedure <tt>PROC</tt> will in that case be called with two arguments: the object being called and a list of the passed arguments.</p><PRE>
<I><FONT COLOR="#B22222">;;; Access sequence-elements as in ARC:
</FONT></I>
(set-invalid-procedure-call-handler!
  (<B><FONT COLOR="#A020F0">lambda</FONT></B> (proc args)
    (<B><FONT COLOR="#A020F0">cond</FONT></B> [(string? proc) (apply string-ref proc args)]
          [(vector? proc) (apply vector-ref proc args)]
          [<B><FONT COLOR="#A020F0">else</FONT></B> (error <B><FONT COLOR="#BC8F8F">&quot;call of non-procedure&quot;</FONT></B> proc)] ) ) )

(<B><FONT COLOR="#BC8F8F">&quot;hello&quot;</FONT></B> 4)    =<B><FONT COLOR="#A020F0">=&gt;</FONT></B>  #\o
</PRE>
<p>This facility does not work in code compiled with the <em>unsafe</em> setting.</p><a name="unbound-variable-value"></a><h3>unbound-variable-value</h3><pre>[procedure] (unbound-variable-value [X])</pre><p>Defines the value that is returned for unbound variables. Normally an error is signalled, use this procedure to override the check and return <tt>X</tt> instead. To set the default behavior (of signalling an error), call <tt>unbound-variable-value</tt> with no arguments.</p><p>This facility does not work in code compiled with the <em>unsafe</em> setting.</p><a name="magic"></a><h2>Magic</h2><a name="object-become"></a><h3>object-become!</h3><pre>[procedure] (object-become! ALIST)</pre><p>Changes the identity of the value of the car of each pair in <tt>ALIST</tt> to the value of the cdr. Both values may not be immediate (i.e. exact integers, characters, booleans or the empty list).</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">x</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;i used to be a string&quot;</FONT></B>)
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">y</FONT></B> '#(<B><FONT COLOR="#A020F0">and</FONT></B> now i am a vector))
(object-become! (list (cons x y)))
x                                    =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #(<B><FONT COLOR="#A020F0">and</FONT></B> now i am a vector)
y                                    =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #(<B><FONT COLOR="#A020F0">and</FONT></B> now i am a vector)
(eq? x y)                            =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #t
</PRE>
<p>Note: this operation invokes a major garbage collection.</p><p>The effect of using <tt>object-become!</tt> on evicted data (see <tt>object-evict</tt>) is undefined.</p><a name="mutate-procedure"></a><h3>mutate-procedure</h3><pre>[procedure] (mutate-procedure OLD PROC)</pre><p>Replaces the procedure <tt>OLD</tt> with the result of calling the one-argument procedure <tt>PROC</tt>. <tt>PROC</tt> will receive a copy of <tt>OLD</tt> that will be identical in behaviour to the result of <tt>PROC</tt>:</p><PRE>
<I><FONT COLOR="#B22222">;;; Replace arbitrary procedure with tracing one:
</FONT></I>
(mutate-procedure my-proc 
  (<B><FONT COLOR="#A020F0">lambda</FONT></B> (new) 
    (<B><FONT COLOR="#A020F0">lambda</FONT></B> args
      (printf <B><FONT COLOR="#BC8F8F">&quot;~s called with arguments: ~s~%&quot;</FONT></B> new args)
      (apply new args) ) ) )
</PRE>
<p>Previous: <a href="unit-tcp.html" class="internal">Unit tcp</a></p><p>Next: <a href="interface-to-external-functions-and-variables.html" class="internal">Interface to external functions and variables</a></p>
</body></html>