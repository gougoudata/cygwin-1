<html><head><title>CHICKEN User's Manual - Using the compiler</title></head><body>
<p> </p><a name="using-the-compiler"></a><h1>Using the compiler</h1><p>The interface to <tt>chicken</tt> is intentionally simple.  System dependent makefiles, shell-scripts or batch-files should perform any necessary steps before and after invocation of <tt>chicken</tt>. A program named <tt>csc</tt> provides a much simpler interface to the Scheme- and C-compilers and linker. Enter</p><pre>csc -help</pre><p>on the command line for more information.</p><a name="compiler-command-line-format"></a><h2>Compiler command line format</h2><pre>chicken FILENAME {OPTION}</pre><p><tt>FILENAME</tt> is the complete pathname of the source file that is to be translated into C. A filename argument of <tt>-</tt> specifies that the source text should be read from standard input. Note that the filename has to be the first argument to <tt>chicken</tt>.</p><p>Possible options are:</p><dl><dt>-analyze-only</dt><dd>Stop compilation after first analysis pass.</dd><dt>-benchmark-mode</dt><dd>Equivalent to <tt>-no-trace -no-lambda-info -optimize-level 3</tt> <tt>-fixnum-arithmetic -disable-interrupts -block -lambda-lift</tt>.</dd><dt>-block</dt><dd>Enable block-compilation. When this option is specified, the compiler assumes that global variables are not modified outside this compilation-unit.  Specifically, toplevel bindings are not seen by <tt>eval</tt> and unused toplevel bindings are removed.</dd><dt>-case-insensitive</dt><dd>Enables the reader to read symbols case insensitive. The default is to read case sensitive (in violation of R5RS).  This option registers the <tt>case-insensitive</tt> feature identifier.</dd><dt>-check-imports</dt><dd>Search for references to undefined global variables. For each library unit accessed via <tt>(declare (uses ...))</tt>, the compiler will search a file named <tt>UNITNAME.exports</tt> in the current include path and load its contents into the <em>import-table</em> (if found). Also, export-information for extensions (accessed through <tt>(require-extension ...)</tt>) will be searched and stored in the import-table. If a required extension does not provide explicit export-information a <tt>.exports</tt> file is searched (as with used units). After the analysis phase of the compiler, referenced toplevel variables for which no assignment was found will generate a warning. Also, re-assignments of imported variables will trigger a warning.</dd><dt>-check-syntax</dt><dd>Aborts compilation process after macro-expansion and syntax checks.</dd><dt>-debug MODES</dt><dd>Enables one or more compiler debugging modes. <tt>MODES</tt> is a string of characters that select debugging information about the compiler that will be printed to standard output.</dd></dl><pre>    t          show time needed for compilation
    b          show breakdown of time needed for each compiler pass
    o          show performed optimizations
    r          show invocation parameters
    s          show program-size information and other statistics
    a          show node-matching during simplification
    p          show execution of compiler sub-passes
    l          show lambda-lifting information
    m          show GC statistics during compilation
    n          print the line-number database 
    c          print every expression before macro-expansion
    u          lists all unassigned global variable references
    x          display information about experimental features
    D          when printing nodes, use node-tree output
    N          show the real-name mapping table
    U          show expressions after the secondary user pass
    0          show database before lambda-lifting pass
    L          show expressions after lambda-lifting
    M          show unit-information and syntax-/runtime-requirements
    1          show source expressions
    2          show canonicalized expressions
    3          show expressions converted into CPS
    4          show database after each analysis pass
    5          show expressions after each optimization pass
    6          show expressions after each inlining pass
    7          show expressions after complete optimization
    8          show database after final analysis
    9          show expressions after closure conversion</pre><dl><dt>-debug-level LEVEL</dt><dd>Selects amount of debug-information. <tt>LEVEL</tt> should be an integer.</dd></dl><pre>    -debug-level 0             is equivalent to -no-trace -no-lambda-info
    -debug-level 1             is equivalent to -no-trace
    -debug-level 2             does nothing (the default)</pre><dl><dt>-disable-interrupts</dt><dd>Equivalent to the <tt>(disable-interrupts)</tt> declaration. No interrupt-checks are generated for compiled programs.</dd><dt>-disable-compiler-macros</dt><dd>disable expansion of compiler macros.</dd><dt>-disable-stack-overflow-checks</dt><dd>Disables detection of stack overflows. This is equivalent to running the compiled executable with the <tt>-:o</tt> runtime option.</dd><dt>-disable-warning CLASS : Disables specific class of warnings, may be given multiple times. The following classes are defined</dt></dl><pre>    usage              warnings related to command-line arguments
    type               warnings related to type-conversion
    ext                warnings related to extension libraries
    var                warnings related to variable- and syntax-definitions and use
    const              warnings related to constant-definitions
    syntax             syntax-related warnings
    redef              warnings about redefinitions of standard- or extended-bindings
    call               warnings related to known procedure calls
    ffi                warnings related to the foreign function interface</pre><dl><dt>-dynamic</dt><dd>This option should be used when compiling files intended to be loaded dynamically into a running Scheme program.</dd><dt>-epilogue FILENAME</dt><dd>Includes the file named <tt>FILENAME</tt> at the end of the compiled source file. The include-path is not searched. This option may be given multiple times.</dd><dt>-emit-exports FILENAME</dt><dd>Write exported toplevel variables to <tt>FILENAME</tt>.</dd><dt>-emit-external-prototypes-first</dt><dd>Emit prototypes for callbacks defined with <tt>define-external</tt> before any other foreign declarations. This is sometimes useful, when C/C++ code embedded into the a Scheme program has to access the callbacks. By default the prototypes are emitted after foreign declarations.</dd><dt>-explicit-use</dt><dd>Disables automatic use of the units <tt>library, eval</tt> and <tt>extras</tt>. Use this option if compiling a library unit instead of an application unit.</dd><dt>-extend FILENAME</dt><dd>Loads a Scheme source file or compiled Scheme program (on systems that support it) before compilation commences. This feature can be used to extend the compiler.  This option may be given multiple times. The file is also searched in the current include path and in the extension-repository.</dd><dt>-extension</dt><dd>Mostly equivalent to <tt>-prelude '(define-extension &lt;NAME&gt;)'</tt>, where <tt>&lt;NAME&gt;</tt> is the basename of the currently compiled file. Note that if you want to compile a file as a normal (dynamically loadable) extension library, you should also pass the <tt>-shared</tt> option.</dd><dt>-feature SYMBOL</dt><dd>Registers <tt>SYMBOL</tt> to be a valid feature identifier for <tt>cond-expand</tt>. Multiple symbols may be given, if comma-separated.</dd><dt>-fixnum-arithmetic</dt><dd>Equivalent to <tt>(fixnum-arithmetic)</tt> declaration. Assume all mathematical operations use small integer arguments.</dd><dt>-heap-size NUMBER</dt><dd>Sets a fixed heap size of the generated executable to <tt>NUMBER</tt> bytes. The parameter may be followed by a  <tt>M</tt> (<tt>m</tt>) or <tt>K</tt> (<tt>k</tt>) suffix which stand for mega- and kilobytes, respectively.  The default heap size is 5 kilobytes. Note that only half of it is in use at every given time.</dd><dt>-heap-initial-size NUMBER</dt><dd>Sets the size that the heap of the compiled application should have at startup time.</dd><dt>-heap-growth PERCENTAGE</dt><dd>Sets the heap-growth rate for the compiled program at compile time (see: <tt>-:hg</tt>).</dd><dt>-heap-shrinkage PERCENTAGE</dt><dd>Sets the heap-shrinkage rate for the compiled program at compile time (see: <tt>-:hs</tt>).</dd><dt>-help</dt><dd>Print a summary of available options and the format of the command line parameters and exit the compiler.</dd><dt>-import FILENAME</dt><dd>Read exports from linked or loaded libraries from given file. See also <tt>-check-imports</tt>. This is equivalent to declaring <tt>(declare (import FILENAME))</tt>. Implies <tt>-check-imports</tt>.</dd><dt>-include-path PATHNAME</dt><dd>Specifies an additional search path for files included via the <tt>include</tt> special form. This option may be given multiple times. If the environment variable <tt>CHICKEN_INCLUDE_PATH</tt> is set, it should contain a list of alternative include pathnames separated by <tt>;</tt>.</dd><dt>-inline</dt><dd>Enable procedure inlining for known procedures of a size below the threshold (which can be set through the <tt>-inline-limit</tt> option).</dd><dt>-inline-limit THRESHOLD</dt><dd>Sets the maximum size of a potentially inlinable procedure. The default threshold is <tt>10</tt>.</dd><dt>-keyword-style STYLE</dt><dd>Enables alternative keyword syntax, where <tt>STYLE</tt> may be either <tt>prefix</tt> (as in Common Lisp), <tt>suffix</tt> (as in DSSSL) or <tt>none</tt>. Any other value is ignored. The default is <tt>suffix</tt>.</dd><dt>-keep-shadowed-macros</dt><dd>Do not remove macro definitions with the same name as assigned toplevel variables (the default is to remove the macro definition).</dd><dt>-lambda-lift</dt><dd>Enable the optimization known as lambda-lifting.</dd><dt>-no-lambda-info</dt><dd>Don't emit additional information for each <tt>lambda</tt> expression (currently the argument-list, after alpha-conversion/renaming).</dd><dt>-no-trace</dt><dd>Disable generation of tracing information. If a compiled executable should halt due to a runtime error, then a list of the name and the line-number (if available) of the last procedure calls is printed, unless <tt>-no-trace</tt> is specified. With this option the generated code is slightly faster.</dd><dt>-no-warnings</dt><dd>Disable generation of compiler warnings.</dd><dt>-nursery NUMBER</dt><dt>-stack-size NUMBER</dt><dd>Sets the size of the first heap-generation of the generated executable to <tt>NUMBER</tt> bytes. The parameter may be followed by a <tt>M</tt> (<tt>m</tt>) or <tt>K</tt> (<tt>k</tt>) suffix.  The default stack-size depends on the target platform.</dd><dt>-optimize-leaf-routines</dt><dd>Enable leaf routine optimization.</dd><dt>-optimize-level LEVEL</dt><dd>Enables certain sets of optimization options. <tt>LEVEL</tt> should be an integer.</dd></dl><pre>    -optimize-level 0          does nothing.
    -optimize-level 1          is equivalent to -optimize-leaf-routines
    -optimize-level 2          is currently the same as -optimize-level 1
    -optimize-level 3          is equivalent to -optimize-leaf-routines -unsafe</pre><dl><dt>-output-file FILENAME</dt><dd>Specifies the pathname of the generated C file. Default is <tt>FILENAME.c</tt>.</dd><dt>-postlude EXPRESSIONS</dt><dd>Add <tt>EXPRESSIONS</tt> after all other toplevel expressions in the compiled file.  This option may be given multiple times. Processing of this option takes place after processing of <tt>-epilogue</tt>.</dd><dt>-prelude EXPRESSIONS</dt><dd>Add <tt>EXPRESSIONS</tt> before all other toplevel expressions in the compiled file.  This option may be given multiple times. Processing of this option takes place before processing of <tt>-prologue</tt>.</dd><dt>-profile</dt><dt>-accumulate-profile</dt><dd>Instruments the source code to count procedure calls and execution times. After the program terminates (either via an explicit <tt>exit</tt> or implicitly), profiling statistics are written to a file named <tt>PROFILE</tt>. Each line of the generated file contains a list with the procedure name, the number of calls and the time spent executing it. Use the <tt>chicken-profile</tt> program to display the profiling information in a more user-friendly form. Enter <tt>chicken-profile</tt> with no arguments at the command line to get a list of available options. The <tt>-accumulate-profile</tt> option is similar to <tt>-profile</tt>, but the resulting profile information will be appended to any existing <tt>PROFILE</tt> file. <tt>chicken-profile</tt> will merge and sum up the accumulated timing information, if several entries for the same procedure calls exist.</dd><dt>-profile-name FILENAME</dt><dd>Specifies name of the generated profile information (which defaults to <tt>PROFILE</tt>. Implies <tt>-profile</tt>.</dd><dt>-prologue FILENAME</dt><dd>Includes the file named <tt>FILENAME</tt> at the start of the compiled source file.  The include-path is not searched. This option may be given multiple times.</dd><dt>-quiet</dt><dd>Disables output of compile information.</dd><dt>-raw</dt><dd>Disables the generation of any implicit code that uses the Scheme libraries (that is all runtime system files besides <tt>runtime.c</tt> and <tt>chicken.h</tt>).</dd><dt>-require-extension NAME</dt><dd>Loads the extension <tt>NAME</tt> before the compilation process commences. This is identical to adding <tt>(require-extension NAME)</tt> at the start of the compiled program. If <tt>-uses NAME</tt> is also given on the command line, then any occurrences of <tt>-require-extension NAME</tt> are replaced with <tt>(declare (uses NAME))</tt>. Multiple names may be given and should be separated by <tt>,</tt>.</dd><dt>-run-time-macros</dt><dd>Makes macros also available at run-time. By default macros are not available at run-time.</dd><dt>-to-stdout</dt><dd>Write compiled code to standard output instead of creating a <tt>.c</tt> file.</dd><dt>-unit NAME</dt><dd>Compile this file as a library unit. Equivalent to <tt>-prelude "(declare (unit NAME))"</tt></dd><dt>-unsafe</dt><dd>Disable runtime safety checks.</dd><dt>-unsafe-libraries</dt><dd>Marks the generated file for being linked with the unsafe runtime system. This should be used when generating shared object files that are to be loaded dynamically. If the marker is present, any attempt to load code compiled with this option will signal an error.</dd><dt>-uses NAME</dt><dd>Use definitions from the library unit <tt>NAME</tt>. This is equivalent to <tt>-prelude "(declare (uses NAME))"</tt>. Multiple arguments may be given, separated by <tt>,</tt>.</dd><dt>-no-usual-integrations</dt><dd>Specifies that standard procedures and certain internal procedures may be redefined, and can not be inlined. This is equivalent to declaring <tt>(not usual-integrations)</tt>.</dd><dt>-version</dt><dd>Prints the version and some copyright information and exit the compiler.</dd><dt>-verbose</dt><dd>Prints progress information to standard output during compilation.</dd></dl><p>The environment variable <tt>CHICKEN_OPTIONS</tt> can be set to a string with default command-line options for the compiler.</p><a name="runtime-options"></a><h2>Runtime options</h2><p>After successful compilation a C source file is generated and can be compiled with a C compiler. Executables generated with CHICKEN (and the compiler itself) accept a small set of runtime options:</p><dl><dt><tt>-:?</tt></dt><dd>Shows a list of the available runtime options and exits the program.</dd><dt><tt>-:aNUMBER</tt></dt><dd>Specifies the length of the buffer for recording a trace of the last invoked procedures. Defaults to 16.</dd><dt><tt>-:b</tt></dt><dd>Enter a read-eval-print-loop when an error is encountered.</dd><dt><tt>-:B</tt></dt><dd>Sounds a bell (ASCII 7) on every major garbage collection.</dd><dt><tt>-:c</tt></dt><dd>Forces console mode. Currently this is only used in the interpreter (<tt>csi</tt>) to force output of the <tt>#;N&gt;</tt> prompt even if stdin is not a terminal (for example if running in an <tt>emacs</tt> buffer under Windows).</dd><dt><tt>-:d</tt></dt><dd>Prints some debug-information at runtime.</dd><dt><tt>-:D</tt></dt><dd>Prints some more debug-information at runtime.</dd><dt><tt>-:fNUMBER</tt></dt><dd>Specifies the maximal number of currently pending finalizers before finalization is forced.</dd><dt><tt>-:hNUMBER</tt></dt><dd>Specifies fixed heap size</dd><dt><tt>-:hgPERCENTAGE</tt></dt><dd>Sets the growth rate of the heap in percent. If the heap is exhausted, then it will grow by <tt>PERCENTAGE</tt>. The default is 200.</dd><dt><tt>-:hiNUMBER</tt></dt><dd>Specifies the initial heap size</dd><dt><tt>-:hmNUMBER</tt></dt><dd>Specifies a maximal heap size. The default is (2GB - 15).</dd><dt><tt>-:hsPERCENTAGE</tt></dt><dd>Sets the shrink rate of the heap in percent. If no more than a quarter of <tt>PERCENTAGE</tt> of the heap is used, then it will shrink to <tt>PERCENTAGE</tt>. The default is 50.  Note: If you want to make sure that the heap never shrinks, specify a value of <tt>0</tt>.  (this can be useful in situations where an optimal heap-size is known in advance).</dd><dt><tt>-:o</tt></dt><dd>Disables detection of stack overflows at run-time.</dd><dt><tt>-:r</tt></dt><dd>Writes trace output to stderr. This option has no effect with in files compiled with the <tt>-no-trace</tt> options.</dd><dt><tt>-:sNUMBER</tt></dt><dd>Specifies stack size.</dd><dt><tt>-:tNUMBER</tt></dt><dd>Specifies symbol table size.</dd><dt><tt>-:w</tt></dt><dd>Enables garbage collection of unused symbols. By default unused and unbound symbols are not garbage collected.</dd><dt><tt>-:x</tt></dt><dd>Raises uncaught exceptions of separately spawned threads in primordial thread. By default uncaught exceptions in separate threads are not handled, unless the primordial one explicitly joins them. When warnings are enabled (the default) and <tt>-:x</tt> is not given, a warning will be shown, though.</dd></dl><p>The argument values may be given in bytes, in kilobytes (suffixed with <tt>K</tt> or <tt>k</tt>), in megabytes (suffixed with <tt>M</tt> or <tt>m</tt>), or in gigabytes (suffixed with <tt>G</tt> or <tt>g</tt>). Runtime options may be combined, like <tt>-:dc</tt>, but everything following a <tt>NUMBER</tt> argument is ignored. So <tt>-:wh64m</tt> is OK, but <tt>-:h64mw</tt> will not enable GC of unused symbols.</p><a name="examples"></a><h2>Examples</h2><a name="a-simple-example-with-one-source-file"></a><h3>A simple example (with one source file)</h3><p>To compile a Scheme program (assuming a UNIX-like environment) consisting of a single source file, perform the following steps.</p><a name="writing-your-source-file"></a><h4>Writing your source file</h4><p>In this example we will assume your source file is called <tt>foo.scm</tt>:</p><PRE>
<I><FONT COLOR="#B22222">;;; foo.scm
</FONT></I>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">fac</FONT></B> n)
  (<B><FONT COLOR="#A020F0">if</FONT></B> (zero? n)
      1
      (* n (fac (- n 1))) ) )

(write (fac 10))
(newline)
</PRE>
<a name="compiling-your-program"></a><h4>Compiling your program</h4><p>Compile the file <tt>foo.scm</tt>:</p><pre>% csc foo.scm</pre><p>This will produce the <tt>foo</tt> executable:</p><pre>% ls
foo  foo.scm</pre><a name="running-your-program"></a><h4>Running your program</h4><p>To run your newly compiled executable use:</p><pre>% foo
3628800</pre><p>If you get a <tt>foo: command not found</tt> error, you might want to try with <tt>./foo</tt> instead (or, in Unix machines, modify your <tt>PATH</tt> environment variable to include your current directory).</p><a name="an-example-with-multiple-files"></a><h3>An example with multiple files</h3><p>If multiple bodies of Scheme code are to be combined into a single executable, then we have to compile each file and link the resulting object files together with the runtime system.</p><p>Let's consider an example where your program consists of multiple source files.</p><a name="writing-your-source-files"></a><h4>Writing your source files</h4><p>The declarations in these files specify which of the compiled files is the main module, and which is the library module. An executable can only have one main module, since a program has only a single entry-point. In this case <tt>foo.scm</tt> is the main module, because it doesn't have a <tt>unit</tt> declaration:</p><PRE>
<I><FONT COLOR="#B22222">;;; foo.scm
</FONT></I>
<I><FONT COLOR="#B22222">; The declaration marks this source file as dependant on the symbols provided
</FONT></I><I><FONT COLOR="#B22222">; by the bar unit:
</FONT></I>(declare (uses bar))

(write (fac 10)) (newline)
</PRE>
<p><tt>bar.scm</tt> will be our library:</p><PRE>
<I><FONT COLOR="#B22222">;;; bar.scm
</FONT></I>
<I><FONT COLOR="#B22222">; The declaration marks this source file as the bar unit.  The names of the
</FONT></I><I><FONT COLOR="#B22222">; units and your files don't need to match.
</FONT></I>(declare (unit bar))

(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">fac</FONT></B> n)
  (<B><FONT COLOR="#A020F0">if</FONT></B> (zero? n)
      1
      (* n (fac (- n 1))) ) )
</PRE>
<a name="compiling-and-running-your-program"></a><h4>Compiling and running your program</h4><p>You should compile your two files with the following commands:</p><pre>% csc -c bar.scm
% csc -c foo.scm</pre><p>That should produce two files, <tt>bar.o</tt> and <tt>foo.o</tt>. They contain the code from your source files in compiled form.</p><p>To link your compiled files use the following command:</p><pre>% csc foo.o bar.o -o foo</pre><p>This should produce the <tt>foo</tt> executable, which you can run just as in the previous example. At this point you can also erase the <tt>*.o</tt> files.</p><p>You could avoid one step and link the two files just as <tt>foo.scm</tt> is compiled:</p><pre>% csc -c bar.scm
% csc foo.scm bar.o -o foo</pre><p>Note that if you want to distribute your program, you might want it to follow the GNU Coding Standards.  One relatively easy way to achieve this is to use Autoconf and Automake, two tools made for this specific purpose. </p><a name="extending-the-compiler"></a><h2>Extending the compiler</h2><p>The compiler supplies a couple of hooks to add user-level passes to the compilation process. Before compilation commences any Scheme source files or compiled code specified using the <tt>-extend</tt> option are loaded and evaluated.  The parameters <tt>user-options-pass, user-read-pass, user-preprocessor-pass, user-pass, user-pass-2</tt> and <tt>user-post-analysis-pass</tt> can be set to procedures that are called to perform certain compilation passes instead of the usual processing (for more information about parameters see: <a href="supported-language.html" class="internal">Supported language</a>.</p><dl><dt>[parameter] user-options-pass</dt><dd>Holds a procedure that will be called with a list of command-line arguments and should return two values: the source filename and the actual list of options, where compiler switches have their leading <tt>-</tt> (hyphen) removed and are converted to symbols.  Note that this parameter is invoked <strong>before</strong> processing of the <tt>-extend</tt> option, and so can only be changed in compiled user passes.</dd><dt>[parameter] user-read-pass</dt><dd>Holds a procedure of three arguments. The first argument is a list of strings with the code passed to the compiler via <tt>-prelude</tt> options. The second argument is a list of source files including any files specified by <tt>-prologue</tt> and <tt>-epilogue</tt>. The third argument is a list of strings specified using <tt>-postlude</tt> options. The procedure should return a list of toplevel Scheme expressions.</dd><dt>[parameter] user-preprocessor-pass</dt><dd>Holds a procedure of one argument. This procedure is applied to each toplevel expression in the source file <strong>before</strong> macro-expansion. The result is macro-expanded and compiled in place of the original expression.</dd><dt>[parameter] user-pass</dt><dd>Holds a procedure of one argument. This procedure is applied to each toplevel expression <strong>after</strong> macro-expansion.  The result of the procedure is then compiled in place of the original expression.</dd><dt>[parameter] user-pass-2</dt><dd>Holds a procedure of three arguments, which is called with the canonicalized node-graph as its sole argument. The result is ignored, so this pass has to mutate the node-structure to cause any effect.</dd><dt>[parameter] user-post-analysis-pass</dt><dd>Holds a procedure that will be called after every performed program analysis pass. The procedure (when defined) will be called with seven arguments: a symbol indicating the analysis pass, the program database, the current node graph, a getter and a setter-procedure which can be used to access and manipulate the program database, which holds various information about the compiled program, a pass iteration count, and an analysis continuation flag. The getter procedure should be called with two arguments: a symbol representing the binding for which information should be retrieved, and a symbol that specifies the database-entry. The current value of the database entry will be returned or <tt>#f</tt>, if no such entry is available. The setter procedure is called with three arguments: the symbol and key and the new value. The pass iteration count currently is meaningful only for the 'opt pass. The analysis continuation flag will be <tt>#f</tt> for the last 'opt pass. For information about the contents of the program database contact the author.</dd></dl><p>Loaded code (via the <tt>-extend</tt> option) has access to the library units <tt>extras, srfi-1, srfi-4, utils, regex</tt> and the pattern matching macros.  Multithreading is not available.</p><p>Note that the macroexpansion/canonicalization phase of the compiler adds certain forms to the source program.  These extra expressions are not seen by <tt>user-preprocessor-pass</tt> but by <tt>user-pass</tt>.</p><a name="distributing-compiled-c-files"></a><h2>Distributing compiled C files</h2><p>It is relatively easy to create distributions of Scheme projects that have been compiled to C.  The runtime system of CHICKEN consists of only two handcoded C files (<tt>runtime.c</tt> and <tt>chicken.h</tt>), plus the file <tt>chicken-config.h</tt>, which is generated by the build process. All other modules of the runtime system and the extension libraries are just compiled Scheme code. The following example shows a minimal application, which should run without changes on the most frequent operating systems, like Windows, Linux or FreeBSD:</p><p>Let's take a simple example.</p><PRE>
<I><FONT COLOR="#B22222">; hello.scm
</FONT></I>
(print <B><FONT COLOR="#BC8F8F">&quot;Hello, world!&quot;</FONT></B>)
</PRE>
<pre> % chicken hello.scm -optimize-level 3 -output-file hello.c</pre><p>Compiled to C, we get <tt>hello.c</tt>. We need the files <tt>chicken.h</tt> and <tt>runtime.c</tt>, which contain the basic runtime system, plus the three basic library files <tt>library.c</tt>, <tt>eval.c</tt> and <tt>extras.c</tt> which contain the same functionality as the library linked into a plain CHICKEN-compiled application, or which is available by default in the interpreter, <tt>csi</tt>:</p><pre> % cd /tmp
 %echo '(print "Hello World.")' &gt; hello.scm
 % cp $CHICKEN_BUILD/runtime.c .
 % cp $CHICKEN_BUILD/library.c .
 % cp $CHICKEN_BUILD/eval.c    .
 % cp $CHICKEN_BUILD/extras.c  .
 % gcc -static -Os -fomit-frame-pointer runtime.c library.c eval.c \
   extras.c hello.c -o hello -lm</pre><p>Now we have all files together, and can create an tarball containing all the files:</p><pre>% tar cf hello.tar Makefile hello.c runtime.c library.c eval.c extras.c chicken.h
% gzip hello.tar</pre><p>This is naturally rather simplistic. Things like enabling dynamic loading, estimating the optimal stack-size and selecting supported features of the host system would need more configuration- and build-time support. All this can be addressed using more elaborate build-scripts, makefiles or by using autoconf/automake.</p><p>Note also that the size of the application can still be reduced by removing <tt>extras</tt> and <tt>eval</tt> and compiling <tt>hello.scm</tt> with the <tt>-explicit-use</tt> option.</p><p>For more information, study the CHICKEN source code and/or get in contact with the author.</p><p>Previous: <a href="index.html" class="internal">index.html</a></p><p>Next: <a href="using-the-interpreter.html" class="internal">Using the interpreter</a></p>
</body></html>