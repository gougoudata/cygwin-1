<html><head><title>CHICKEN User's Manual - Unit extras</title></head><body>
<p> </p><a name="unit-extras"></a><h1>Unit extras</h1><p>This unit contains a collection of useful utility definitions.  This unit is used by default, unless the program is compiled with the <tt>-explicit-use</tt> option.</p><a name="formatted-output"></a><h2>Formatted output</h2><a name="printf"></a><h3>printf</h3><a name="fprintf"></a><h3>fprintf</h3><a name="sprintf"></a><h3>sprintf</h3><pre>[procedure] (fprintf PORT FORMATSTRING ARG ...)
[procedure] (printf FORMATSTRING ARG ...)
[procedure] (sprintf FORMATSTRING ARG ...)</pre><p>Simple formatted output to a given port (<tt>fprintf</tt>), the value of <tt>(current-output-port)</tt> (<tt>printf</tt>), or a string (<tt>sprintf</tt>).  The <tt>FORMATSTRING</tt> can contain any sequence of characters.  There must be at least as many <tt>ARG</tt> arguments given as there are format directives that require an argument in <tt>FORMATSTRING</tt>.  Extra <tt>ARG</tt> arguments are ignored.  The character `~' prefixes special formatting directives:</p><table><tr><td><pre>~%</pre><p>write newline character</p></td></tr><tr><td><pre>~N</pre><p>the same as <tt>~%</tt></p></td></tr><tr><td><pre>~S</pre><p>write the next argument</p></td></tr><tr><td><pre>~A</pre><p>display the next argument</p></td></tr><tr><td><pre>~\n</pre><p>skip all whitespace in the format-string until the next non-whitespace character</p></td></tr><tr><td><pre>~B</pre><p>write the next argument as a binary number</p></td></tr><tr><td><pre>~O</pre><p>write the next argument as an octal number</p></td></tr><tr><td><pre>~X</pre><p>write the next argument as a hexadecimal number</p></td></tr><tr><td><pre>~C</pre><p>write the next argument as a character</p></td></tr><tr><td><pre>~~</pre><p>display `~'</p></td></tr><tr><td><pre>~!</pre><p>flush all pending output</p></td></tr><tr><td><pre>~?</pre><p>invoke formatted output routine recursively with the next two arguments as format-string and list of parameters</p></td></tr></table><a name="format"></a><h3>format</h3><pre>[procedure] (format [DESTINATION] FORMATSTRING ARG ...)</pre><p>The parameters  <tt>FORMATSTRING</tt> and <tt>ARG ...</tt> are as for (<tt>printf</tt>/<tt>sprintf</tt>/<tt>fprintf</tt>).</p><p>The optional <tt>DESTINATION</tt>, when supplied, performs a (<tt>sprintf</tt>) for a  <tt>#f</tt>, a (<tt>printf</tt>) for a <tt>#t</tt>, and a (<tt>fprintf</tt>) for an output-port. When missing a (<tt>sprintf</tt>) is performed.</p><a name="random-numbers"></a><h2>Random numbers</h2><a name="random-seed"></a><h3>random-seed</h3><pre>[procedure] (random-seed [SEED])</pre><p>Seeds the random number generator with <tt>SEED</tt> (an exact integer) or  <tt>(current-seconds)</tt> if <tt>SEED</tt> is not given.</p><a name="random"></a><h3>random</h3><pre>[procedure] (random N)</pre><p>Returns an exact random integer from 0 to <tt>N</tt>-1.</p><a name="randomize"></a><h3>randomize</h3><pre>[procedure] (randomize [X])</pre><p>Set random-number seed. If <tt>X</tt> is not supplied, the current time is used. On startup (when the <tt>extras</tt> unit is initialized), the random number generator is initialized with the current time.</p><a name="input-output-extensions"></a><h2>Input/Output extensions</h2><a name="pretty-print"></a><h3>pretty-print</h3><pre>[procedure] (pretty-print EXP [PORT])
[procedure] (pp EXP [PORT])</pre><p>Print expression nicely formatted. <tt>PORT</tt> defaults to the value of <tt>(current-output-port)</tt>.</p><a name="pretty-print-width"></a><h3>pretty-print-width</h3><p>(Parameter) Specifies the maximal line-width for pretty printing, after which line wrap will occur.</p><a name="read-byte"></a><h3>read-byte</h3><a name="write-byte"></a><h3>write-byte</h3><pre>[procedure] (read-byte [PORT])
[procedure] (write-byte BYTE [PORT])</pre><p>Read/write a byte to the port given in <tt>PORT</tt>, which default to the values of <tt>(current-input-port)</tt> and <tt>(current-output-port)</tt>, respectively.</p><a name="read-file"></a><h3>read-file</h3><pre>[procedure] (read-file [FILE-OR-PORT [READER [MAXCOUNT]]])</pre><p>Returns a list containing all toplevel expressions read from the file or port <tt>FILE-OR-PORT</tt>. If no argument is given, input is read from the port that is the current value of <tt>(current-input-port)</tt>. After all expressions are read, and if the argument is a port, then the port will not be closed. The <tt>READER</tt> argument specifies the procedure used to read  expressions from the given file or port and defaults to <tt>read</tt>. The reader procedure will be called with a single argument (an input port). If <tt>MAXCOUNT</tt> is given then only up to <tt>MAXCOUNT</tt> expressions will be read in.</p><a name="read-line"></a><h3>read-line</h3><a name="write-line"></a><h3>write-line</h3><pre>[procedure] (read-line [PORT [LIMIT]])
[procedure] (write-line STRING [PORT])</pre><p>Line-input and -output. <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt> and <tt>(current-output-port)</tt>, respectively. If the optional argument <tt>LIMIT</tt> is given and not <tt>#f</tt>, then <tt>read-line</tt> reads at most <tt>LIMIT</tt> characters per line. <tt>read-line</tt> returns a string without the terminating newline and <tt>write-line</tt> adds a terminating newline  before outputting.</p><a name="read-lines"></a><h3>read-lines</h3><pre>[procedure] (read-lines [PORT [MAX]])</pre><p>Read <tt>MAX</tt> or fewer lines from <tt>PORT</tt>. <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt>. <tt>PORT</tt> may optionally be a string naming a file. Returns a list of strings, each string representing a line read, not including any line separation character(s).</p><a name="read-string"></a><h3>read-string</h3><a name="read-string"></a><h3>read-string!</h3><a name="write-string"></a><h3>write-string</h3><pre>[procedure] (read-string [NUM [PORT]])
[procedure] (read-string! NUM STRING [PORT [START]])
[procedure] (write-string STRING [NUM [PORT]]</pre><p>Read or write <tt>NUM</tt> characters from/to <tt>PORT</tt>, which defaults to the value of <tt>(current-input-port)</tt> or <tt>(current-output-port)</tt>, respectively.  If <tt>NUM</tt> is <tt>#f</tt> or not given, then all data up to the end-of-file is read, or, in the case of <tt>write-string</tt> the whole string is written. If no more input is available, <tt>read-string</tt> returns the empty string. <tt>read-string!</tt> reads destructively into the given <tt>STRING</tt> argument, but never more characters that would fit into <tt>STRING</tt>. If <tt>START</tt> is given, then the read characters are stored starting at that position. <tt>read-string!</tt> returns the actual number of characters read.</p><a name="read-token"></a><h3>read-token</h3><pre>[procedure] (read-token PREDICATE [PORT])</pre><p>Reads characters from <tt>PORT</tt> (which defaults to the value of <tt>(current-input-port)</tt>) and calls the procedure <tt>PREDICATE</tt> with each character until <tt>PREDICATE</tt> returns false. Returns a string with the accumulated characters.</p><p>Previous: <a href="unit-files.html" class="internal">Unit files</a></p><p>Next: <a href="unit-srfi-1.html" class="internal">Unit srfi-1</a></p>
</body></html>