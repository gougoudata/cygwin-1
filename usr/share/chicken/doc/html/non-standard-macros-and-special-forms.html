<html><head><title>CHICKEN User's Manual - Non-standard macros and special forms</title></head><body>
<a name="non-standard-macros-and-special-forms"></a><h1>Non-standard macros and special forms</h1><a name="making-extra-libraries-and-extensions-available"></a><h2>Making extra libraries and extensions available</h2><a name="require-extension"></a><h3>require-extension</h3><pre>[syntax] (require-extension ID ...)
[syntax] (use ID ...)</pre><p>This form does all the necessary steps to make the libraries or extensions given in <tt>ID ...</tt> available. It loads syntactic extensions, if needed and generates code for loading/linking with core library modules or separately installed extensions. <tt>use</tt> is just a shorter alias for <tt>require-extension</tt>. This implementation of <tt>require-extension</tt> is compliant with <a href="http://srfi.schemers.org/srfi-55/srfi-55.html" class="external">SRFI-55</a> (see the <a href="http://srfi.schemers.org/srfi-55/srfi-55.html" class="external">SRFI-55</a> document for more information).</p><p>During interpretation/evaluation <tt>require-extension</tt> performs one of the following:</p><ul><li>If <tt>ID</tt> names a built-in feature <tt>chicken srfi-0 srfi-2 srfi-6 srfi-8 srfi-9 srfi-10 srfi-17 srfi-23 srfi-30 srfi-39 srfi-55</tt>, then nothing is done.</li><li>If <tt>ID</tt> names one of the syntactic extensions <tt>chicken-more-macros chicken-ffi-macros</tt>, then this extension will be loaded.</li><li>If <tt>ID</tt> names one of the core library units shipped with CHICKEN, then a <tt>(load-library 'ID)</tt> will be performed.</li><li>If <tt>ID</tt> names an installed extension with the <tt>syntax</tt> or <tt>require-at-runtime</tt> attribute, then the equivalent of <tt>(require-for-syntax 'ID)</tt> is performed, probably followed by <tt>(require ...)</tt> for any run-time requirements.</li><li>Otherwise, <tt>(require-extension ID)</tt> is equivalent to <tt>(require 'ID)</tt>.</li></ul><p>During compilation, one of the following happens instead:</p><ul><li>If <tt>ID</tt> names a built-in feature <tt>chicken srfi-0 srfi-2 srfi-6 srfi-8 srfi-9 srfi-10 srfi-17 srfi-23 srfi-30 srfi-39 srfi-55</tt>, then nothing is done.</li><li>If <tt>ID</tt> names one of the syntactic extensions <tt>chicken-more-macros chicken-ffi-macros</tt>, then this extension will be loaded at compile-time, making the syntactic extensions available in compiled code.</li><li>If <tt>ID</tt> names one of the core library units shipped with CHICKEN, or if the option <tt>-uses ID</tt> has been passed to the compiler, then a <tt>(declare (uses ID))</tt> is generated.</li><li>If <tt>ID</tt> names an installed extension with the <tt>syntax</tt> or <tt>require-at-runtime</tt> attribute, then the equivalent of <tt>(require-for-syntax 'ID)</tt> is performed, and code is emitted to <tt>(require ...)</tt> any needed run-time requirements.</li><li>Otherwise <tt>(require-extension ID)</tt> is equivalent to <tt>(require 'ID)</tt>.</li></ul><p>To make long matters short - just use <tt>require-extension</tt> and it will normally figure everything out for dynamically loadable extensions and core library units.</p><p><tt>ID</tt> should be a pure extension name and should not contain any path prefixes (for example <tt>dir/lib...</tt>) is illegal).</p><p><tt>ID</tt> may also be a list that designates an extension-specifier. Currently the following extension specifiers are defined:</p><ul><li><tt>(srfi NUMBER ...)</tt> is required for SRFI-55 compatibility and is fully implemented</li><li><tt>(version ID NUMBER)</tt> is equivalent to <tt>ID</tt>, but checks at compile-time whether the extension named <tt>ID</tt> is installed and whether its version is equal or higher than <tt>NUMBER</tt>. <tt>NUMBER</tt> may be a string or a number, the comparison is done lexicographically (using <tt>string&gt;=?</tt>).</li></ul><p>See also: <tt>set-extension-specifier!</tt></p><p>When syntax extensions are loaded that redefine the global toplevel macro-expander (for example the <a href="http://www.call-with-current-continuation.org/eggs/syntax-case.html" class="external">syntax-case</a> extension), then all remaining expression <em>in the same toplevel form</em> are still expanded with the old toplevel macro-expander.</p><a name="define-extension"></a><h3>define-extension</h3><pre>[syntax] (define-extension NAME CLAUSE ...)</pre><p>This macro simplifies the task of writing extensions that can be linked both statically and dynamically. If encountered in interpreted code or code that is compiled into a shared object (specifically if compiled with the feature <tt>chicken-compile-shared</tt>, done automatically by <tt>csc</tt> when compiling with the <tt>-shared</tt> or <tt>-dynamic</tt> option) then the code given by clauses of the form</p><PRE>
(dynamic EXPRESSION ...)
</PRE>
<p>are inserted into the output as a <tt>begin</tt> form.</p><p>If compiled statically (specifically if the feature <tt>chicken-compile-shared</tt> has not been given), then this form expands into the following:</p><PRE>
(declare (unit NAME))
(provide 'NAME)
</PRE>
<p>and all clauses of the form</p><PRE>
(static EXPRESSION ...)
</PRE>
<p>all additionally inserted into the expansion.</p><p>As a convenience, the clause</p><PRE>
(export IDENTIFIER ...)
</PRE>
<p>is also allowed and is identical to <tt>(declare (export IDENTIFIER ...))</tt> (unless the <tt>define-extension</tt> form occurs in interpreted code, in with it is simply ignored).</p><p>Note that the compiler option <tt>-extension NAME</tt> is equivalent to prefixing the compiled file with </p><PRE>
(define-extension NAME)
</PRE>
<a name="binding-forms-for-optional-arguments"></a><h2>Binding forms for optional arguments</h2><a name="optional"></a><h3>optional</h3><pre>[syntax] (optional ARGS DEFAULT)</pre><p>Use this form for procedures that take a single optional argument. If <tt>ARGS</tt> is the empty list <tt>DEFAULT</tt> is evaluated and returned, otherwise the first element of the list <tt>ARGS</tt>. It is an error if <tt>ARGS</tt> contains more than one value.</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">incr</FONT></B> x . i) (+ x (optional i 1)))
(incr 10)                                   =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 11
(incr 12 5)                                 =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 17
</PRE>
<a name="case-lambda"></a><h3>case-lambda</h3><pre>[syntax] (case-lambda (LAMBDA-LIST1 EXP1 ...) ...)</pre><p>Expands into a lambda that invokes the body following the first matching lambda-list.</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">plus</FONT></B>
  (case-lambda 
    (() 0)
    ((x) x)
    ((x y) (+ x y))
    ((x y z) (+ (+ x y) z))
    (args (apply + args))))

(plus)                      =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 0
(plus 1)                    =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 1
(plus 1 2 3)                =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 6
</PRE>
<p>For more information see the documentation for <a href="http://srfi.schemers.org/srfi-16/srfi-16.html" class="external">SRFI-16</a></p><a name="let-optionals"></a><h3>let-optionals</h3><pre>[syntax]  (let-optionals ARGS ((VAR1 DEFAULT1) ...) BODY ...)</pre><p>Binding constructs for optional procedure arguments. <tt>ARGS</tt> should be a rest-parameter taken from a lambda-list. <tt>let-optionals</tt> binds <tt>VAR1 ...</tt> to available arguments in parallel, or to <tt>DEFAULT1 ...</tt> if not enough arguments were provided. <tt>let-optionals*</tt> binds <tt>VAR1 ...</tt> sequentially, so every variable sees the previous ones. it is an error if any excess arguments are provided.</p><PRE>
(let-optionals '(one two) ((a 1) (b 2) (c 3))
  (list a b c) )                               =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (one two 3)
</PRE>
<a name="let-optionals"></a><h3>let-optionals*</h3><pre>[syntax]  (let-optionals* ARGS ((VAR1 DEFAULT1) ... [RESTVAR]) BODY ...)</pre><p>Binding constructs for optional procedure arguments. <tt>ARGS</tt> should be a rest-parameter taken from a lambda-list. <tt>let-optionals</tt> binds <tt>VAR1 ...</tt> to available arguments in parallel, or to <tt>DEFAULT1 ...</tt> if not enough arguments were provided. <tt>let-optionals*</tt> binds <tt>VAR1 ...</tt> sequentially, so every variable sees the previous ones. If a single variable <tt>RESTVAR</tt> is given, then it is bound to any remaining arguments, otherwise it is an error if any excess arguments are provided.</p><PRE>
(let-optionals* '(one two) ((a 1) (b 2) (c a))
  (list a b c) )                               =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (one two one)
</PRE>
<a name="other-binding-forms"></a><h2>Other binding forms</h2><a name="and-let"></a><h3>and-let*</h3><pre>[syntax] (and-let* (BINDING ...) EXP1 EXP2 ...)</pre><p>SRFI-2. Bind sequentially and execute body. <tt>BINDING</tt> can be a list of a variable and an expression, a list with a single expression, or a single variable. If the value of an expression bound to a variable is <tt>#f</tt>, the <tt>and-let*</tt> form evaluates to <tt>#f</tt> (and the subsequent bindings and the body are not executed).  Otherwise the next binding is performed. If all bindings/expressions evaluate to a true result, the body is executed normally and the result of the last expression is the result of the <tt>and-let*</tt> form. See also the documentation for <a href="http://srfi.schemers.org/srfi-2/srfi-2.html" class="external">SRFI-2</a>.</p><a name="rec"></a><h3>rec</h3><pre>[syntax] (rec NAME EXPRESSION)
[syntax] (rec (NAME VARIABLE ...) BODY ...)</pre><p>Allows simple definition of recursive definitions. <tt>(rec NAME EXPRESSION)</tt> is equivalent to <tt>(letrec ((NAME EXPRESSION)) NAME)</tt> and <tt>(rec (NAME VARIABLE ...) BODY ...)</tt> is the same as <tt>(letrec ((NAME (lambda (VARIABLE ...) BODY ...))) NAME)</tt>.</p><a name="cut"></a><h3>cut</h3><pre>[syntax] (cut SLOT ...)
[syntax] (cute SLOT ...)</pre><p><a href="http://srfi.schemers.org/srfi-26/srfi-26.html" class="external">Syntactic sugar for specializing parameters</a>.</p><a name="define-values"></a><h3>define-values</h3><pre>[syntax] (define-values (NAME ...) EXP)</pre><p>Defines several variables at once, with the result values of expression <tt>EXP</tt>.</p><a name="fluid-let"></a><h3>fluid-let</h3><pre>[syntax] (fluid-let ((VAR1 X1) ...) BODY ...)</pre><p>Binds the variables <tt>VAR1 ...</tt> dynamically to the values <tt>X1 ...</tt>  during execution of <tt>BODY ...</tt>.</p><a name="let-values"></a><h3>let-values</h3><pre>[syntax] (let-values (((NAME ...) EXP) ...) BODY ...)</pre><p>Binds multiple variables to the result values of <tt>EXP ...</tt>. All variables are bound simultaneously.</p><a name="let-values"></a><h3>let*-values</h3><pre>[syntax] (let*-values (((NAME ...) EXP) ...) BODY ...)</pre><p>Binds multiple variables to the result values of <tt>EXP ...</tt>. The variables are bound sequentially.</p><PRE>
(let*-values (((a b) (values 2 3))
              ((p) (+ a b)) )
  p)                               =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 5
</PRE>
<a name="letrec-values"></a><h3>letrec-values</h3><pre>[syntax] (letrec-values (((NAME ...) EXP) ...) BODY ...)</pre><p>Binds the result values of <tt>EXP ...</tt> to multiple variables at once. All variables are mutually recursive.</p><PRE>
(letrec-values (((odd even)
                   (values 
                     (<B><FONT COLOR="#A020F0">lambda</FONT></B> (n) (<B><FONT COLOR="#A020F0">if</FONT></B> (zero? n) #f (even (sub1 n))))
                     (<B><FONT COLOR="#A020F0">lambda</FONT></B> (n) (<B><FONT COLOR="#A020F0">if</FONT></B> (zero? n) #t (odd (sub1 n)))) ) ) )
  (odd 17) )                           =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #t
</PRE>
<a name="parameterize"></a><h3>parameterize</h3><pre>[syntax] (parameterize ((PARAMETER1 X1) ...) BODY ...)</pre><p>Binds the parameters <tt>PARAMETER1 ...</tt> dynamically to the values <tt>X1 ...</tt> during execution of <tt>BODY ...</tt>.  (see also: <tt>make-parameter</tt> in <a href="parameters.html" class="internal">Parameters</a>). Note that <tt>PARAMETER</tt> may be any expression that evaluates to a parameter procedure.</p><a name="receive"></a><h3>receive</h3><pre>[syntax] (receive (NAME1 ... [. NAMEn]) VALUEEXP BODY ...)
[syntax] (receive VALUEEXP)</pre><p>SRFI-8. Syntactic sugar for <tt>call-with-values</tt>. Binds variables to the result values of <tt>VALUEEXP</tt> and evaluates <tt>BODY ...</tt>.</p><p>The syntax </p><PRE>
(receive VALUEEXP)
</PRE>
<p>is equivalent to</p><PRE>
(receive _ VALUEEXP _)
</PRE>
<a name="set-values"></a><h3>set!-values</h3><pre>[syntax] (set!-values (NAME ...) EXP)</pre><p>Assigns the result values of expression <tt>EXP</tt> to multiple variables.</p><a name="substitution-forms-and-macros"></a><h2>Substitution forms and macros</h2><a name="define-constant"></a><h3>define-constant</h3><pre>[syntax] (define-constant NAME CONST)</pre><p>Define a variable with a constant value, evaluated at compile-time.  Any reference to such a constant should appear textually <strong>after</strong> its definition. This construct is equivalent to <tt>define</tt> when evaluated or interpreted. Constant definitions should only appear at toplevel. Note that constants are local to the current compilation unit and are not available outside of the source file in which they are defined. Names of constants still exist in the Scheme namespace and can be lexically shadowed.  If the value is mutable, then the compiler is careful to preserve its identity. <tt>CONST</tt> may be any constant expression, and may also refer to constants defined via <tt>define-constant</tt> previously. This for should only be used at top-level.</p><a name="define-inline"></a><h3>define-inline</h3><pre>[syntax] (define-inline (NAME VAR ... [. VAR]) BODY ...)
[syntax] (define-inline NAME EXP)</pre><p>Defines an inline procedure. Any occurrence of <tt>NAME</tt> will be replaced by <tt>EXP</tt> or <tt>(lambda (VAR ... [. VAR]) BODY ...)</tt>.  This is similar to a macro, but variable-names and -scope will be correctly handled.  Inline substitutions take place <strong>after</strong> macro-expansion.  <tt>EXP</tt> should be a lambda-expression. Any reference to <tt>NAME</tt> should appear textually <strong>after</strong> its definition. Note that inline procedures are local to the current compilation unit and are not available outside of the source file in which they are defined. Names of inline procedures still exist in the Scheme namespace and can be lexically shadowed.  This construct is equivalent to <tt>define</tt> when evaluated or interpreted. Inline definitions should only appear at toplevel.</p><a name="define-macro"></a><h3>define-macro</h3><pre>[syntax] (define-macro (NAME VAR ... [. VAR]) EXP1 ...)
[syntax] (define-macro NAME (lambda (VAR ... [. VAR]) EXP1 ...))
[syntax] (define-macro NAME1 NAME2)</pre><p>Define a globally visible macro special form. The macro is available as soon as it is defined, i.e. it is registered at compile-time. If the file containing this definition invokes <tt>eval</tt> and the declaration <tt>run-time-macros</tt> (or the command line option <tt>-run-time-macros</tt>) has been used, then the macro is visible in evaluated expressions during runtime. The second possible syntax for <tt>define-macro</tt> is allowed for portability purposes only. In this case the second argument <strong>must</strong> be a lambda-expression or a macro name.  Only global macros can be defined using this form. <tt>(define-macro NAME1 NAME2)</tt> simply copies the macro definition from <tt>NAME2</tt> to <tt>NAME1</tt>, creating an alias.</p><p>Extended lambda list syntax (<tt>#!optional</tt>, etc.) can be used but note that arguments are source expressions and thus default values for optional or keyword arguments should take this into consideration.</p><a name="define-for-syntax"></a><h3>define-for-syntax</h3><pre>[syntax] (define-for-syntax (NAME VAR ... [. VAR]) EXP1 ...)
[syntax] (define-for-syntax NAME [VALUE])</pre><p>Defines the toplevel variable <tt>NAME</tt> at macro-expansion time. This can be helpful when you want to define support procedures for use in macro-transformers, for example.</p><a name="conditional-forms"></a><h2>Conditional forms</h2><a name="select"></a><h3>select</h3><pre>[syntax] (select EXP ((KEY ...) EXP1 ...) ... [(else EXPn ...)])</pre><p>This is similar to <tt>case</tt>, but the keys are evaluated.</p><a name="unless"></a><h3>unless</h3><pre>[syntax] (unless TEST EXP1 EXP2 ...)</pre><p>Equivalent to:</p><PRE>
(<B><FONT COLOR="#A020F0">if</FONT></B> (not TEST) (<B><FONT COLOR="#A020F0">begin</FONT></B> EXP1 EXP2 ...))
</PRE>
<a name="when"></a><h3>when</h3><pre>[syntax] (when TEST EXP1 EXP2 ...)</pre><p>Equivalent to:</p><PRE>
(<B><FONT COLOR="#A020F0">if</FONT></B> TEST (<B><FONT COLOR="#A020F0">begin</FONT></B> EXP1 EXP2 ...))
</PRE>
<a name="record-structures"></a><h2>Record structures</h2><a name="define-record"></a><h3>define-record</h3><pre>[syntax] (define-record NAME SLOTNAME ...)</pre><p>Defines a record type. Call <tt>make-NAME</tt> to create an instance of the structure (with one initialization-argument for each slot). <tt>(NAME? STRUCT)</tt> tests any object for being an instance of this structure.  Slots are accessed via <tt>(NAME-SLOTNAME STRUCT)</tt> and updated using <tt>(NAME-SLOTNAME-set!</tt> <tt>STRUCT</tt> <tt>VALUE)</tt>.</p><PRE>
(define-record point x y)
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">p1</FONT></B> (make-point 123 456))
(point? p1)                      =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #t
(point-x p1)                     =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 123
(point-y-set! p1 99)
(point-y p1)                     =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 99
</PRE>
<a name="define-record-printer"></a><h3>define-record-printer</h3><pre>[syntax] (define-record-printer (NAME RECORDVAR PORTVAR) BODY ...)
[syntax] (define-record-printer NAME PROCEDURE)</pre><p>Defines a printing method for record of the type <tt>NAME</tt> by associating a procedure with the record type. When a record of this type is written using <tt>display, write</tt> or <tt>print</tt>, then the procedure is called with two arguments: the record to be printed and an output-port.</p><PRE>
(define-record foo x y z)
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">f</FONT></B> (make-foo 1 2 3))
(define-record-printer (foo x out)
  (fprintf out <B><FONT COLOR="#BC8F8F">&quot;#,(foo ~S ~S ~S)&quot;</FONT></B>
           (foo-x x) (foo-y x) (foo-z x)) )
(define-reader-ctor 'foo make-foo)
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">s</FONT></B> (with-output-to-string
              (<B><FONT COLOR="#A020F0">lambda</FONT></B> () (write f))))
s                                   =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;#,(foo 1 2 3)&quot;</FONT></B>
(equal? f (with-input-from-string
              s read)))             =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #t
</PRE>
<p><tt>define-record-printer</tt> works also with SRFI-9 record types.</p><a name="define-record-type"></a><h3>define-record-type</h3><pre>[syntax] (define-record-type NAME
                             (CONSTRUCTOR TAG ...)
                             PREDICATE
                             (FIELD ACCESSOR [MODIFIER]) ...)</pre><p>SRFI-9 record types. For more information see the documentation for <a href="http://srfi.schemers.org/srfi-9/srfi-9.html" class="external">SRFI-9</a>.</p><a name="other-forms"></a><h2>Other forms</h2><a name="assert"></a><h3>assert</h3><pre>[syntax] (assert EXP [STRING ARG ...])</pre><p>Signals an error if <tt>EXP</tt> evaluates to false. An optional message <tt>STRING</tt> and arguments <tt>ARG ...</tt> may be supplied to give a more informative error-message.  If compiled in <em>unsafe</em> mode (either by specifying the <tt>-unsafe</tt> compiler option or by declaring <tt>(unsafe)</tt>), then this expression expands to an unspecified value. The result is the value of <tt>EXP</tt>.</p><a name="cond-expand"></a><h3>cond-expand</h3><pre>[syntax] (cond-expand FEATURE-CLAUSE ...)</pre><p>Expands by selecting feature clauses. This form is allowed to appear in non-toplevel expressions.</p><p>Predefined feature-identifiers are "situation" specific:</p><dl><dt>compile</dt><dd><tt>eval</tt>, <tt>library</tt>, <tt>match</tt>, <tt>compiling</tt>, <tt>srfi-11</tt>, <tt>srfi-15</tt>, <tt>srfi-31</tt>, <tt>srfi-26</tt>, <tt>srfi-16</tt>, <tt>utils</tt>, <tt>regex</tt>, <tt>srfi-4</tt>, <tt>match</tt>, <tt>srfi-1</tt>, <tt>srfi-69</tt>, <tt>srfi-28</tt>, <tt>extras</tt>, <tt>srfi-8</tt>, <tt>srfi-6</tt>, <tt>srfi-2</tt>, <tt>srfi-0</tt>, <tt>srfi-10</tt>, <tt>srfi-9</tt>, <tt>srfi-55</tt>, <tt>srfi-61</tt> <tt>chicken</tt>, <tt>srfi-23</tt>, <tt>srfi-30</tt>, <tt>srfi-39</tt>, <tt>srfi-62</tt>, <tt>srfi-17</tt>, <tt>srfi-12</tt>.</dd><dt>load</dt><dd><tt>srfi-69</tt>, <tt>srfi-28</tt>, <tt>extras</tt>, <tt>srfi-8</tt>, <tt>srfi-6</tt>, <tt>srfi-2</tt>, <tt>srfi-0</tt>, <tt>srfi-10</tt>, <tt>srfi-9</tt>, <tt>srfi-55</tt>, <tt>srfi-61</tt>, <tt>chicken</tt>, <tt>srfi-23</tt>, <tt>srfi-30</tt>, <tt>srfi-39</tt>, <tt>srfi-62</tt>, <tt>srfi-17</tt>, <tt>srfi-12</tt>. <tt>library</tt> is implicit.</dd><dt>eval</dt><dd><tt>match</tt>, <tt>csi</tt>, <tt>srfi-11</tt>, <tt>srfi-15</tt>, <tt>srfi-31</tt>, <tt>srfi-26</tt>, <tt>srfi-16</tt>, <tt>srfi-69</tt>, <tt>srfi-28</tt>, <tt>extras</tt>, <tt>srfi-8</tt>, <tt>srfi-6</tt>, <tt>srfi-2</tt>, <tt>srfi-0</tt>, <tt>srfi-10</tt>, <tt>srfi-9</tt>, <tt>srfi-55</tt>, <tt>srfi-61</tt>, <tt>chicken</tt>, <tt>srfi-23</tt>, <tt>srfi-30</tt>, <tt>srfi-39</tt>, <tt>srfi-62</tt>, <tt>srfi-17</tt>, <tt>srfi-12</tt>. <tt>library</tt> is implicit.</dd></dl><p>The following feature-identifiers are available in all situations: <tt>(machine-byte-order)</tt>, <tt>(machine-type)</tt>, <tt>(software-type)</tt>, <tt>(software-version)</tt>, where the actual feature-identifier is platform dependent.</p><p>In addition the following feature-identifiers may exist: <tt>applyhook</tt>, <tt>extraslot</tt>, <tt>ptables</tt>, <tt>dload</tt>.</p><p>For further information, see the documentation for <a href="http://srfi.schemers.org/srfi-0/srfi-0.html" class="external">SRFI-0</a>.</p><a name="ensure"></a><h3>ensure</h3><pre>[syntax] (ensure PREDICATE EXP [ARGUMENTS ...])</pre><p>Evaluates the expression <tt>EXP</tt> and applies the one-argument procedure <tt>PREDICATE</tt> to the result. If the predicate returns <tt>#f</tt> an error is signaled, otherwise the result of <tt>EXP</tt> is returned.  If compiled in <em>unsafe</em> mode (either by specifying the <tt>-unsafe</tt> compiler option or by declaring <tt>(unsafe)</tt>), then this expression expands to an unspecified value.  If specified, the optional <tt>ARGUMENTS</tt> are used as arguments to the invocation of the error-signalling code, as in <tt>(error ARGUMENTS ...)</tt>. If no <tt>ARGUMENTS</tt> are given, a generic error message is displayed with the offending value and <tt>PREDICATE</tt> expression.</p><a name="eval-when"></a><h3>eval-when</h3><pre>[syntax] (eval-when (SITUATION ...) EXP ...)</pre><p>Controls evaluation/compilation of subforms. <tt>SITUATION</tt> should be one of the symbols <tt>eval</tt>, <tt>compile</tt> or <tt>load</tt>. When encountered in the evaluator, and the situation specifier <tt>eval</tt> is not given, then this form is not evaluated and an unspecified value is returned.  When encountered while compiling code, and the situation specifier <tt>compile</tt> is given, then this form is evaluated at compile-time.  When encountered while compiling code, and the situation specifier <tt>load</tt> is not given, then this form is ignored and an expression resulting into an unspecified value is compiled instead.</p><p>The following table should make this clearer:</p><table><tr><th></th><th><p>In compiled code</p></th><th><p>In interpreted code</p></th></tr><tr><td><p><tt>eval</tt></p></td><td><p>ignore</p></td><td><p>evaluate</p></td></tr><tr><td><p><tt>compile</tt></p></td><td><p>evaluate at compile time</p></td><td><p>ignore</p></td></tr><tr><td><p><tt>load</tt></p></td><td><p>compile as normal</p></td><td><p>ignore</p></td></tr></table><p>The situation specifiers <tt>compile-time</tt> and <tt>run-time</tt> are also defined and have the same meaning as <tt>compile</tt> and <tt>load</tt>, respectively.</p><a name="include"></a><h3>include</h3><pre>[syntax] (include STRING)</pre><p>Include toplevel-expressions from the given source file in the currently compiled/interpreted program.  If the included file has the extension <tt>.scm</tt>, then it may be omitted.  The file is searched in the current directory and, if not found, in all directories specified in the <tt>-include-path</tt> option.</p><a name="nth-value"></a><h3>nth-value</h3><pre>[syntax] (nth-value N EXP)</pre><p>Returns the <tt>N</tt>th value (counting from zero) of the values returned by expression <tt>EXP</tt>.</p><a name="time"></a><h3>time</h3><pre>[syntax] (time EXP1 ...)</pre><p>Evaluates <tt>EXP1 ...</tt> and prints elapsed time and some values about GC use, like time spent in major GCs, number of minor and major GCs.</p><p>Previous: <a href="non-standard-read-syntax.html" class="internal">Non-standard read syntax</a></p><p>Next: <a href="pattern-matching.html" class="internal">Pattern matching</a></p>
</body></html>