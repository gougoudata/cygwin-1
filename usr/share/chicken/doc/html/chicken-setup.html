<html><head><title>CHICKEN User's Manual - chicken-setup</title></head><body>
<p> </p><a name="chicken-setup"></a><h1>chicken-setup</h1><a name="extension-libraries"></a><h2>Extension libraries</h2><p>Extension libraries (<em>eggs</em>) are extensions to the core functionality provided by the basic CHICKEN system, to be built and installed separately.  The mechanism for loading compiled extensions is based on dynamically loadable code and as such is only available on systems on which loading compiled code at runtime is supported. Currently these are most UNIX-compatible platforms that provide the <tt>libdl</tt> functionality like Linux, Solaris, BSD, Mac OS X and Windows using Cygwin.</p><p>Note: Extension may also be normal applications or shell scripts, but are usually libraries.</p><p><tt>chicken-setup</tt> will download the source code for extension automatically from the canonical server at <a href="http://www.call-with-current-continuation.org/eggs" class="external">http://www.call-with-current-continuation.org/eggs</a> if the requested egg does not exist in the current directory. Various command-line options exist for customizing the process and/or retrieving the egg from other locations or in other formats.</p><a name="installing-extensions"></a><h2>Installing extensions</h2><p>To install an extension library, run the <tt>chicken-setup</tt> program with the extension name as argument. The extension archive is downloaded, its contents extracted and the contained <em>setup</em> script is executed. This setup script is a normal Scheme source file, which will be interpreted by <tt>chicken-setup</tt>. The complete language supported by <tt>csi</tt> is available, and the library units <tt>srfi-1 regex utils posix tcp</tt> are loaded. Additional libraries can be loaded at run-time.</p><p>The setup script should perform all necessary steps to build the new library (or application). After a successful build, the extension can be installed by invoking one of the procedures <tt>install-extension</tt>, <tt>install-program</tt> or <tt>install-script</tt>.  These procedures will copy a number of given files into the extension repository or in the path where the CHICKEN executables are located (in the case of executable programs or scripts). Additionally the list of installed files, and user-defined metadata is stored in the repository.</p><p>If no extension name is given on the command-line, and if none of the options <tt>-list</tt>, <tt>-version</tt>, <tt>-repository</tt> (without argument), <tt>-program-path</tt> (without argument), <tt>-fetch</tt>, <tt>-fetch-tree</tt> or <tt>-docindex</tt> is given, then all <tt>.setup</tt> scripts in the current directory are processed.</p><a name="installing-extensions-that-use-libraries"></a><h3>Installing extensions that use libraries</h3><p>Sometimes an extension requires a C library to compile. Compilation can fail when your system has this library in a nonstandard location. Luckily, normally Chicken searches in the default locations <tt>/usr</tt> and <tt>/usr/local</tt>, and in the prefix where Chicken itself was installed. Sometimes this is not enough, so you'll need to supply chicken-setup with some extra hints to the C compiler/linker. Here's an example:</p><pre> chicken-setup -c '-I/usr/pkg/include/mysql' -c '-L/usr/pkg/lib/mysql' -c '-L -R/usr/pkg/lib/mysql' mysql</pre><p>This installs the mysql egg with the extra compiler options -I and -L to set the include path and the library search path. The second -L switch passes the -R option directly to the linker, which causes the library path to get hardcoded into the resulting extension file (for systems that do not use ld.so.conf).</p><a name="creating-extensions"></a><h2>Creating extensions</h2><p>Extensions can be created by creating an (optionally gzipped) <tt>tar</tt> archive named <tt>EXTENSION.egg</tt> containing all needed files plus a <tt>.setup</tt> script in the root directory.  After <tt>chicken-setup</tt> has extracted the files, the setup script will be invoked. There are no additional constraints on the structure of the archive, but the setup script has to be in the root path of the archive.</p><a name="procedures-and-macros-available-in-setup-scripts"></a><h2>Procedures and macros available in setup scripts</h2><a name="install-extension"></a><h3>install-extension</h3><pre>(install-extension ID FILELIST [INFOLIST])</pre><p>Installs the extension library with the name <tt>ID</tt>. All files given in the list of strings <tt>FILELIST</tt> will be copied to the extension repository. It should be noted here that the extension id has to be identical to the name of the file implementing the extension. The extension may load or include other files, or may load other extensions at runtime specified by the <tt>require-at-runtime</tt> property.</p><p><tt>FILELIST</tt> may be a filename, a list of filenames, or a list of pairs of the form <tt>(SOURCE DEST)</tt> (if you want to copy into a particular sub-directory - the destination directory will be created as needed). If <tt>DEST</tt> is a relative pathname, &lt; it will be copied into the extension repository.</p><p>The optional argument <tt>INFOLIST</tt> should be an association list that maps symbols to values, this list will be stored as <tt>ID.setup-info</tt> at the same location as the extension code. Currently the following properties are used:</p><a name="syntax"></a><h4>syntax</h4><pre>[extension property] (syntax)</pre><p>Marks the extension as syntax-only. No code is compiled, the extension is intended as a file containing macros to be loaded at compile/macro-expansion time.</p><a name="require-at-runtime"></a><h4>require-at-runtime</h4><pre>[extension property] (require-at-runtime ID ...)</pre><p>Specifies extensions that should be loaded (via <tt>require</tt>) at runtime. This is mostly useful for syntax extensions that need additional support code at runtime.</p><a name="version"></a><h4>version</h4><pre>[extension property] (version STRING)</pre><p>Specifies version string.</p><a name="documentation"></a><h4>documentation</h4><pre>[extension property] (documentation FILENAME)</pre><p>The filename of a HTML document containing extension-specific documentation. This file should be given in the file-list passed to <tt>install-extension</tt> and a link to it will be automatically included in the index page (accessible via <tt>chicken-setup -docindex</tt>).</p><a name="examples"></a><h4>examples</h4><pre>[extension property] (examples FILENAME ...)</pre><p>Copies the given files into the examples directory, which is usually  <tt>$prefix/share/chicken/examples</tt> or <tt>(make-pathname (chicken-home) "examples")</tt>).</p><p>Note that the files listed in this property should not be listed in the normal list of files to install passed to <tt>install-extension</tt>. This is the only exception - other files that are installed in the repository must be given in the file list.</p><a name="exports"></a><h4>exports</h4><pre>[extension property] (exports EXPORT ...)</pre><p>Add export-information to the generated extension-information. <tt>EXPORT</tt> may be a symbol naming an exported toplevel variable or a string designating a file with exported variables, as generated by the <tt>-emit-exports</tt> option or the <tt>emit-exports</tt> declaration specifier.</p><a name="static"></a><h4>static</h4><pre>[extension property] (static STRING)</pre><p>If the extension also provides a static library, then STRING should contain the name of that library. Used by <tt>csc</tt> when compiling with the <tt>-static-extensions</tt> option.</p><a name="static-options"></a><h4>static-options</h4><pre>[extension property] (static-options STRING)</pre><p>Additional options that should be passed to the linker when linking with the static version of an extension (see <tt>static</tt> above). Used by <tt>csc</tt> when compiling with the <tt>-static-extensions</tt> option.</p><p>All other properties are currently ignored. The <tt>FILELIST</tt> argument may also be a single string.</p><a name="install-program"></a><h3>install-program</h3><pre>[procedure] (install-program ID FILELIST [INFOLIST])</pre><p>Similar to <tt>install-extension</tt>, but installs an executable program in the executable path (usually <tt>/usr/local/bin</tt>).</p><a name="install-script"></a><h3>install-script</h3><pre>[procedure] (install-script ID FILELIST [INFOLIST])</pre><p>Similar to <tt>install-program</tt>, but additionally changes the file permissions of all files in <tt>FILELIST</tt> to executable (for installing shell-scripts).</p><a name="run"></a><h3>run</h3><pre>[syntax] (run FORM ...)</pre><p>Runs the shell command <tt>FORM</tt>, which is wrapped in an implicit <tt>quasiquote</tt>.  <tt>(run (csc ...))</tt> is treated specially and passes <tt>-v</tt> (if <tt>-verbose</tt> has been given to <tt>chicken-setup</tt>) and <tt>-feature compiling-extension</tt> options to the compiler.</p><a name="compile"></a><h3>compile</h3><pre>[syntax] (compile FORM ...)</pre><p>Equivalent to <tt>(run (csc FORM ...))</tt>.</p><a name="make"></a><h3>make</h3><pre>[syntax] (make ((TARGET (DEPENDENT ...) COMMAND ...) ...) ARGUMENTS)</pre><p>A <em>make</em> macro that executes the expressions <tt>COMMAND ...</tt>, when any of the dependents <tt>DEPENDENT ...</tt> have changed, to build <tt>TARGET</tt>. This is the same as the <tt>make</tt> extension, which is available separately. For more information, see <a href="http://www.call-with-current-continuation.org/eggs/make.html" class="external">make</a>.</p><a name="patch"></a><h3>patch</h3><pre>[procedure] (patch WHICH REGEX SUBST)</pre><p>Replaces all occurrences of the regular expression <tt>REGEX</tt> with the string <tt>SUBST</tt>, in the file given in <tt>WHICH</tt>. If <tt>WHICH</tt> is a string, the file will be patched and overwritten. If <tt>WHICH</tt> is a list of the form <tt>OLD NEW</tt>, then a different file named <tt>NEW</tt> will be generated.</p><a name="copy-file"></a><h3>copy-file</h3><pre>[procedure] (copy-file FROM TO)</pre><p>Copies the file or directory (recursively) given in the string <tt>FROM</tt> to the destination file or directory <tt>TO</tt>.</p><a name="move-file"></a><h3>move-file</h3><pre>[procedure] (move-file FROM TO)</pre><p>Moves the file or directory (recursively) given in the string <tt>FROM</tt> to the destination file or directory <tt>TO</tt>.</p><a name="remove-file"></a><h3>remove-file*</h3><pre>[procedure] (remove-file* PATH)</pre><p>Removes the file or directory given in the string <tt>PATH</tt>.</p><a name="find-library"></a><h3>find-library</h3><pre>[procedure] (find-library NAME PROC)</pre><p>Returns <tt>#t</tt> if the library named <tt>libNAME.[a|so]</tt> (unix) or <tt>NAME.lib</tt> (windows) could be found by compiling and linking a test program. <tt>PROC</tt> should be the name of a C function that must be provided by the library. If no such library was found or the function could not be resolved, <tt>#f</tt> is returned.</p><a name="find-header"></a><h3>find-header</h3><pre>[procedure] (find-header NAME)</pre><p>Returns <tt>#t</tt> if a C include-file with the given name is available, or <tt>#f</tt> otherwise.</p><a name="try-compile"></a><h3>try-compile</h3><pre>[procedure] (try-compile CODE #!key cc cflags ldflags compile-only c++)</pre><p>Returns <tt>#t</tt> if the C code in <tt>CODE</tt> compiles and links successfully, or <tt>#f</tt> otherwise. The keyword parameters <tt>cc</tt> (compiler name, defaults to the C compiler used to build this system), <tt>cflags</tt> and <tt>ldflags</tt> accept additional compilation and linking options. If <tt>compile-only</tt> is true, then no linking step takes place. If the keyword argument <tt>c++</tt> is given and true, then the code will be compiled in C++ mode.</p><a name="create-directory"></a><h3>create-directory</h3><pre>[procedure] (create-directory PATH)</pre><p>Creates the directory given in the string <tt>PATH</tt>, with all parent directories as needed.</p><a name="chicken-prefix"></a><h3>chicken-prefix</h3><pre>[parameter] chicken-prefix</pre><p>The installation prefix specified when CHICKEN was built.</p><a name="installation-prefix"></a><h3>installation-prefix</h3><pre>[parameter] installation-prefix</pre><p>An alternative installation prefix that will be prepended to extension installation paths if specified. It is set by the <tt>-install-prefix</tt> option or environment variable <tt>CHICKEN_INSTALL_PREFIX</tt>.</p><a name="program-path"></a><h3>program-path</h3><pre>[parameter] (program-path [PATH])</pre><p>Holds the path where executables are installed and defaults to either <tt>$CHICKEN_PREFIX/bin</tt>, if the environment variable <tt>CHICKEN_PREFIX</tt> is set or the path where the CHICKEN binaries (<tt>chicken</tt>, <tt>csi</tt>, etc.) are installed.</p><a name="setup-root-directory"></a><h3>setup-root-directory</h3><pre>[parameter] (setup-root-directory [PATH])</pre><p>Contains the path of the directory where <tt>chicken-setup</tt> was invoked.</p><a name="setup-build-directory"></a><h3>setup-build-directory</h3><pre>[parameter] (setup-build-directory [PATH])</pre><p>Contains the path of the directory where the extension is built. This is not necessarily identical to <tt>setup-root-directory</tt>.</p><a name="setup-verbose-flag"></a><h3>setup-verbose-flag</h3><pre>[parameter] (setup-verbose-flag [BOOL])</pre><p>Reflects the setting of the <tt>-verbose</tt> option, i.e. is <tt>#t</tt>, if <tt>-verbose</tt> was given.</p><a name="setup-install-flag"></a><h3>setup-install-flag</h3><pre>[parameter] (setup-install-flag [BOOL])</pre><p>Reflects the setting of the <tt>--no-install</tt> option, i.e. is <tt>#f</tt>, if <tt>-no-install</tt> was given.</p><a name="required-chicken-version"></a><h3>required-chicken-version</h3><pre>[procedure] (required-chicken-version VERSION)</pre><p>Signals an error if the version of CHICKEN that this script runs under is lexicographically less than <tt>VERSION</tt> (the argument will be converted to a string, first).</p><a name="required-extension-version"></a><h3>required-extension-version</h3><pre>[procedure] (required-extension-version EXTENSION1 VERSION1 ...)</pre><p>Checks whether the extensions <tt>EXTENSION1 ...</tt> are installed and at least of version <tt>VERSION1 ...</tt>. The test is made by lexicographically comparing the string-representations of the given version with the version  of the installed extension. If one of the listed extensions is not installed, has no associated version information or is of a version older than the one specified.</p><a name="cross-chicken"></a><h3>cross-chicken</h3><pre>[procedure] (cross-chicken)</pre><p>Returns <tt>#t</tt> if this system is configured for cross-compilation or <tt>#f</tt> otherwise.</p><a name="host-extension"></a><h3>host-extension</h3><pre>[parameter] host-extension</pre><p>For a cross-compiling CHICKEN, when compiling an extension, then it should be built for the host environment (as opposed to the target environment). This parameter is controlled by the <tt>-host-extension</tt> command-line option. A setup script should perform the proper steps of compiling any code by passing <tt>-host</tt> when invoking <tt>csc</tt> or using the <tt>compile</tt> macro.</p><a name="examples-for-extensions"></a><h2>Examples for extensions</h2><p>The simplest case is a single file that does not export any syntax. For example</p><PRE>
<I><FONT COLOR="#B22222">;;;; hello.scm
</FONT></I>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">hello</FONT></B> name)
  (print <B><FONT COLOR="#BC8F8F">&quot;Hello, &quot;</FONT></B> name <B><FONT COLOR="#BC8F8F">&quot; !&quot;</FONT></B>) )
</PRE>
<p>We need a <tt>.setup</tt> script to build and install our nifty extension:</p><PRE>
<I><FONT COLOR="#B22222">;;;; hello.setup
</FONT></I>
<I><FONT COLOR="#B22222">;; compile the code into a dynamically loadable shared object
</FONT></I><I><FONT COLOR="#B22222">;; (will generate hello.so)
</FONT></I>(compile -s hello.scm)

<I><FONT COLOR="#B22222">;; Install as extension library
</FONT></I>(install-extension 'hello <B><FONT COLOR="#BC8F8F">&quot;hello.so&quot;</FONT></B>)
</PRE>
<p>After entering </p><pre>$ chicken-setup hello</pre><p>at the shell prompt (and in the same directory where the two files exist), the file <tt>hello.scm</tt> will be compiled into a dynamically loadable library. If the compilation succeeds, <tt>hello.so</tt> will be stored in the repository, together with a file named <tt>hello.setup-info</tt> containing an a-list with metadata. If no extension name is given to <tt>chicken-setup</tt>, it will simply execute the first file with the <tt>.setup</tt> extension it can find.</p><p>Use it like any other CHICKEN extension:</p><pre>$ csi -q
#;1&gt; (require-extension hello)
; loading /usr/local/lib/chicken/1/hello.so ...
#;2&gt; (hello "me")
Hello, me!
#;3&gt;</pre><p>Here we create a simple application:</p><PRE>
<I><FONT COLOR="#B22222">;;;; hello2.scm
</FONT></I>
(print <B><FONT COLOR="#BC8F8F">&quot;Hello, &quot;</FONT></B>)
(for-each (<B><FONT COLOR="#A020F0">lambda</FONT></B> (x) (printf <B><FONT COLOR="#BC8F8F">&quot;~A &quot;</FONT></B> x)) (command-line-arguments))
(print <B><FONT COLOR="#BC8F8F">&quot;!&quot;</FONT></B>)
</PRE>
<p>We also need a setup script:</p><PRE>
<I><FONT COLOR="#B22222">;;;; hello2.setup
</FONT></I>
(compile hello2.scm)  <I><FONT COLOR="#B22222">; compile `hello2'
</FONT></I>(install-program 'hello2 <B><FONT COLOR="#BC8F8F">&quot;hello2&quot;</FONT></B>) <I><FONT COLOR="#B22222">; name of the extension and files to be installed
</FONT></I></PRE>
<p>To use it, just run <tt>chicken-setup</tt> in the same directory:</p><pre>$ chicken-setup</pre><p>(Here we omit the extension name)</p><p>Now the program <tt>hello2</tt> will be installed in the same location as the other CHICKEN tools (like <tt>chicken</tt>, <tt>csi</tt>, etc.), which will normally be <tt>/usr/local/bin</tt>.  Note that you need write-permissions for those locations and may have to run <tt>chicken-setup</tt> with administrative rights.</p><p>Uninstallation is just as easy:</p><pre>$ chicken-setup -uninstall hello2</pre><p><tt>chicken-setup</tt> provides a <tt>make</tt> macro, so build operations can be of arbitrary complexity. When running <tt>chicken-setup</tt> with an argument <tt>NAME</tt>, for which no associated file <tt>NAME.setup</tt>, <tt>NAME.egg</tt> or <tt>NAME.scm</tt> exists will ask you to download the extension via HTTP from the default URL <a href="http://www.call-with-current-continuation.org/eggs" class="external">http://www.call-with-current-continuation.org/eggs</a>. You can use the <tt>-host</tt> option to specify an alternative source location. Extensions that are required to compile and/or use the requested extension are downloaded and installed automatically.</p><p>If the given extension name contains a path prefix and the <tt>-host</tt> option is given, then <tt>chicken-setup</tt> can also download and install eggs from an arbitrary HTTP server. Alternatively you can pass a full URL (including the <tt>http://</tt> prefix. Note that no dependency checks are done when downloading eggs directly with the URL syntax.</p><p>Finally a somewhat more complex example: We want to package a syntax extension with additional support code that is to be loaded at run-time of any Scheme code that uses that extension. We create a <em>glass</em> lambda, a procedure with free variables that can be manipulated from outside:</p><PRE>
<I><FONT COLOR="#B22222">;;;; glass.scm
</FONT></I>
(define-macro (glass-lambda llist vars . body)
  <I><FONT COLOR="#B22222">;; Low-level macros are fun!
</FONT></I>  (<B><FONT COLOR="#A020F0">let</FONT></B> ([lvar (gensym)]
	[svar (gensym)] 
	[x (gensym)]
	[y (gensym)] 
	[yn (gensym)] )
    `(<B><FONT COLOR="#A020F0">let</FONT></B> ,(map (<B><FONT COLOR="#A020F0">lambda</FONT></B> (v) (list v #f)) vars)
       (<B><FONT COLOR="#A020F0">define</FONT></B> (,svar ,x . ,y)
	 (<B><FONT COLOR="#A020F0">let*</FONT></B> ([,yn (pair? ,y)]
		[,y (<B><FONT COLOR="#A020F0">and</FONT></B> ,yn (car ,y))] )
	   (<B><FONT COLOR="#A020F0">case</FONT></B> ,x
	     ,@(map (<B><FONT COLOR="#A020F0">lambda</FONT></B> (v)
		      `([,v] (<B><FONT COLOR="#A020F0">if</FONT></B> ,yn 
				 (<B><FONT COLOR="#A020F0">set!</FONT></B> ,v ,y)
				 ,v) ) )
		    vars)
	     (<B><FONT COLOR="#A020F0">else</FONT></B> (error <B><FONT COLOR="#BC8F8F">&quot;variable not found&quot;</FONT></B> ,x)) ) ) )
       (<B><FONT COLOR="#A020F0">define</FONT></B> ,lvar (<B><FONT COLOR="#A020F0">lambda</FONT></B> ,llist ,@body))
       (extend-procedure ,lvar ,svar) ) ) )
</PRE>
<p>Here some support code that needs to be loaded at runtime:</p><PRE>
<I><FONT COLOR="#B22222">;;;; glass-support.scm
</FONT></I>
(require-extension lolevel)

(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">glass-lambda-accessor</FONT></B> procedure-data)
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">glass-lambda-ref</FONT></B> gl v) ((procedure-data gl) v))
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">glass-lambda-set!</FONT></B> gl v x) ((procedure-data gl) v x))
</PRE>
<p>The setup script looks like this:</p><PRE>
(compile -s glass-support.scm)

(install-extension
  'glass
  '(<B><FONT COLOR="#BC8F8F">&quot;glass.scm&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;glass-support.so&quot;</FONT></B>)
  '((syntax) (require-at-runtime glass-support)) )
</PRE>
<p>The invocation of <tt>install-extension</tt> provides the files that are to be copied into the extension repository, and a metadata list that specifies that the extension <tt>glass</tt> is a syntax extension and that, if it is declared to be used by other code (either with the <tt>require-extension</tt> or <tt>require-for-syntax</tt> form), then client code should perform an implicit <tt>(require 'glass-support)</tt> at startup.</p><p>This can be conveniently packaged as an <em>egg</em>:</p><pre>$ tar cfz glass.egg glass.setup glass.scm glass-support.scm</pre><p>And now we use it:</p><pre>$ chicken-setup glass
$ csi -quiet
#;1&gt; (require-extension glass)
; loading /usr/local/lib/chicken/1/glass.scm ...
; loading /usr/local/lib/chicken/1/glass-support.so ...
#;2&gt; (define foo (glass-lambda (x) (y) (+ x y)))
#;3&gt; (glass-lambda-set! foo 'y 99)
#;4&gt; (foo 33)
132</pre><a name="chicken-setup-reference"></a><h2>chicken-setup reference</h2><p>Available options:</p><dl><dt><tt>-h  -help</tt></dt><dd>Show usage information and exit.</dd><dt><tt>-V  -version</tt></dt><dd>Display version and exit.</dd><dt><tt>-R  -repository [PATHNAME]</tt></dt><dd>When used without an argument, the path of the extension repository is displayed on standard output. When given an argument, the repository pathname (and the <tt>repository-path</tt> parameter) will be set to <tt>PATHNAME</tt> for all subsequent operations. The default repository path is the installation library directory (usually <tt>/usr/local/lib/chicken</tt>), or (if set) the directory given in the environment variable <tt>CHICKEN_REPOSITORY</tt>. <tt>PATHNAME</tt> should be an absolute pathname.</dd><dt><tt>-P  -program-path [PATHNAME]</tt></dt><dd>When used without an argument, the path for executables is displayed on standard output. When given an argument, the program path for installing executables and scripts will be set to <tt>PATHNAME</tt> for all subsequent operations. <tt>PATHNAME</tt> should be an absolute pathname.</dd><dt><tt>-h  -host HOSTNAME[:PORT]</tt></dt><dd>Specifies alternative host for downloading extensions, optionally with a TCP port number (which defaults to 80).</dd><dt><tt>-u  -uninstall EXTENSION</tt></dt><dd>Removes all files that were installed for <tt>EXTENSION</tt> from the file-system, together with any metadata that has been stored.</dd><dt><tt>-l  -list [NAME ...]</tt></dt><dd>List all installed extensions or show extension information.</dd><dt><tt>-r  -run FILENAME</tt></dt><dd>Load and execute given file.</dd><dt><tt>-s  -script FILENAME</tt></dt><dd>Executes the given Scheme source file with all remaining arguments and exit. The <em>she-bang</em> shell script header is recognized, so you can write Scheme scripts that use <tt>chicken-setup</tt> just as with <tt>csi</tt>.</dd><dt><tt>-e  -eval EXPRESSION</tt></dt><dd>Evaluates the given expression(s)</dd><dt><tt>-v  -verbose</tt></dt><dd>Display additional debug information</dd><dt><tt>-k  -keep</tt></dt><dd>Keep temporary files and directories</dd><dt><tt>-c  -csc-option OPTION</tt></dt><dd>Passes <tt>OPTION</tt> as an extra argument to invocations of the compiler-driver (<tt>csc</tt>); this works only if <tt>csc</tt> is invoked as <tt>(run (csc ...))</tt></dd><dt><tt>-d  -dont-ask</tt></dt><dd>Do not ask the user before trying to download required extensions</dd><dt><tt>-n  -no-install</tt></dt><dd>Do not install generated binaries and/or support files; any invocations of <tt>install-program</tt>, <tt>install-extension</tt> or <tt>install-script</tt> will be be no-ops</dd><dt><tt>-i  -docindex</tt></dt><dd>Displays the path to the index-page of any installed extension-documentation; if the index page does not exist, it is created</dd><dt><tt>-t  -test EXTENSION ...</tt></dt><dd>return success if all given extensions are installed</dd><dt><tt>-ls EXTENSION</tt></dt><dd>List installed files for extension</dd><dt><tt>-fetch-tree</tt></dt><dd>Download and print the repository catalog</dd><dt><tt>-create-tree DIRECTORY</tt></dt><dd>Create a fresh, minimal repository catalog and writes it to stdout</dd><dt><tt>-t  -test</tt></dt><dd>If the extension sources contain a directory named <tt>tests</tt> and this directory includes a file named <tt>run.scm</tt> then this file is executed (with <tt>tests</tt> being the current working directory)</dd><dt><tt>-tree FILENAME</tt></dt><dd>Download and show the repository catalog</dd><dt><tt>-svn URL</tt></dt><dd>Fetch extension from <a href="http://subversion.tigris.org" class="external">Subversion</a> repository</dd><dt><tt>-svn-trunk URL</tt></dt><dd>Fetch extension from trunk in <a href="http://subversion.tigris.org" class="external">Subversion</a> repository</dd><dt><tt>-revision REV</tt></dt><dd>Specifies SVN revision to check out</dd><dt><tt>-local PATHNAME</tt></dt><dd>Fetch extension from local file</dd><dt><tt>-install-prefix PATHNAME</tt></dt><dd>Specify alternative installation prefix (for packaging)</dd><dt><tt>-host-extension</tt></dt><dd>Compile extension in "host" mode (sets the parameter <tt>host-extension</tt> to <tt>#f</tt>)</dd><dt><tt>-build-prefix PATHNAME</tt></dt><dd>Location where chicken-setup will create egg build directories  (default: the value of environment variable CHICKEN_TMPDIR, or <tt>/tmp/chicken-{MAJOR-VERSION-build-{USER</tt>}})</dd><dt><tt>-download-path PATHNAME</tt></dt><dd>Location where chicken-setup will save downloaded files  (default: <tt>build-prefix/downloads</tt>)</dd><dt><tt>--</tt></dt><dd>Ignore all following arguments</dd></dl><p>Note that the options are processed exactly in the order in which they appear in the command-line.</p><a name="windows-notes"></a><h2>Windows notes</h2><p><tt>chicken-setup</tt> works on Windows, when compiled with Visual C++, but depends on the <tt>tar</tt> and <tt>gunzip</tt> tools to extract the contents of an egg. The best way is to download an egg either manually (or with <tt>chicken-setup -fetch</tt>) and extract its contents with a separate program (like <tt>winzip</tt>). the <tt>CHICKEN_REPOSITORY</tt> environment variable has to be set to a directory where your compiled extensions should be located.</p><p>The <tt>.setup</tt> scripts will not always work under Windows, and the extensions may require libraries that are not provided for Windows or work differently. Under these circumstances it is recommended to perform the required steps to build an extension manually.</p><p>The required UNIX tools are also available as Windows binaries. Google or ask on the CHICKEN mailing list if you need help locating them.</p><a name="security"></a><h2>Security</h2><p>When extensions are downloaded and installed one is executing code from potentially compromised systems. This applies also when <tt>chicken-setup</tt> executes system tests for required extensions. As the code has been  retrieved over the network effectively untrusted code is going to be evaluated. When <tt>chicken-setup</tt> is run as <em>root</em> the whole system is at the mercy of the build instructions (note that this is also the case every time you install software via <tt>sudo make install</tt>, so this is not specific to the CHICKEN extension mechanism).</p><p>Security-conscious users should never run <tt>chicken-setup</tt> as root. A simple remedy is to set the environment variable <tt>CHICKEN_REPOSITORY</tt>, which will transparently place the repository at an arbitrary user-selected location. Alternatively obtain write/execute access to the default location of the repository (usually <tt>/usr/local/lib/chicken</tt>) to avoid running as root.</p><a name="other-modes-of-installation"></a><h2>Other modes of installation</h2><p>It is possible to install extensions directly from a <a href="http://subversion.tigris.org" class="external">Subversion</a> repository or from a local checkout by using the <tt>-svn</tt> or <tt>-local</tt> options. By using either the <tt>svn</tt> client program (which must be installed) or file-system operations, all necessary files will be copied into the current directory (creating a subdirectory named <tt>EXTENSIONNAME.egg-dir</tt>), built and subsequently installed.</p><p>Dependency information, which is necessary to ensure required extensions are also installed, is downloaded automatically.  If you have no internet connection or don't want to connect, you can also use a local file containing the necessary dependency information.  The <tt>-fetch-tree</tt> option retrieves the canonical <em>repository file</em> at <a href="http://www.call-with-current-continuation.org/eggs/repository" class="external">http://www.call-with-current-continuation.org/eggs/repository</a>, writing it to stdout. Redirecting this output into a file and passing the file via the <tt>-tree</tt> option to <tt>chicken-setup</tt> allows you now to use the local repository file:</p><p>Retrieve complete extension repository (big):</p><pre>% cd /opt
% svn co <a href="https://galinha.ucpel.tche.br/svn/chicken-eggs/release/3" class="external">https://galinha.ucpel.tche.br/svn/chicken-eggs/release/3</a> eggs</pre><p>Get your own copy of the repository file:</p><pre>% chicken-setup -fetch-tree &gt;~/my-repository-file</pre><p>Now you can install eggs from your local checkout, with full dependency tracking and without being connected to the internet:</p><pre>% cd ~/tmp
% chicken-setup -local /opt/eggs -tree ~/my-repository-file opengl</pre><a name="linking-extensions-statically"></a><h2>Linking extensions statically</h2><p>The compiler and <a href="chicken-setup.html" class="internal">chicken-setup</a> support statically linked  eggs. The general approach is to generate an object file or static library (in addition to the usual shared library) in your <tt>.setup</tt> script and install it along with the dynamically loadable extension. The setup properties <tt>static</tt>  should contain the name of the object file (or static library) to be linked, when <tt>csc</tt> gets passed the <tt>-static-extensions</tt> option:</p><PRE>
(compile -s -O2 -d1 my-ext.scm)   <I><FONT COLOR="#B22222">; dynamically loadable &quot;normal&quot; version
</FONT></I>(compile -c -O2 -d1 my-ext -unit my-ext)  <I><FONT COLOR="#B22222">; statically linkable version
</FONT></I>(install-extension
  'my-ext
  '(<B><FONT COLOR="#BC8F8F">&quot;my-ext.so&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;my-ext.o&quot;</FONT></B>)
  '((static <B><FONT COLOR="#BC8F8F">&quot;my-ext.o&quot;</FONT></B>)) )
</PRE>
<p>Note the use of the <tt>-unit</tt> option in the second compilation step: static linking must use static library units. <tt>chicken-setup</tt> will perform  platform-dependent file-extension translation for the file list, but does currently not do that for the <tt>static</tt> extension property.</p><p>To actually link with the static version of <tt>my-ext</tt>, do:</p><pre>% csc -static-extensions my-program.scm -uses my-ext</pre><p>The compiler will try to do the right thing, but can not handle all extensions, since the ability to statically link eggs is relatively new. Eggs that support static linking are designated as being able to do so. If you require a statically linkable version of an egg that has not been converted yet, contact the extension author or the CHICKEN  mailing list.</p><p>Previous: <a href="interface-to-external-functions-and-variables.html" class="internal">Interface to external functions and variables</a></p><p>Next: <a href="data-representation.html" class="internal">Data representation</a></p>
</body></html>