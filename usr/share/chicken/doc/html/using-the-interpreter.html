<html><head><title>CHICKEN User's Manual - Using the interpreter</title></head><body>
<p> </p><a name="using-the-interpreter"></a><h1>Using the interpreter</h1><p>CHICKEN provides an interpreter named <tt>csi</tt> for evaluating Scheme programs and expressions interactively.</p><a name="interpreter-command-line-format"></a><h2>Interpreter command line format</h2><p><tt>csi {FILENAME|OPTION</tt>}</p><p>where <tt>FILENAME</tt> specifies a file with Scheme source-code.  If the extension of the source file is <tt>.scm</tt>, it may be omitted. The runtime options described in <a href="http://galinha.ucpel.tche.br/Using%20the%20compiler#Compiler%20command%20line%20format" class="external">Compiler command line format</a> are also available for the interpreter.  If the environment variable <tt>CSI_OPTIONS</tt> is set to a list of options, then these options are additionally passed to every direct or indirect invocation of <tt>csi</tt>. Please note that runtime options (like <tt>-:...</tt>) can not be passed using this method. The options recognized by the interpreter are:</p><dl><dt>&ndash;</dt><dd>Ignore everything on the command-line following this marker. Runtime options (<tt>-:...</tt>) are still recognized.</dd><dt>-i  -case-insensitive</dt><dd>Enables the reader to read symbols case insensitive. The default is to read case sensitive (in violation of R5RS).  This option registers the <tt>case-insensitive</tt> feature identifier.</dd><dt>-b  -batch</dt><dd>Quit the interpreter after processing all command line options.</dd><dt>-e  -eval EXPRESSIONS</dt><dd>Evaluate <tt>EXPRESSIONS</tt>. This option implies <tt>-batch</tt> and <tt>-quiet</tt>, so no startup message will be printed and the interpreter exits after processing all <tt>-eval</tt> options and/or loading files given on the command-line.</dd><dt>-p  -print EXPRESSIONS</dt><dd>Evaluate <tt>EXPRESSIONS</tt> and print the results of each expression using <tt>print</tt>. Implies <tt>-batch</tt> and <tt>-quiet</tt>.</dd><dt>-P  -pretty-print EXPRESSIONS</dt><dd>Evaluate <tt>EXPRESSIONS</tt> and print the results of each expression using <tt>pretty-print</tt>. Implies <tt>-batch</tt> and <tt>-quiet</tt>.</dd><dt>-D  -feature SYMBOL</dt><dd>Registers <tt>SYMBOL</tt> to be a valid feature identifier for <tt>cond-expand</tt> and <tt>feature?</tt>.</dd><dt>-h  -help</dt><dd>Write a summary of the available command line options to standard output and exit.</dd><dt>-I  -include-path PATHNAME</dt><dd>Specifies an alternative search-path for files included via the <tt>include</tt> special form. This option may be given multiple times. If the environment variable <tt>CHICKEN_INCLUDE_PATH</tt> is set, it should contain a list of alternative include pathnames separated by <tt>;</tt>.</dd><dt>-k  -keyword-style STYLE</dt><dd>Enables alternative keyword syntax, where <tt>STYLE</tt> may be either <tt>prefix</tt> (as in Common Lisp) or <tt>suffix</tt> (as in DSSSL). Any other value is ignored.</dd><dt>-n  -no-init</dt><dd>Do not load initialization-file. If this option is not given and the file <tt>./.csirc</tt> or <tt>$HOME/.csirc</tt> exists, then it is loaded before the read-eval-print loop commences.</dd><dt>-w  -no-warnings</dt><dd>Disables any warnings that might be issued by the reader or evaluated code.</dd><dt>-q  -quiet</dt><dd>Do not print a startup message. Also disables generation of call-trace information for interpreted code.</dd><dt>-s  -script PATHNAME</dt><dd>This is equivalent to <tt>-batch -quiet -no-init PATHNAME</tt>. Arguments following <tt>PATHNAME</tt> are available by using  <tt>command-line-arguments</tt> and are not processed as interpreter options. Extra options in the environment variable <tt>CSI_OPTIONS</tt> are ignored.</dd><dt>-ss PATHNAME</dt><dd>The same as <tt>-s PATHNAME</tt> but invokes the procedure <tt>main</tt> with the value of <tt>(command-line-arguments)</tt> as its single argument. If the main procedure returns an integer result, then the interpreter is terminated, returning the integer as the status code back to the invoking process. Any other result terminates the interpreter with a zero exit status.</dd><dt>-R  -require-extension NAME</dt><dd>Equivalent to evaluating <tt>(require-extension NAME)</tt>.</dd><dt>-v  -version</dt><dd>Write the banner with version information to standard output and exit.</dd></dl><a name="writing-scheme-scripts"></a><h2>Writing Scheme scripts</h2><p>Since UNIX shells use the <tt>#!</tt> notation for starting scripts, anything following the characters <tt>#!</tt> is ignored, with the exception of the special symbols <tt>#!optional, #!key, #!rest</tt> and <tt>#!eof</tt>.</p><p>The easiest way is to use the <tt>-script</tt> option like this:</p><pre>% cat foo
#! /usr/local/bin/csi -script
(print (eval (with-input-from-string
                (car (command-line-arguments))
                 read)))</pre><pre>% chmod +x foo
% foo "(+ 3 4)"
7</pre><p>The parameter <tt>command-line-arguments</tt> is set to a list of the parameters that were passed to the Scheme script.  Scripts can be compiled to standalone executables (don't forget to declare used library units).</p><p>CHICKEN supports writing shell scripts in Scheme for these platforms as well, using a slightly different approach. The first example would look like this on Windows:</p><pre>C:&gt;type foo.bat
@;csibatch %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
(print (eval (with-input-from-string
                (car (command-line-arguments))
                read)))</pre><pre>C:&gt;foo "(+ 3 4)"
7</pre><p>Like UNIX scripts, batch files can be compiled. Windows batch scripts do not accept more than 8 arguments.</p><p>Since it is sometimes useful to run a script into the interpreter without actually running it (for example to test specific parts of it), the option <tt>-ss</tt> can be used as an alternative to <tt>-script</tt>. <tt>-ss PATHNAME</tt> is equivalent to <tt>-script PATHNAME</tt> but invokes <tt>(main (command-line-arguments))</tt> after loading all top-level forms of the script file. The result of <tt>main</tt> is returned as the exit status to the shell. Any non-numeric result exits with status zero:</p><pre>% cat hi.scm
(define (main args)
  (print "Hi, " (car args))
  0)
% csi -ss hi.scm you
Hi, you
% csi -q
#;1&gt; ,l hi.scm
#;2&gt; (main (list "ye all"))
Hi, ye all
0
#;3&gt;</pre><a name="toplevel-commands"></a><h2>Toplevel commands</h2><p>The toplevel loop understands a number of special commands:</p><dl><dt>,?</dt><dd>Show summary of available toplevel commands.</dd><dt>,l FILENAME ...</dt><dd>Load files with given <tt>FILENAME</tt>s</dd><dt>,ln FILENAME ...</dt><dd>Load files and print result(s) of each top-level expression.</dd><dt>,p EXP</dt><dd>Pretty-print evaluated expression <tt>EXP</tt>.</dd><dt>,d EXP</dt><dd>Describe result of evaluated expression <tt>EXP</tt>.</dd><dt>,du EXP</dt><dd>Dump contents of the result of evaluated expression <tt>EXP</tt>.</dd><dt>,dur EXP N</dt><dd>Dump <tt>N</tt> bytes of the result of evaluated expression <tt>EXP</tt>.</dd><dt>,exn</dt><dd>Describes the last exception that occurred and adds it to the result history (it can be accessed using the <tt>#</tt> notation).</dd><dt>,q</dt><dd>Quit the interpreter.</dd><dt>,r</dt><dd>Show system information.</dd><dt>,s TEXT ...</dt><dd>Execute shell-command.</dd><dt>,t EXP</dt><dd>Evaluate form and print elapsed time.</dd><dt>,x EXP</dt><dd>Pretty-print macroexpanded expression <tt>EXP</tt> (the expression is not evaluated).</dd><dt>,tr SYMBOL ...</dt><dd>Enables tracing of the toplevel procedures with the given names.</dd></dl><PRE>
#<I><FONT COLOR="#B22222">;1&gt; (fac 10)                       ==&gt; 3628800
</FONT></I>#<I><FONT COLOR="#B22222">;2&gt; ,tr fac
</FONT></I>#<I><FONT COLOR="#B22222">;3&gt; (fac 3)
</FONT></I>|(fac 3)
| (fac 2)
|  (fac 1)
|   (fac 0)
|   fac -&gt; 1 
|  fac -&gt; 1 
| fac -&gt; 2 
|fac -&gt; 6                          =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 6
#<I><FONT COLOR="#B22222">;4&gt; ,utr fac
</FONT></I>#<I><FONT COLOR="#B22222">;5&gt; (fac 3)                        ==&gt; 6
</FONT></I></PRE>
<p>k</p><dl><dt>,utr SYMBOL ...</dt><dd>Disables tracing of the given toplevel procedures.</dd><dt>,br SYMBOL ...</dt><dd>Sets a breakpoint at the procedures named <tt>SYMBOL ...</tt>. Breakpoint can also be trigged using the <tt>breakpoint</tt> procedure.</dd><dt>,ubr SYMBOL ...</dt><dd>Removes breakpoints.</dd><dt>,c</dt><dd>Continues execution from the last invoked breakpoint.</dd><dt>,breakall</dt><dd>Enable breakpoints for all threads (this is the default).</dd><dt>,breakonly THREAD</dt><dd>Enable breakpoints only for the thread returned by the expression <tt>THREAD</tt>.</dd><dt>,info</dt><dd>Lists traced procedures and breakpoints.</dd><dt>,step EXPR</dt><dd>Evaluates <tt>EXPR</tt> in single-stepping mode. On each procedure call you will be presented with a menu that allows stepping to the next call, leaving single-stepping mode or triggering a breakpoint. Note that you will see some internal calls, and unsafe or heavily optimized compiled code might not be stepped at all. Single-stepping mode is also possible by invoking the <tt>singlestep</tt> procedure.</dd></dl><p>You can define your own toplevel commands using the <tt>toplevel-command</tt> procedure:</p><a name="toplevel-command"></a><h2>toplevel-command</h2><pre>[procedure] (toplevel-command SYMBOL PROC [HELPSTRING])</pre><p>Defines or redefines a toplevel interpreter command which can be invoked by entering <tt>,SYMBOL</tt>. <tt>PROC</tt> will be invoked when the command is entered and may read any required argument via <tt>read</tt> (or <tt>read-line</tt>). If the optional argument <tt>HELPSTRING</tt> is given, it will be listed by the <tt>,?</tt> command.</p><a name="history-access"></a><h2>History access</h2><p>The interpreter toplevel accepts the special object <tt>#[INDEX]</tt> which returns the result of entry number <tt>INDEX</tt> in the history list. If the expression for that entry resulted in multiple values, the first result (or an unspecified value for no values) is returned. If no <tt>INDEX</tt> is given (and if a whitespace or closing paranthesis character follows the <tt>#</tt>, then the result of the last expression is returned. Note that the value returned is implicitly quoted.</p><a name="set-describer"></a><h2>set-describer!</h2><pre>[procedure] (set-describer! TAG PROC)</pre><p>Sets a custom description handler that invokes <tt>PROC</tt> when the <tt>,d</tt> command is invoked with a record-type object that has the type <tt>TAG</tt> (a symbol). <tt>PROC</tt> is called with two arguments: the object to be described and an output-port. It should write a possibly useful textual description of the object to the passed output-port. For example:</p><pre>#;1&gt; (define-record point x y)
#;2&gt; (set-describer! 'point 
       (lambda (pt o)
         (print "a point with x=" (point-x pt) " and y=" (point-y pt))))
#;3&gt; ,d (make-point 1 2)
a point with x=1 and y=2</pre><a name="auto-completion-and-edition"></a><h2>Auto-completion and edition</h2><p>On platforms that support it, it is possible to get auto-completion of symbols, history (over different <tt>csi</tt> sessions) and a more feature-full editor for the expressions you type using the <a href="http://www.call-with-current-continuation.org/eggs/readline.html" class="external">http://www.call-with-current-continuation.org/eggs/readline.html</a> egg by Tony Garnock Jones. It is very useful for interactive use of csi.</p><p>To enable it install the egg and put this in your <tt>~/.csirc</tt> file:</p><pre>(use readline regex)
(current-input-port (make-gnu-readline-port))
(gnu-history-install-file-manager 
  (string-append (or (getenv "HOME") ".") "/.csi.history"))</pre><p>More details are available in <a href="http://www.call-with-current-continuation.org/eggs/readline.html" class="external">the egg's documentation</a>.</p><a name="accessing-documentation"></a><h2>Accessing documentation</h2><p>You can access the manual directly from <tt>csi</tt> using the <a href="http://www.call-with-current-continuation.org/eggs/man.html" class="external">man</a> extension by Mario Domenech Goulart.</p><p>To enable it install the egg and put this in your <tt>~/.csirc</tt> file:</p><pre>(use man)
(man:load)</pre><p>Then, in <tt>csi</tt>, you can search for definitions using <tt>man:search</tt> as in:</p><pre>(man:search "case")</pre><p>Note that the search uses regular expressions. To view the documentation for one entry from the manual, use <tt>man:help</tt> as in:</p><pre>(man:help "case-lambda")</pre><p>Note: Currently the documentation provided by the <tt>man</tt> extension corresponds to Chicken's 2.429, one of the last releases whose documentation was in the texinfo format (the format the <tt>man</tt> extension parses).</p><hr/><p>Previous: <a href="using-the-compiler.html" class="internal">Using the compiler</a></p><p>Next: <a href="supported-language.html" class="internal">Supported language</a></p>
</body></html>