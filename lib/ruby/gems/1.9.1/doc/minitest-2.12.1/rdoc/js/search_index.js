var search_data = {"index":{"searchIndex":["hoe","minitest","minitest","assertion","assertions","expectations","mock","skip","spec","unit","guard","testcase","object","prideio","pridelol","add_setup_hook()","add_teardown_hook()","after()","after_setup()","after_teardown()","assert()","assert_block()","assert_empty()","assert_equal()","assert_in_delta()","assert_in_epsilon()","assert_includes()","assert_instance_of()","assert_kind_of()","assert_match()","assert_nil()","assert_operator()","assert_output()","assert_performance()","assert_performance_constant()","assert_performance_exponential()","assert_performance_linear()","assert_performance_power()","assert_predicate()","assert_raises()","assert_respond_to()","assert_same()","assert_send()","assert_silent()","assert_throws()","before()","before_setup()","before_teardown()","bench()","bench_exp()","bench_linear()","bench_performance_constant()","bench_performance_exponential()","bench_performance_linear()","bench_range()","bench_range()","benchmark_suites()","capture_io()","children()","diff()","diff()","diff=()","exception_details()","expect()","fit_error()","fit_exponential()","fit_linear()","fit_power()","flunk()","i_suck_and_my_tests_are_order_dependent!()","io()","io?()","it()","jruby?()","let()","message()","mri?()","mu_pp()","mu_pp_for_diff()","must_be()","must_be_empty()","must_be_instance_of()","must_be_kind_of()","must_be_nil()","must_be_same_as()","must_be_silent()","must_be_within_delta()","must_be_within_epsilon()","must_equal()","must_include()","must_match()","must_output()","must_raise()","must_respond_to()","must_send()","must_throw()","pass()","passed?()","pride()","pride()","print()","refute()","refute_empty()","refute_equal()","refute_in_delta()","refute_in_epsilon()","refute_includes()","refute_instance_of()","refute_kind_of()","refute_match()","refute_nil()","refute_operator()","refute_predicate()","refute_respond_to()","refute_same()","register_spec_type()","rubinius?()","run()","setup()","sigma()","skip()","spec_type()","subject()","teardown()","validation_for_fit()","verify()","windows?()","wont_be()","wont_be_close_to()","wont_be_empty()","wont_be_instance_of()","wont_be_kind_of()","wont_be_nil()","wont_be_same_as()","wont_be_within_delta()","wont_be_within_epsilon()","wont_equal()","wont_include()","wont_match()","wont_respond_to()","history","manifest","readme"],"longSearchIndex":["hoe","hoe::minitest","minitest","minitest::assertion","minitest::assertions","minitest::expectations","minitest::mock","minitest::skip","minitest::spec","minitest::unit","minitest::unit::guard","minitest::unit::testcase","object","prideio","pridelol","minitest::unit::testcase::add_setup_hook()","minitest::unit::testcase::add_teardown_hook()","minitest::spec::after()","minitest::unit::testcase#after_setup()","minitest::unit::testcase#after_teardown()","minitest::assertions#assert()","minitest::assertions#assert_block()","minitest::assertions#assert_empty()","minitest::assertions#assert_equal()","minitest::assertions#assert_in_delta()","minitest::assertions#assert_in_epsilon()","minitest::assertions#assert_includes()","minitest::assertions#assert_instance_of()","minitest::assertions#assert_kind_of()","minitest::assertions#assert_match()","minitest::assertions#assert_nil()","minitest::assertions#assert_operator()","minitest::assertions#assert_output()","minitest::unit::testcase#assert_performance()","minitest::unit::testcase#assert_performance_constant()","minitest::unit::testcase#assert_performance_exponential()","minitest::unit::testcase#assert_performance_linear()","minitest::unit::testcase#assert_performance_power()","minitest::assertions#assert_predicate()","minitest::assertions#assert_raises()","minitest::assertions#assert_respond_to()","minitest::assertions#assert_same()","minitest::assertions#assert_send()","minitest::assertions#assert_silent()","minitest::assertions#assert_throws()","minitest::spec::before()","minitest::unit::testcase#before_setup()","minitest::unit::testcase#before_teardown()","minitest::spec::bench()","minitest::unit::testcase::bench_exp()","minitest::unit::testcase::bench_linear()","minitest::spec::bench_performance_constant()","minitest::spec::bench_performance_exponential()","minitest::spec::bench_performance_linear()","minitest::spec::bench_range()","minitest::unit::testcase::bench_range()","minitest::unit::testcase::benchmark_suites()","minitest::assertions#capture_io()","minitest::spec::children()","minitest::assertions#diff()","minitest::assertions::diff()","minitest::assertions::diff=()","minitest::assertions#exception_details()","minitest::mock#expect()","minitest::unit::testcase#fit_error()","minitest::unit::testcase#fit_exponential()","minitest::unit::testcase#fit_linear()","minitest::unit::testcase#fit_power()","minitest::assertions#flunk()","minitest::unit::testcase::i_suck_and_my_tests_are_order_dependent!()","minitest::unit::testcase#io()","minitest::unit::testcase#io?()","minitest::spec::it()","minitest::unit::guard#jruby?()","minitest::spec::let()","minitest::assertions#message()","minitest::unit::guard#mri?()","minitest::assertions#mu_pp()","minitest::assertions#mu_pp_for_diff()","minitest::expectations#must_be()","minitest::expectations#must_be_empty()","minitest::expectations#must_be_instance_of()","minitest::expectations#must_be_kind_of()","minitest::expectations#must_be_nil()","minitest::expectations#must_be_same_as()","minitest::expectations#must_be_silent()","minitest::expectations#must_be_within_delta()","minitest::expectations#must_be_within_epsilon()","minitest::expectations#must_equal()","minitest::expectations#must_include()","minitest::expectations#must_match()","minitest::expectations#must_output()","minitest::expectations#must_raise()","minitest::expectations#must_respond_to()","minitest::expectations#must_send()","minitest::expectations#must_throw()","minitest::assertions#pass()","minitest::unit::testcase#passed?()","prideio#pride()","pridelol#pride()","prideio#print()","minitest::assertions#refute()","minitest::assertions#refute_empty()","minitest::assertions#refute_equal()","minitest::assertions#refute_in_delta()","minitest::assertions#refute_in_epsilon()","minitest::assertions#refute_includes()","minitest::assertions#refute_instance_of()","minitest::assertions#refute_kind_of()","minitest::assertions#refute_match()","minitest::assertions#refute_nil()","minitest::assertions#refute_operator()","minitest::assertions#refute_predicate()","minitest::assertions#refute_respond_to()","minitest::assertions#refute_same()","minitest::spec::register_spec_type()","minitest::unit::guard#rubinius?()","minitest::unit::testcase#run()","minitest::unit::testcase#setup()","minitest::unit::testcase#sigma()","minitest::assertions#skip()","minitest::spec::spec_type()","minitest::spec::subject()","minitest::unit::testcase#teardown()","minitest::unit::testcase#validation_for_fit()","minitest::mock#verify()","minitest::unit::guard#windows?()","minitest::expectations#wont_be()","minitest::expectations#wont_be_close_to()","minitest::expectations#wont_be_empty()","minitest::expectations#wont_be_instance_of()","minitest::expectations#wont_be_kind_of()","minitest::expectations#wont_be_nil()","minitest::expectations#wont_be_same_as()","minitest::expectations#wont_be_within_delta()","minitest::expectations#wont_be_within_epsilon()","minitest::expectations#wont_equal()","minitest::expectations#wont_include()","minitest::expectations#wont_match()","minitest::expectations#wont_respond_to()","","",""],"info":[["Hoe","","Hoe.html","",""],["Hoe::Minitest","","Hoe/Minitest.html","",""],["MiniTest","","MiniTest.html","","<p>A simple and clean mock object framework.\n<p>Minimal (mostly drop-in) replacement for test-unit.\n<p>minitest/{unit,spec,mock,benchmark} …\n"],["MiniTest::Assertion","","MiniTest/Assertion.html","","<p>Assertion base class\n"],["MiniTest::Assertions","","MiniTest/Assertions.html","","<p>MiniTest Assertions.  All assertion methods accept a <code>msg</code> which\nis printed if the assertion fails.\n"],["MiniTest::Expectations","","MiniTest/Expectations.html","","<p>It’s where you hide your “assertions”.\n"],["MiniTest::Mock","","MiniTest/Mock.html","","<p>All mock objects are an instance of Mock\n"],["MiniTest::Skip","","MiniTest/Skip.html","","<p>Assertion raised when skipping a test\n"],["MiniTest::Spec","","MiniTest/Spec.html","","<p>MiniTest::Spec – The faster, better, less-magical spec framework!\n<p>For a list of expectations, see MiniTest::Expectations …\n"],["MiniTest::Unit","","MiniTest/Unit.html","",""],["MiniTest::Unit::Guard","","MiniTest/Unit/Guard.html","","<p>Provides a simple set of guards that you can use in your tests to skip\nexecution if it is not applicable. …\n"],["MiniTest::Unit::TestCase","","MiniTest/Unit/TestCase.html","","<p>Subclass TestCase to create your own tests. Typically you’ll want a\nTestCase subclass per implementation …\n"],["Object","","Object.html","",""],["PrideIO","","PrideIO.html","","<p>Show your testing pride!\n"],["PrideLOL","","PrideLOL.html","","<p>If you thought the PrideIO was colorful…\n<p>(Inspired by lolcat, but with clean math)\n"],["add_setup_hook","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-add_setup_hook","(arg=nil, &block)","<p>Adds a block of code that will be executed before every TestCase is run.\nEquivalent to <code>setup</code>, but usable …\n"],["add_teardown_hook","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-add_teardown_hook","(arg=nil, &block)","<p>Adds a block of code that will be executed after every TestCase is run.\nEquivalent to <code>teardown</code>, but usable …\n"],["after","MiniTest::Spec","MiniTest/Spec.html#method-c-after","(type = :each, &block)","<p>Define an ‘after’ action. Inherits the way normal methods should.\n<p>NOTE: <code>type</code> is ignored and is only there …\n"],["after_setup","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-after_setup","()","<p>Runs before every test after setup. Use this to refactor test\ninitialization.\n"],["after_teardown","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-after_teardown","()","<p>Runs after every teardown. Use this to refactor test cleanup.\n"],["assert","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert","(test, msg = nil)","<p>Fails unless <code>test</code> is a true value.\n"],["assert_block","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_block","(msg = nil)","<p>Fails unless the block returns a true value.\n"],["assert_empty","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_empty","(obj, msg = nil)","<p>Fails unless <code>obj</code> is empty.\n"],["assert_equal","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_equal","(exp, act, msg = nil)","<p>Fails unless <code>exp == act</code> printing the difference between the\ntwo, if possible.\n<p>If there is no visible difference …\n"],["assert_in_delta","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code>\nare within <code>delta</code> of each other.\n\n<pre>assert_in_delta Math::PI, ...</pre>\n"],["assert_in_epsilon","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_in_epsilon","(a, b, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code>\nhave a relative error less than <code>epsilon</code>.\n"],["assert_includes","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_includes","(collection, obj, msg = nil)","<p>Fails unless <code>collection</code> includes <code>obj</code>.\n"],["assert_instance_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_instance_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is an instance of <code>cls</code>.\n"],["assert_kind_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_kind_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is a kind of <code>cls</code>.\n"],["assert_match","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_match","(exp, act, msg = nil)","<p>Fails unless <code>exp</code> is <code>=~</code> <code>act</code>.\n"],["assert_nil","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_nil","(obj, msg = nil)","<p>Fails unless <code>obj</code> is nil\n"],["assert_operator","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_operator","(o1, op, o2 = UNDEFINED, msg = nil)","<p>For testing with binary operators.\n\n<pre>assert_operator 5, :&lt;=, 4</pre>\n"],["assert_output","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_output","(stdout = nil, stderr = nil)","<p>Fails if stdout or stderr do not output the expected results. Pass in nil\nif you don’t care about that …\n"],["assert_performance","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance","(validation, &work)","<p>Runs the given <code>work</code>, gathering the times of each run. Range\nand times are then passed to a given <code>validation</code> …\n"],["assert_performance_constant","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_constant","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to\nmatch a constant rate (eg, linear slope …\n"],["assert_performance_exponential","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_exponential","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to\nmatch a exponential curve within a given …\n"],["assert_performance_linear","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_linear","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to\nmatch a straight line within a given error …\n"],["assert_performance_power","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_power","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered curve\nfit to match a power curve within a given …\n"],["assert_predicate","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_predicate","(o1, op, msg = nil)","<p>For testing with predicates.\n\n<pre>assert_predicate str, :empty?</pre>\n<p>This is really meant for specs and is front-ended …\n"],["assert_raises","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_raises","(*exp)","<p>Fails unless the block raises one of <code>exp</code>. Returns the\nexception matched so you can check the message, …\n"],["assert_respond_to","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_respond_to","(obj, meth, msg = nil)","<p>Fails unless <code>obj</code> responds to <code>meth</code>.\n"],["assert_same","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_same","(exp, act, msg = nil)","<p>Fails unless <code>exp</code> and <code>act</code> are #equal?\n"],["assert_send","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_send","(send_ary, m = nil)","<p><code>send_ary</code> is a receiver, message and arguments.\n<p>Fails unless the call returns a true value TODO: I should …\n"],["assert_silent","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_silent","()","<p>Fails if the block outputs anything to stderr or stdout.\n<p>See also: #assert_output\n"],["assert_throws","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_throws","(sym, msg = nil)","<p>Fails unless the block throws <code>sym</code>\n"],["before","MiniTest::Spec","MiniTest/Spec.html#method-c-before","(type = :each, &block)","<p>Define a ‘before’ action. Inherits the way normal methods should.\n<p>NOTE: <code>type</code> is ignored and is only there …\n"],["before_setup","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-before_setup","()","<p>Runs before every setup. Use this to refactor test initialization.\n"],["before_teardown","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-before_teardown","()","<p>Runs after every test before teardown. Use this to refactor test\ninitialization.\n"],["bench","MiniTest::Spec","MiniTest/Spec.html#method-c-bench","(name, &block)","<p>This is used to define a new benchmark method. You usually don’t use this\ndirectly and is intended for …\n"],["bench_exp","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-bench_exp","(min, max, base = 10)","<p>Returns a set of ranges stepped exponentially from <code>min</code> to\n<code>max</code> by powers of <code>base</code>. Eg:\n\n<pre>bench_exp(2, 16, ...</pre>\n"],["bench_linear","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-bench_linear","(min, max, step = 10)","<p>Returns a set of ranges stepped linearly from <code>min</code> to\n<code>max</code> by <code>step</code>. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">bench_linear</span>(<span class=\"ruby-value\">20</span>, <span class=\"ruby-value\">40</span>, <span class=\"ruby-value\">10</span>) <span class=\"ruby-comment\"># =&gt; [20, ...</span>\n</pre>\n"],["bench_performance_constant","MiniTest::Spec","MiniTest/Spec.html#method-c-bench_performance_constant","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is constant.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">describe</span> <span class=\"ruby-string\">&quot;my class&quot;</span> <span class=\"ruby-keyword\">do</span>\n  <span class=\"ruby-identifier\">bench_performance_constant</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["bench_performance_exponential","MiniTest::Spec","MiniTest/Spec.html#method-c-bench_performance_exponential","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is exponential.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">describe</span> <span class=\"ruby-string\">&quot;my class&quot;</span> <span class=\"ruby-keyword\">do</span>\n  <span class=\"ruby-identifier\">bench_performance_exponential</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["bench_performance_linear","MiniTest::Spec","MiniTest/Spec.html#method-c-bench_performance_linear","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is linear.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">describe</span> <span class=\"ruby-string\">&quot;my class&quot;</span> <span class=\"ruby-keyword\">do</span>\n  <span class=\"ruby-identifier\">bench_performance_linear</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["bench_range","MiniTest::Spec","MiniTest/Spec.html#method-c-bench_range","(&block)","<p>Specifies the ranges used for benchmarking for that class.\n\n<pre>bench_range do\n  bench_exp(2, 16, 2)\nend</pre>\n<p>See …\n"],["bench_range","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-bench_range","()","<p>Specifies the ranges used for benchmarking for that class. Defaults to\nexponential growth from 1 to 10k …\n"],["benchmark_suites","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-benchmark_suites","()","<p>Returns all test suites that have benchmark methods.\n"],["capture_io","MiniTest::Assertions","MiniTest/Assertions.html#method-i-capture_io","()","<p>Captures $stdout and $stderr into strings:\n\n<pre>out, err = capture_io do\n  warn &quot;You did a bad thing&quot;\nend\n ...</pre>\n"],["children","MiniTest::Spec","MiniTest/Spec.html#method-c-children","()","<p>Returns the children of this spec.\n"],["diff","MiniTest::Assertions","MiniTest/Assertions.html#method-i-diff","(exp, act)","<p>Returns a diff between <code>exp</code> and <code>act</code>. If there is\nno known diff command or if it doesn’t make sense to …\n"],["diff","MiniTest::Assertions","MiniTest/Assertions.html#method-c-diff","()","<p>Returns the diff command to use in #diff. Tries to intelligently figure out\nwhat diff to use.\n"],["diff=","MiniTest::Assertions","MiniTest/Assertions.html#method-c-diff-3D","(o)","<p>Set the diff command to use in #diff.\n"],["exception_details","MiniTest::Assertions","MiniTest/Assertions.html#method-i-exception_details","(e, msg)","<p>Returns details for exception <code>e</code>\n"],["expect","MiniTest::Mock","MiniTest/Mock.html#method-i-expect","(name, retval, args=[])","<p>Expect that method <code>name</code> is called, optionally with\n<code>args</code>, and returns <code>retval</code>.\n\n<pre>@mock.expect(:meaning_of_life, ...</pre>\n"],["fit_error","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_error","(xys)","<p>Takes an array of x/y pairs and calculates the general R^2 value.\n<p>See: en.wikipedia.org/wiki/Coefficient_of_determination …\n"],["fit_exponential","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_exponential","(xs, ys)","<p>To fit a functional form: y = ae^(bx).\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingExponential.html …\n"],["fit_linear","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_linear","(xs, ys)","<p>Fits the functional form: a + bx.\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFitting.html …\n"],["fit_power","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_power","(xs, ys)","<p>To fit a functional form: y = ax^b.\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html …\n"],["flunk","MiniTest::Assertions","MiniTest/Assertions.html#method-i-flunk","(msg = nil)","<p>Fails with <code>msg</code>\n"],["i_suck_and_my_tests_are_order_dependent!","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-i_suck_and_my_tests_are_order_dependent-21","()","<p>Call this at the top of your tests when you absolutely positively need to\nhave ordered tests. In doing …\n"],["io","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-io","()","<p>Return the output IO object\n"],["io?","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-io-3F","()","<p>Have we hooked up the IO yet?\n"],["it","MiniTest::Spec","MiniTest/Spec.html#method-c-it","(desc = \"anonymous\", &block)","<p>Define an expectation with name <code>desc</code>. Name gets morphed to a\nproper test method name. For some freakish …\n"],["jruby?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-jruby-3F","(platform = RUBY_PLATFORM)","<p>Is this running on jruby?\n"],["let","MiniTest::Spec","MiniTest/Spec.html#method-c-let","(name, &block)","<p>Essentially, define an accessor for <code>name</code> with\n<code>block</code>.\n<p>Why use let instead of def? I honestly don’t know. …\n"],["message","MiniTest::Assertions","MiniTest/Assertions.html#method-i-message","(msg = nil, ending = \".\", &default)","<p>Returns a proc that will output <code>msg</code> along with the default\nmessage.\n"],["mri?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-mri-3F","(platform = RUBY_DESCRIPTION)","<p>Is this running on mri?\n"],["mu_pp","MiniTest::Assertions","MiniTest/Assertions.html#method-i-mu_pp","(obj)","<p>This returns a human-readable version of <code>obj</code>. By default\n#inspect is called. You can override this to …\n"],["mu_pp_for_diff","MiniTest::Assertions","MiniTest/Assertions.html#method-i-mu_pp_for_diff","(obj)","<p>This returns a diff-able human-readable version of <code>obj</code>. This\ndiffers from the regular mu_pp because it …\n"],["must_be","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be","","<p>See MiniTest::Assertions#assert_operator\n\n<pre>n.must_be :&lt;=, 42</pre>\n<p>This can also do predicates:\n"],["must_be_empty","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_empty","","<p>See MiniTest::Assertions#assert_empty.\n\n<pre>collection.must_be_empty</pre>\n"],["must_be_instance_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_instance_of","","<p>See MiniTest::Assertions#assert_instance_of\n\n<pre>obj.must_be_instance_of klass</pre>\n"],["must_be_kind_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_kind_of","","<p>See MiniTest::Assertions#assert_kind_of\n\n<pre>obj.must_be_kind_of mod</pre>\n"],["must_be_nil","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_nil","","<p>See MiniTest::Assertions#assert_nil\n\n<pre>obj.must_be_nil</pre>\n"],["must_be_same_as","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_same_as","","<p>See MiniTest::Assertions#assert_same\n\n<pre>a.must_be_same_as b</pre>\n"],["must_be_silent","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_silent","","<p>See MiniTest::Assertions#assert_silent\n\n<pre>proc { ... }.must_be_silent</pre>\n"],["must_be_within_delta","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_within_delta","","<p>See MiniTest::Assertions#assert_in_delta\n\n<pre>n.must_be_close_to m [, delta]</pre>\n"],["must_be_within_epsilon","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_within_epsilon","","<p>See MiniTest::Assertions#assert_in_epsilon\n\n<pre>n.must_be_within_epsilon m [, epsilon]</pre>\n"],["must_equal","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_equal","","<p>See MiniTest::Assertions#assert_equal\n\n<pre>a.must_equal b</pre>\n"],["must_include","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_include","","<p>See MiniTest::Assertions#assert_includes\n\n<pre>collection.must_include obj</pre>\n"],["must_match","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_match","","<p>See MiniTest::Assertions#assert_match\n\n<pre>a.must_match b</pre>\n"],["must_output","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_output","","<p>See MiniTest::Assertions#assert_output\n\n<pre>proc { ... }.must_output out_or_nil [, err]</pre>\n"],["must_raise","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_raise","","<p>See MiniTest::Assertions#assert_raises\n\n<pre>proc { ... }.must_raise exception</pre>\n"],["must_respond_to","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_respond_to","","<p>See MiniTest::Assertions#assert_respond_to\n\n<pre>obj.must_respond_to msg</pre>\n"],["must_send","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_send","","<p>See MiniTest::Assertions#assert_send TODO: remove me\n\n<pre>a.must_send</pre>\n"],["must_throw","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_throw","","<p>See MiniTest::Assertions#assert_throws\n\n<pre>proc { ... }.must_throw sym</pre>\n"],["pass","MiniTest::Assertions","MiniTest/Assertions.html#method-i-pass","(msg = nil)","<p>used for counting assertions\n"],["passed?","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-passed-3F","()","<p>Returns true if the test passed.\n"],["pride","PrideIO","PrideIO.html#method-i-pride","(string)","<p>Color a string.\n"],["pride","PrideLOL","PrideLOL.html#method-i-pride","(string)","<p>Make the string even more colorful. Damnit.\n"],["print","PrideIO","PrideIO.html#method-i-print","(o)","<p>Wrap print to colorize the output.\n"],["refute","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute","(test, msg = nil)","<p>Fails if <code>test</code> is a true value\n"],["refute_empty","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_empty","(obj, msg = nil)","<p>Fails if <code>obj</code> is empty.\n"],["refute_equal","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_equal","(exp, act, msg = nil)","<p>Fails if <code>exp == act</code>.\n<p>For floats use refute_in_delta.\n"],["refute_in_delta","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> is within\n<code>delta</code> of <code>act</code>\n\n<pre>refute_in_delta Math::PI, (22.0 / 7.0)</pre>\n"],["refute_in_epsilon","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_in_epsilon","(a, b, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> and <code>act</code> have\na relative error less than <code>epsilon</code>.\n"],["refute_includes","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_includes","(collection, obj, msg = nil)","<p>Fails if <code>collection</code> includes <code>obj</code>\n"],["refute_instance_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_instance_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is an instance of <code>cls</code>\n"],["refute_kind_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_kind_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is a kind of <code>cls</code>\n"],["refute_match","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_match","(exp, act, msg = nil)","<p>Fails if <code>exp</code> <code>=~</code> <code>act</code>\n"],["refute_nil","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_nil","(obj, msg = nil)","<p>Fails if <code>obj</code> is nil.\n"],["refute_operator","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_operator","(o1, op, o2 = UNDEFINED, msg = nil)","<p>Fails if <code>o1</code> is not <code>op</code> <code>o2</code>. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, :<span class=\"ruby-operator\">&gt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; pass</span>\n<span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, :<span class=\"ruby-operator\">&lt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; fail</span>\n</pre>\n"],["refute_predicate","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_predicate","(o1, op, msg = nil)","<p>For testing with predicates.\n\n<pre>refute_predicate str, :empty?</pre>\n<p>This is really meant for specs and is front-ended …\n"],["refute_respond_to","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_respond_to","(obj, meth, msg = nil)","<p>Fails if <code>obj</code> responds to the message <code>meth</code>.\n"],["refute_same","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_same","(exp, act, msg = nil)","<p>Fails if <code>exp</code> is the same (by object identity) as\n<code>act</code>.\n"],["register_spec_type","MiniTest::Spec","MiniTest/Spec.html#method-c-register_spec_type","(*args, &block)","<p>Register a new type of spec that matches the spec’s description. This\nmethod can take either a Regexp …\n"],["rubinius?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-rubinius-3F","(platform = defined?(RUBY_ENGINE) && RUBY_ENGINE)","<p>Is this running on rubinius?\n"],["run","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-run","(runner)","<p>Runs the tests reporting the status to <code>runner</code>\n"],["setup","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-setup","()","<p>Runs before every test. Use this to refactor test initialization.\n"],["sigma","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-sigma","(enum, &block)","<p>Enumerates over <code>enum</code> mapping <code>block</code> if given,\nreturning the sum of the result. Eg:\n\n<pre>sigma([1, 2, 3])    ...</pre>\n"],["skip","MiniTest::Assertions","MiniTest/Assertions.html#method-i-skip","(msg = nil, bt = caller)","<p>Skips the current test. Gets listed at the end of the run but doesn’t cause\na failure exit code.\n"],["spec_type","MiniTest::Spec","MiniTest/Spec.html#method-c-spec_type","(desc)","<p>Figure out the spec class to use based on a spec’s description. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">spec_type</span>(<span class=\"ruby-string\">&quot;BlahController&quot;</span>) <span class=\"ruby-comment\"># =&gt; MiniTest::Spec::Rails</span>\n</pre>\n"],["subject","MiniTest::Spec","MiniTest/Spec.html#method-c-subject","(&block)","<p>Another lazy man’s accessor generator. Made even more lazy by setting the\nname for you to <code>subject</code>.\n"],["teardown","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-teardown","()","<p>Runs after every test. Use this to refactor test cleanup.\n"],["validation_for_fit","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-validation_for_fit","(msg, threshold)","<p>Returns a proc that calls the specified fit method and asserts that the\nerror is within a tolerable threshold. …\n"],["verify","MiniTest::Mock","MiniTest/Mock.html#method-i-verify","()","<p>Verify that all methods were called as expected. Raises\n<code>MockExpectationError</code> if the mock object was not …\n"],["windows?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-windows-3F","(platform = RUBY_PLATFORM)","<p>Is this running on windows?\n"],["wont_be","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be","","<p>See MiniTest::Assertions#refute_operator\n\n<pre>n.wont_be :&lt;=, 42</pre>\n<p>This can also do predicates:\n"],["wont_be_close_to","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_close_to","",""],["wont_be_empty","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_empty","","<p>See MiniTest::Assertions#refute_empty\n\n<pre>collection.wont_be_empty</pre>\n"],["wont_be_instance_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_instance_of","","<p>See MiniTest::Assertions#refute_instance_of\n\n<pre>obj.wont_be_instance_of klass</pre>\n"],["wont_be_kind_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_kind_of","","<p>See MiniTest::Assertions#refute_kind_of\n\n<pre>obj.wont_be_kind_of mod</pre>\n"],["wont_be_nil","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_nil","","<p>See MiniTest::Assertions#refute_nil\n\n<pre>obj.wont_be_nil</pre>\n"],["wont_be_same_as","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_same_as","","<p>See MiniTest::Assertions#refute_same\n\n<pre>a.wont_be_same_as b</pre>\n"],["wont_be_within_delta","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_within_delta","","<p>See MiniTest::Assertions#refute_in_delta\n\n<pre>n.wont_be_close_to m [, delta]</pre>\n"],["wont_be_within_epsilon","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_within_epsilon","","<p>See MiniTest::Assertions#refute_in_epsilon\n\n<pre>n.wont_be_within_epsilon m [, epsilon]</pre>\n"],["wont_equal","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_equal","","<p>See MiniTest::Assertions#refute_equal\n\n<pre>a.wont_equal b</pre>\n"],["wont_include","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_include","","<p>See MiniTest::Assertions#refute_includes\n\n<pre>collection.wont_include obj</pre>\n"],["wont_match","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_match","","<p>See MiniTest::Assertions#refute_match\n\n<pre>a.wont_match b</pre>\n"],["wont_respond_to","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_respond_to","","<p>See MiniTest::Assertions#refute_respond_to\n\n<pre>obj.wont_respond_to msg</pre>\n"],["History","","History_txt.html","","<p>2.12.1 / 2012-04-10\n<p>1 minor enhancement:\n<p>Added ruby releases to History.txt to make it easier to see what …\n"],["Manifest","","Manifest_txt.html","","<p>.autotest History.txt Manifest.txt README.txt Rakefile design_rationale.rb\nlib/hoe/minitest.rb lib/minitest/autorun.rb …\n"],["README","","README_txt.html","","<p>minitest/{unit,spec,mock,benchmark}\n<p>home  &mdash; github.com/seattlerb/minitest\n<p>rdoc  &mdash; docs.seattlerb.org/minitest …\n"]]}}